// -*-Mode: C++;-*-

// * BeginRiceCopyright *****************************************************
//
// $HeadURL$
// $Id$
//
// --------------------------------------------------------------------------
// Part of HPCToolkit (hpctoolkit.org)
//
// Information about sources of support for research and development of
// HPCToolkit is at 'hpctoolkit.org' and in 'README.Acknowledgments'.
// --------------------------------------------------------------------------
//
// Copyright ((c)) 2020, Rice University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the distribution.
//
// * Neither the name of Rice University (RICE) nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// This software is provided by RICE and contributors "as is" and any
// express or implied warranties, including, but not limited to, the
// implied warranties of merchantability and fitness for a particular
// purpose are disclaimed. In no event shall RICE or contributors be
// liable for any direct, indirect, incidental, special, exemplary, or
// consequential damages (including, but not limited to, procurement of
// substitute goods or services; loss of use, data, or profits; or
// business interruption) however caused and on any theory of liability,
// whether in contract, strict liability, or tort (including negligence
// or otherwise) arising in any way out of the use of this software, even
// if advised of the possibility of such damage.
//
// ******************************************************* EndRiceCopyright *

#include "args.hpp"

#include "lib/profile/source.hpp"
#include "lib/profile/finalizers/struct.hpp"
#include "include/hpctoolkit-config.h"

#include <omp.h>
#include <iostream>
#include <getopt.h>

using namespace hpctoolkit;
namespace fs = stdshim::filesystem;

static const std::string version = HPCTOOLKIT_VERSION;
static const std::string summary =
"[options]... <measurement files/directories>...";
static const std::string header = R"EOF(
Attribute measurements made by `hpcrun' back to the original source using maps
generated by `hpcstruct', packaging the result as a monolithic database
viewable in `hpc[trace]viewer'.
)EOF";
static const std::string footer = R"EOF(
For best results, compile your application with debug information, generate
structure data (`-S'), and provide prefix replacements (`-R') as needed.
)EOF";

static const std::string options = R"EOF(
General Options:
  -h, --help                  Display this help and exit.
      --version               Print version information and exit.
  -v, --verbose               Increase the verbosity of messages.
  -q, --quiet                 Disable all non-error messages.
  -o FILE                     Output to the given filename.
  -Q, --dry-run               Disable output. Useful for performance testing.
  -jN                         Use N threads to accelerate processing.

Input Options:
  -S, --structure=FILE        Read binary structure information from FILE.
  -R, --replace-prefix=FROM=TO
                              Replace path prefixes when searching for source
                              files and binaries. Use `\=' to escape `=', use
                              `\\' to escape `\'.

Output Options:
  -n, --title=NAME            Specify a title for the output database.
  -f, --format=FORMAT
                              Specify the database output format.
                              Default is `exmldb` for the usual format,
                              using `sparse` outputs in the new sparse format.
      --never-merge-lines
                              Always output an instruction-level database, even
                              in cases where the output format is not able to
                              fully support instruction-level attribution.
  -M (none|STAT[,STAT...])
                              Disable or enable generation of global
                              statistics. STAT is one of the following:
                                    sum: Linear sum (over threads)
                                 normal: Linear mean and standard deviation
                                extrema: Minimum and maximum
                                  stats: All of the above
                              `none' disables all global statistics.
      --no-thread-local       Disable generation of thread-local statistics.
      --no-traces             Disable generation of traces.
      --no-source             Disable embedded source output.

Compatibility Options:
      --name=NAME             Equivalent to `-n NAME'
      --metric-db (yes|no)    `no' is equivalent to --no-thread-local.

Current Obsolete Options:
  -I, --include=DIR           Unsupported, use `-R' instead.
      --debug                 Depreciated, use `-v' or `-q' instead.
      --force-metric          Unsupported.
      --remove-redundancy     Unsupported (effect is always enabled).
      --struct-id             Unsupported.
)EOF";

ProfArgs::ProfArgs(int argc, char* const argv[])
  : title(), threads(1), instructionGrain(false), output("hpctoolkit-database"),
    include_sources(true), include_traces(true), include_thread_local(true),
    format(Format::exmldb) {
  int arg_instructionGrain = instructionGrain;
  int arg_includeSources = include_sources;
  int arg_includeTraces = include_traces;
  struct option longopts[] = {
    // These first ones are more special and must be in this order.
    {"version", no_argument, NULL, 0},
    {"metric-db", required_argument, NULL, 0},
    {"no-thread-local", no_argument, NULL, 0},
    // The rest can be in any order
    {"help", no_argument, NULL, 'h'},
    {"verbose", no_argument, NULL, 'v'},
    {"quiet", no_argument, NULL, 'q'},
    {"dry-run", no_argument, NULL, 'Q'},
    {"replace-prefix", required_argument, NULL, 'R'},
    {"title", required_argument, NULL, 'n'},
    {"format", required_argument, NULL, 'f'},
    {"never-merge-lines", no_argument, &arg_instructionGrain, 1},
    {"no-traces", no_argument, &arg_includeTraces, 0},
    {"no-source", no_argument, &arg_includeSources, 0},
    {"name", required_argument, NULL, 'n'},
    {0, 0, 0, 0}
  };

  bool seenNoThreadLocal = false;
  bool seenMetricDB = false;
  bool dryRun = false;

  int opt;
  int longopt;
  while((opt = getopt_long(argc, argv, "hvqQo:j:S:R:n:f:M:", longopts, &longopt)) >= 0) {
    switch(opt) {
    case 'h':
      std::cout << "Usage: " << fs::path(argv[0]).filename().string()
                             << " " << summary  // header begins with a '\n'
                << header << options << footer;
      std::exit(0);
    case 'v':
      // Eventually, verbosity++;
      break;
    case 'q':
      // Eventually, assert(verbosity == 1); verbosity = 0;
      break;
    case 'o':
      output = fs::path(optarg);
      break;
    case 'Q':
      dryRun = true;
      break;
    case 'j': {
      std::size_t pos;
      threads = std::stoi(optarg, &pos, 10);
      if(pos == 0 || optarg[pos] != '\0') {
        std::cerr << "Invalid thread number '" << optarg << "'!\n";
        std::exit(2);
      }
      break;
    }
    case 'S': {
      fs::path path(optarg);
      std::unique_ptr<finalizers::StructFile> c;
      try {
        c.reset(new finalizers::StructFile(path));
      } catch(...) {
        std::cerr << "Invalid structure file '" << optarg << "'!\n";
        std::exit(2);
      }
      const auto& p = c->forPath();
      structheads[p.filename()].emplace_back(p.parent_path());
      structs.emplace_back(std::move(c), path);
      break;
    }
    case 'R': {
      std::string from;
      std::string to;
      std::string* current = &from;
      for(std::size_t idx = 0; optarg[idx] != '\0'; idx++) {
        if(optarg[idx] == '=' && current == &from)
          current = &to;
        else if(optarg[idx] == '\\' && optarg[idx+1] == '=') {
          *current += '=';
          idx++;  // Skip over escaped equals
        } else if(optarg[idx] == '\\' && optarg[idx+1] == '\\') {
          *current += '\\';
          idx++;  // Skip over escaped backslash
        } else
          *current += optarg[idx];
      }
      if(from.empty()) {
        std::cerr << "Missing source prefix in -R '" << optarg << "'!\n";
        std::exit(2);
      }
      if(to.empty()) {
        std::cerr << "Missing destination prefix in -R '" << optarg << "'!\n";
        std::exit(2);
      }
      if(!prefixes.emplace(fs::path(from), fs::path(to)).second) {
        std::cerr << "Duplicate replacement for prefix '" << from << "'!\n";
        std::exit(2);
      }
      break;
    }
    case 'n':
      title = optarg;
      break;
    case 'f': {
      std::string form(optarg);
      if(form == "exmldb") format = Format::exmldb;
      else if(form == "sparse") format = Format::sparse;
      else {
        std::cerr << "Unrecognized output format '" << form << "'!\n";
        std::exit(2);
      }
      break;
    }
    case 'M':
      // Eventually, getsubopt etc.
      break;
    case 0:
      switch(longopt) {
      case 0:  // --version
        std::cout << fs::path(argv[0]).filename().string()
                  << " of HPCToolkit " << version << "\n";
        std::exit(0);
      case 1: {  // --metric-db (mutually exclusive with --no-thread-local)
        if(seenNoThreadLocal) {
          std::cerr << "Error: --metric-db and --no-thread-local cannot be used together!\n";
          std::exit(2);
        }
        std::string arg(optarg);
        if(arg == "yes") include_thread_local = true;
        else if(arg == "no") include_thread_local = false;
        else {
          std::cerr << "Error: --metric-db argument must be `yes' or `no'!\n";
          std::exit(2);
        }
        seenMetricDB = true;
        break;
      }
      case 2:  // --no-thread-local (mutually exclusive with --metric-db)
        if(seenMetricDB) {
          std::cerr << "Error: --metric-db and --no-thread-local cannot be used together!\n";
          std::exit(2);
        }
        include_thread_local = false;
        seenNoThreadLocal = true;
        break;
      }
      break;
    default:
      std::cout << "Usage: " << fs::path(argv[0]).filename().string()
                             << " " << summary << "\n";
      std::exit(2);
    }
  }

  if(dryRun) output = fs::path();

  instructionGrain = arg_instructionGrain;
  include_sources = arg_includeSources;
  include_traces = arg_includeTraces;

  // Now that the arguments have been munged, we can do the inputs.
  for(int idx = optind; idx < argc; idx++) {
    fs::path p(argv[idx]);
    if(fs::is_directory(p)) {
      bool any = false;
      for(const auto& de: fs::directory_iterator(p)) {
        auto s = ProfileSource::create_for(de);
        if(s) { any = true; sources.emplace_back(std::move(s), de.path()); }
      }
      if(!any) {
        std::cerr << "ERROR: No recognized profiles in " << p << "! Aborting!\n";
        std::exit(1);
      }
      // Also check for a structs/ directory for extra structfiles.
      fs::path sp = p / "structs";
      if(fs::exists(sp)) {
        for(const auto& de: fs::directory_iterator(sp)) {
          std::unique_ptr<ProfileFinalizer> c;
          try {
            c.reset(new finalizers::StructFile(de));
          } catch(...) { continue; }
          ProfArgs::structs.emplace_back(std::move(c), de);
        }
      }
    } else {
      auto s = ProfileSource::create_for(p);
      if(!s) {
        std::cerr << "ERROR: Invalid profile " << p << "!\n";
        std::exit(1);
      }
      sources.emplace_back(std::move(s), p);
    }
  }

  if(sources.empty()) {
    std::cerr << "No input files given!\n"
                 "Usage: " << fs::path(argv[0]).filename().string()
                            << " " << summary << "\n";
    std::exit(2);
  }
}

static std::pair<bool, fs::path> remove_prefix(const fs::path& path, const fs::path& pre) {
  if(pre.root_path() != path.root_path()) return {false, fs::path()};
  auto rpath = path.relative_path();
  auto rpathit = rpath.begin();
  auto rpathend = rpath.end();
  for(const auto& e: pre.relative_path()) {
    if(rpathit == rpathend) return {false, fs::path()};  // Missing a component
    if(e == "") break;  // Directory ending component
    if(e == "*") {  // Glob-esque match
      ++rpathit;
      continue;
    }
    if(*rpathit != e) return {false, fs::path()};  // Wrong component
    ++rpathit;
  }
  fs::path rem;
  for(; rpathit != rpathend; ++rpathit) rem /= *rpathit;
  return {true, rem};
}

static fs::path search(const std::unordered_map<fs::path, fs::path>& prefixes,
                       const fs::path& p) noexcept {
  for(const auto& ft: prefixes) {
    auto xp = remove_prefix(p, ft.first);
    if(xp.first) {
      fs::path rp = ft.second / xp.second;
      if(fs::exists(rp)) return rp;
    }
  }
  if(fs::exists(p)) return p;  // If all else fails;
  return fs::path();
}

void ProfArgs::Prefixer::file(const File& f, stdshim::filesystem::path& p) {
  p = search(args.prefixes, f.path());
}

void ProfArgs::Prefixer::module(const Module& m, stdshim::filesystem::path& p) {
  p = search(args.prefixes, m.path());
}

void ProfArgs::StructWarner::module(const Module& m, Classification& c) {
  if(c.empty()) {
    // Check if there any Structfiles might match this Module
    const auto it = args.structheads.find(m.path().filename());
    if(it == args.structheads.end()) return;
    std::cerr << "WARNING: Struct file partial match on "
              << m.path().filename().string() << ", did you forget a -R?\n"
                 "Suggestions:\n";
    for(const auto& pre: it->second) {
      std::cerr << "  -R '" << m.path().parent_path().string()
                            << "'='" << pre.string() << "'\n";
    }
  }
}
