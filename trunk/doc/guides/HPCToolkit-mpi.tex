%
% $Id$
%
\documentclass[12pt]{article}

\usepackage{fancyvrb}
\usepackage{fullpage}
\usepackage{moreverb}
\usepackage{hyperref}
\usepackage{verbatim}

\setlength{\topmargin}{0in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\parskip}{4pt}
% \setlength{\parindent}{0pt}

\newcommand{\HPCToolkit}{\textsc{HPCToolkit}}
\newcommand{\hpcrun}{\texttt{hpcrun}}
\newcommand{\hpclink}{\texttt{hpclink}}
\newcommand{\hpcstruct}{\texttt{hpcstruct}}
\newcommand{\hpcprof}{\texttt{hpcprof}}
\newcommand{\hpcviewer}{\texttt{hpcviewer}}

\newcommand{\question}[1]{\vspace{4pt}\par\noindent{\bf Q: #1}}
\newcommand{\answer}{\par\vspace{2pt}\noindent{\bf A:}}

\begin{document}

\title{Using {\sc HPCToolkit} with MPI Programs}
\author{The \HPCToolkit\ Team}
\maketitle

\begin{abstract}
\HPCToolkit{} is an integrated suite of tools that supports
measurement, analysis, attribution and presentation of application
performance for sequential and parallel programs.  This paper
describes how to use \HPCToolkit\ with MPI programs.
\end{abstract}

\section{Introduction}

\HPCToolkit's measurement tools collect data on each process and
thread of an MPI program.  \HPCToolkit\ can be used with pure MPI
programs as well as hybrid programs that use OpenMP or pthreads for
multi-threaded parallelism.

\HPCToolkit{} supports C, C++ and Fortran MPI programs.  It has been
successfully tested with MPICH, MVAPICH and OpenMPI and should work
with almost all MPI implementations.

\section{Running and Analyzing MPI Programs}

\question{How do I launch an MPI program with hpcrun?}

\answer{} For dynamically-linked binaries, use a command line similar
to the following example.

\begin{quote}
\verb|mpirun -np num hpcrun -e EVENT:count ... program arg ...|
\end{quote}

\noindent
{\it Note:\/} The MPI launch command ({\tt mpirun}, {\tt mpiexec},
{\it etc.})\ goes on the outside with its options first, then {\tt
hpcrun} and its options on the inside, and finally the application
program and its command-line arguments last.

\question{How do I compile and run a statically-linked MPI program?}

\answer{} 
On systems such as Compute-Node Linux and BG/P that run only
statically-linked binaries on the compute nodes, use \hpclink\ to
build a statically-linked version of your application with the
\HPCToolkit\ library linked in.  For example,

\begin{quote}
\begin{verbatim}
hpclink mpicc -o myprog file.o ... -l<lib> ...
\end{verbatim}
\end{quote}

\noindent
Then, set the {\tt HPCRUN\_EVENT\_LIST} environment variable in the
launch script before running the application.

\begin{quote}
\begin{verbatim}
export HPCRUN_EVENT_LIST="PAPI_TOT_CYC@4000000"
mpiexec -n 64 myprog arg ...
\end{verbatim}
\end{quote}

\noindent
See the {\it Using {\sc HPCToolkit} with Statically-Linked Programs} guide
for more information.

\question{What files does {\tt hpcrun} produce for an MPI program?}

\answer{} In this example, {\tt s3d\_f90.x} is the Fortran S3D program
compiled with OpenMPI and run with the command line ``{\tt mpiexec -n
4 hpcrun -e PAPI\_TOT\_CYC:2500000 ./s3d\_f90.x}''.  This produced 12
files in the following abbreviated {\tt ls} listing.

\begin{quote}
\begin{verbatim}
krentel 1889240 Feb 18  s3d_f90.x-000000-000-72815673-21063.hpcrun
krentel    9848 Feb 18  s3d_f90.x-000000-001-72815673-21063.hpcrun
krentel 1914680 Feb 18  s3d_f90.x-000001-000-72815673-21064.hpcrun
krentel    9848 Feb 18  s3d_f90.x-000001-001-72815673-21064.hpcrun
krentel 1908030 Feb 18  s3d_f90.x-000002-000-72815673-21065.hpcrun
krentel    7974 Feb 18  s3d_f90.x-000002-001-72815673-21065.hpcrun
krentel 1912220 Feb 18  s3d_f90.x-000003-000-72815673-21066.hpcrun
krentel    9848 Feb 18  s3d_f90.x-000003-001-72815673-21066.hpcrun
krentel  147635 Feb 18  s3d_f90.x-72815673-21063.log
krentel  142777 Feb 18  s3d_f90.x-72815673-21064.log
krentel  161266 Feb 18  s3d_f90.x-72815673-21065.log
krentel  143335 Feb 18  s3d_f90.x-72815673-21066.log
\end{verbatim}
\end{quote}

\noindent
Here, there are four processes and two threads per process.  Looking
at the file names, {\tt s3d\_f90.x} is the name of the program binary,
{\tt 000000-000} through {\tt 000003-001} are the MPI rank and thread
numbers, and {\tt 21063} through {\tt 21066} are the process IDs.

We see from the file sizes that OpenMPI is spawning one helper thread
per process.  Technically, the smaller {\tt .hpcrun} files imply only
a smaller calling-context tree (CCT), not necessarily fewer samples.
But in this case, the helper threads are not doing much work.

\question{Do I need to include anything special in the source code?}

\answer{} Just one thing.  Early in the program, preferably right
after {\tt MPI\_Init()}, the program should call {\tt
MPI\_Comm\_rank()} with communicator {\tt MPI\_COMM\_WORLD}.  Nearly
all MPI programs already do this, so this is rarely a problem.  For
example, in C, the program might begin with:

\begin{quote}
\begin{verbatim}
int main(int argc, char **argv)
{
    int size, rank;

    MPI_Init(&argc, &argv);
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    ...
}
\end{verbatim}
\end{quote}

\noindent
{\it Note:} The first call to {\tt MPI\_Comm\_rank()} should use {\tt
MPI\_COMM\_WORLD}.  This sets the process's MPI rank in the eyes of
{\tt hpcrun}.  Other communicators are allowed, but the first call
should use {\tt MPI\_COMM\_WORLD}.

Also, the call to {\tt MPI\_Comm\_rank()} should be unconditional,
that is all processes should make this call.  Actually, the call to
{\tt MPI\_Comm\_size()} is not necessary (for {\tt hpcrun}), although
most MPI programs normally call both {\tt MPI\_Comm\_size()} and {\tt
MPI\_Comm\_rank()}.

\question{What MPI implementations are supported?}

\answer{} Although the matrix of all possible MPI variants, versions,
compilers, architectures and systems is very large, \HPCToolkit\ has
been tested successfully with MPICH, MVAPICH and OpenMPI and should
work with most MPI implementations.

\question{What languages are supported?}

\answer{} C, C++ and Fortran are supported.

\section{Building and Installing HPCToolkit}

\question{Do I need to compile {\sc HPCToolkit} with any special
options for MPI support?}

\answer{} No, \HPCToolkit\ is designed to work with multiple MPI
implementations at the same time.  That is, you don't need to provide
an {\tt mpi.h} include path, and you don't need to compile multiple
versions of \HPCToolkit, one for each MPI implementation.

The technically-minded reader will note that each MPI implementation
uses a different value for {\tt MPI\_COMM\_WORLD} and may wonder how
this is possible.  \hpcrun\ (actually {\tt libmonitor}) waits for the
application to call {\tt MPI\_Comm\_rank()} and uses the same
communicator value that the application uses.  This is why we need the
application to call {\tt MPI\_Comm\_rank()} with communicator {\tt
MPI\_COMM\_WORLD}.

\end{document}
