%\documentclass[12pt]{article}
\documentclass{article}
\usepackage{hyperref}
\usepackage{verbatim,moreverb,fancyvrb}
\setlength{\topmargin}{0in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\parindent}{0in}

% ----------------------------------------------------------
% tools
% ----------------------------------------------------------

\newcommand{\HPCToolkit}{\textsc{HPCToolkit}}
\newcommand{\hpcrun}{\texttt{hpcrun}}
\newcommand{\hpcstruct}{\texttt{hpcstruct}}
\newcommand{\hpcprof}{\texttt{hpcprof}}
\newcommand{\hpcviewer}{\texttt{hpcviewer}}

\begin{document}
\title{Understanding and Troubleshooting \\
         \HPCToolkit\ Problems}
\author{The \HPCToolkit\ Team}
\date{03 February 2009}
\maketitle

\textbf{Why isn't my source code found by \hpcviewer ?}
\begin{comment}
(circular links in recursive search may lead to  inf loop)
\end{comment}
\begin{quote}
When using \hpcprof\ to create performance databases, one must specify the path 
to the source directories using the \verb|-I dir| flag. If there are multiple
source directories, then multiple \verb|-I| flags are required:
\begin{quote}
 \verb|-I dir1 -I dir2 ... -I dirN|
\end{quote}
The specified list of directory paths, \verb|dir1| through
\verb|dirN|, can be either relative or absolute.

In addition, \hpcprof\ has a recursive directory search feature that
can greatly reduce the number of \verb|-I| flag instances. To conduct
a source-file search of a directory \emph{and all of it's decendants},
simply append an escaped '*' after the last slash, e.g.,
\verb|/mypath/\*| ( or \verb|/mypath/'*'| ). This greatly simplifies
the \hpcprof\ command line for a typical project. For example, suppose
a project has all of it's source in a top-level directory called
\verb|src|. Inside \verb|src| are several libraries ( like
\verb|src/lib1|,\verb|src/lib2|, \verb|src/lib-math|, etc). Then, all
of the source is visible to \hpcprof\ by using the single flag
\begin{quote}
\verb|-I src/'*'|.
\end{quote}

\textbf{NOTE:} The \verb|'*'| can be used \emph{only} at the end of
a directory path.

For any functions whose source code is not found in the specified directories
(e.g., system libraries), \hpcviewer\ will generate a synopsis that shows
the presence of the function and its line extents (if known), but no
source code.
\end{quote}

\vbox{%
\textbf{I tried the approach above, but I am still missing source files.}
\begin{quote}
This is a common problem. The cause for this difficulty is that the
pathnames associated with performance metrics are extracted from an
application binary. The path names encoded in the binary can be

\begin{itemize}
   \item relative to the directory where the source was compiled, not
         where you are now as you measure and analyze the code, or

   \item absolute paths that have encodings for the mount point the
         directory that existed when the file was compiled, but might be
         different now (e.g., they were compiled on a different node of a
         cluster that had a different mount point for the shared file
         system).
\end{itemize}
\end{quote}
} 
\begin{quote}
Diagnosing and fixing this problem requires knowing exactly what path
names are referenced in the binary and/or perhaps the performance
data. Fortunately, this is information is supplied by \hpcprof .
If a source file is sucessfully located, then a 
\begin{quote}
\verb|msg:   cp:...|
\end{quote}
line appears in the output of \hpcprof . Unlocated files are deemed 'lost'
and there is an output line of the form 
\begin{quote}
\verb|WARNING:  lost:|
\end{quote}
in the output.

\begin{comment}
 It might be better to have three lost files in the example: one without a path
	interp.c
one with a relative path like 
	solve/solvermain.c
and one with a path like
	../../lib/math.c

        In all cases, the path passed to hpcprof with a -I flag should
        be a directory from which the relative path will reach the
        missing source file.
\end{comment}

For example, suppose we have an application \verb|app1| whose main source 
is in in a directory \verb|/projs/Apps/app1-src|. The \verb|app1|
application is built inside the \verb|app1-src| subdirectory, and it uses
source files from a subdirectory \verb|app1-src/special| as well as some
source common to all applications, located in
\verb|/projs/Apps/common|. When \verb|app1| is built, the
\verb|common| source is accessed by relative path \verb|../common|.
The \verb|app1| executable is installed on our path.

Now, we switch to our home directory \verb|/h/user/T1| to collect
some profile data for \verb|app1|.
When we run \hpcstruct\ (without the \verb|-I| flag) as follows:
\begin{quote}
  \verb|hpcstruct -S app1.hpcstruct */*.hpcrun|
\end{quote}
This results in the output
\begin{quote}
\begin{Verbatim}[fontsize=\small]
msg: Line map : /opt/apps/intel/compilers/10.1/lib/libimf.so
msg: STRUCTURE: /usr/local/bin/app1
msg: Copying source files reached by PATH option to /h/user/T1/hpctoolkit-app1-database
WARNING: lost: app1.c
WARNING: lost: special/xfn1.c
WARNING: lost: ../common/mathx.c
WARNING: lost: ~unknown-file~
WARNING: lost: irc_msg_support.c
\end{Verbatim}
\end{quote}
The \verb|WARNING: lost:| obtains for \verb|~unknown-file~| and
\verb|irc_msg_support.c| because these are compiler system files --- source
is unavailable. The other lost files, however, can be found by using
the proper \verb|-I| flag:
\begin{quote}
\begin{verbatim}
hpcstruct -I /projs/Apps/'*' -S app1.hpcstruct */*.hpcrun
\end{verbatim}
\end{quote}
\vbox{%
The resulting output:
\begin{quote}
\begin{Verbatim}[fontsize=\small]
msg: Line map : /opt/apps/intel/compilers/10.1/lib/libimf.so
msg: STRUCTURE: /usr/local/bin/app1
msg: Copying source files reached by PATH option to /h/user/T1/hpctoolkit-app1-database
msg:   cp:/projs/Apps/app1-src/app1.c -> ./projs/Apps/app1-src/app1.c
msg:   cp:/projs/Apps/app1-src/special/xfn1.c -> ./projs/Apps/app1-src/special/xfn1.c
msg:   cp:/projs/Apps/common/mathx.c -> ./projs/Apps/common/mathx.c
WARNING: lost: ~unknown-file~
WARNING: lost: irc_msg_support.c
\end{Verbatim}
\end{quote}
Much better!
}
\textbf{Best Practice:} Carefully inspect the output of \hpcprof\ to
determine which files are lost.  Then, use the recursive search form
of the \verb|-I| flag with absolute paths to the actual source
directory.
\end{quote}

\begin{comment}
   possible question: What happens if I forget to run hpcstruct?  
No hpcstruct = 
   really crazy procedure & loop bounds
   no inlining detection!
\end{comment}

\vbox{%
\textbf{Why don't the line numbers for loops and/or procedures exactly
correspond to what I see in the source code?}
\begin{comment}
  Wipe MIPSpro, Compaq compiler

PGI associates 1 line / basic block, so info is limited

Intel and GCC have, in our experience produced the best.

See hpcstruct manpage.

hpcviewer help is good idea.
\end{comment}
\begin{quote}

To use a clich\'{e}, ``garbage in, garbage out''. \HPCToolkit\ 
depends on information recorded in the symbol table by the
compiler. Line numbers for procedures and loops are inferred by
looking at the symbol table information recorded for machine
instructions identified as being inside the procedure or loop.
\end{quote}
}
\begin{quote}
For procedures, often no machine instructions are associated with a
procedure's declarations. Thus, the first line in the procedure that
has an associated machine instruction is the first line of executable
code.

Inlined functions may occasionally lead to confusing data for a
procedure. Machine instructions mapped to source lines from the inline
function appear in the context of other functions. While \hpcprof 's
methods for handling inline functions are good, some codes can confuse
the system.

For loops, the process of identifying what source lines are in a loop
is similar to the procedure process: what source lines map to machine
instructions inside a loop defined by a backward branch to a loop
head. Sometimes compilers sometimes don’t properly record the line
number mapping.

\begin{comment}
  
Some common constructs such as Fortran's statement functions lead to
confusing output from \hpcstruct , \HPCToolkit 's binary analyzer. With
Compaq's C compiler on Alpha systems, machine instructions that result
from forward substitution of statement functions are mapped back to
the line numbers in which the statement functions are defined. \verb|bloop|'s
normalization phase ensures that source lines will appear only once in
hpcviewer’s display. Thus different loops in which the same statement
functions are instantiated will appear fused in the program structure
after \verb|bloop|'s normalization. There is no simple fix for this
problem. A related issue is that sampled performance data for a
machine instruction is mapped back to the source line that a machine
instruction was derived from.  When machine instructions found in
different loops map back to the source line for a statement function,
performance is not going to be attributed correctly. To cope with this
issue, the whole \HPCToolkit\ tool chain needs modifications to cope
with the fact that there are multiple instances of a source line that
need to be processed and viewed as distinct entities.

With SGI's \verb|MIPspro| compilers, we have seen loop headers attributed to
the last line before the loop containing executable code. In the case
of the Intel compiler, sometimes machine instructions found in
optimized code map to the end of the source file. Yuck!
\end{comment}

When the compiler line mapping information is wrong, there is little
you can do about it other than to ignore its imperfections, or
hand-edit the XML program structure file produced by \hpcstruct . This
technique is used only when truly desparate.
\end{quote}

\end{document}
