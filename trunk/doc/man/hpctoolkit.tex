%% $Id$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[english]{article}
\usepackage[latin1]{inputenc}
\usepackage{babel}
\usepackage{verbatim}

%% do we have the `hyperref package?
\IfFileExists{hyperref.sty}{
   \usepackage[bookmarksopen,bookmarksnumbered]{hyperref}
}{}

%% do we have the `fancyhdr' or `fancyheadings' package?
\IfFileExists{fancyhdr.sty}{
\usepackage[fancyhdr]{latex2man}
}{
\IfFileExists{fancyheadings.sty}{
\usepackage[fancy]{latex2man}
}{
\usepackage[nofancy]{latex2man}
\message{no fancyhdr or fancyheadings package present, discard it}
}}

%% do we have the `rcsinfo' package?
\IfFileExists{rcsinfo.sty}{
\usepackage[nofancy]{rcsinfo}
\rcsInfo $Id$
\setDate{\rcsInfoLongDate}
}{
\setDate{ 2007/05/29}
\message{package rcsinfo not present, discard it}
}

\setVersionWord{Version:}  %%% that's the default, no need to set it.
\setVersion{=PACKAGE_VERSION=}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{Name}{1}{hpctoolkit}{The HPCToolkit Performance Tools}{The HPCToolkit Performance Tools}{HPCToolkit}

\textbf{HPCToolkit} is a collection of performance analysis tools for node-based performance analysis.
It has been designed around the following principles:
\begin{itemize}
\item \textbf{Language independence.} Modern scientific codes are multi-lingual.
\item \textbf{Avoid code instrumentation.} Adding instrumentation manually requires making \emph{a priori} assumptions about bottlenecks; adding instrumentation automatically can dilate execution and preclude compiler optimizations.
\item \textbf{Context is essential for understanding layered and object-oriented software.} In large, modular programs costs must be understood in their calling context.
\item \textbf{Any one performance measure produces a myopic view.}
\item \textbf{Derived performance metrics are essential for effective analysis.}
\item \textbf{Performance analysis should be top down.}
\item \textbf{Hierarchical aggregation is important in the face of approximate attribution.} 
\item \textbf{With instruction-level parallelism, aggregate properties are vital.}
\end{itemize}

\textbf{HPCToolkit}'s website contains papers that explain these design principles in more detail.

\end{Name}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Description}

\subsection{Top-Down Analysis With Calling Context and Program Structure}

A typical node-based performance analysis session consists of:
\begin{enumerate}
\item \textbf{Measurement.}  
Collect low-overhead, high-accuracy profiles using statistical sampling.
\Cmd{hpcrun}{1} collects `flat' profiles (IP histograms, where IP is instruction pointer) while \Cmd{csprof}{1} collects call path profiles.

\item \textbf{Recovering static source code structure.} 
\Cmd{bloop}{1} recovers static program structure such as procedures and loop nests.
It accounts for procedure and loop transformations such as inlining and software pipelining.

\item \textbf{Correlating dynamic profiles with static source code structure.} 
\textbf{HPCToolkit}'s correlation tool combines dynamic profile information with \Cmd{bloop}{1}'s static program structure to correlate costs of the optimized object code to useful source code constructs such as loop nests.
The result of correlation is called an Experiment database.
Currently, \Cmd{hpcquick}{1}/\Cmd{hpcview}{1} is used for flat profiles and \Cmd{xcsprof}{1} for call stack profiles.

\item \textbf{Top-down visualization}
\Prog{hpcviewer} is a Java-based top-down viewer for flat and call stack profiles.
An important feature of the Experiment database is that it is self-contained, containing profile information and copies of application source files.
This means that the first three steps can be performed remotely on a cluster and then the database can be viewed locally on a laptop or workstation.
\end{enumerate}

\subsection{Traditional Analysis}

\begin{enumerate}
\item \textbf{Measurement.}  
Collect low-overhead, high-accuracy `flat' profiles using statistical sampling (\Cmd{hpcrun}{1}).

\item \textbf{Correlating dynamic profiles with procedures source lines.} 
\Cmd{hpcprof}{1} correlates `flat' profiles with procedure source line information.
It does not account for procedure transformations such as inlining and does not detect loops.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}

\subsection{Visualize native metrics from flat profiles}

Assume we have an application called \texttt{zoo} whose source code is located in in \texttt{path-to-zoo}.

\begin{enumerate}
\item \textbf{Measure}.  Profile with \Cmd{hpcrun}{1}.  Assume the results are in \texttt{profile-file-1} and \texttt{profile-file-2}.
\begin{verbatim}
  hpcrun <event-list-1> zoo
  hpcrun <event-list-2> zoo
\end{verbatim}

\item \textbf{Recover static source code structure}. Use \Cmd{bloop}{1} to recover program structure.
\begin{verbatim}
  bloop zoo > zoo.psxml
\end{verbatim}

\item \textbf{Correlate dynamic profiles with static source code structure}.
Create an Experiment database using \Cmd{hpcquick}{1}, a front-end to \Cmd{hpcview}{1}.  Assume the Experiment database is located in \texttt{experiment-db}.
\begin{verbatim}
  hpcquick -I path-to-zoo/\* -S zoo.psxml -P profile-file-1 -P profile-file-2
\end{verbatim}

\item \textbf{Visualize}.
Visualize the Experiment database using \Cmd{hpcviewer}{1}:
\begin{verbatim}
  hpcviewer experiment-db/experiment.xml
\end{verbatim}

\end{enumerate}

\subsection{Visualize derived metrics for flat profiles}

The easiest way to begin is to collect all native metrics and then perform steps 1, 2 and 3 above.
These steps create a template \Cmd{hpcview}{1} configuration file which can be modified and used to rerun \Prog{hpcview}.

\begin{enumerate}
\item \textbf{Create derived metrics}.  Add COMPUTE metrics to the \Cmd{hpcview}{1} configuration file generated by \Cmd{hpcquick}{1}, typically stored in \texttt{hpcquick.xml}.  The \Cmd{hpcview}{1} man page contains some examples. 

\item \textbf{Correlate}. Rerun \Cmd{hpcview}{1} to create a new Experiment database.  Assume that it is located in \texttt{experiment-db-1}
\begin{verbatim}
  hpcview hpcquick.xml
\end{verbatim}

\item \textbf{Visualize}.
Visualize the Experiment database using \Cmd{hpcviewer}{1}:
\begin{verbatim}
  hpcviewer experiment-db-1/experiment.xml
\end{verbatim}

\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Notes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{See Also}

\Cmd{hpcrun}{1}, \Cmd{csprof}{1} \\
\Cmd{bloop}{1} \\
\Cmd{hpcquick}{1}, \Cmd{hpcview}{1}, \Cmd{xcsprof}{1}, \Cmd{hpcprof}{1} \\ %\Cmd{xprof}{1} 
\Cmd{hpcviewer}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Version}

Version: \Version\ of \Date.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{License and Copyright}

\begin{description}
\item[Copyright] \copyright\ 2002-2007, Rice University.
\item[License] See \File{README.License}.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Authors}

Email: \Email{hpc@cs.rice.edu} \\
WWW: \URL{http://hipersoft.cs.rice.edu/hpctoolkit}.

\LatexManEnd

\end{document}

%% Local Variables:
%% eval: (add-hook 'write-file-hooks 'time-stamp)
%% time-stamp-start: "setDate{ "
%% time-stamp-format: "%:y/%02m/%02d"
%% time-stamp-end: "}\n"
%% time-stamp-line-limit: 50
%% End:

