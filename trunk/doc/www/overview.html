<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--
  HPCTools Top-level Page: Editing within Netscape/Mozilla Composer
  is possible, but it generates strange stuff in-line.  
  Please use an ordinary text editor.
-->

<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="description" content="HPCToolkit Overview">
  <meta name="keywords" content="HPCToolkit overview, optimization of programs, sequential optimization, parallel optimization, high-performance systems, performance analysis, compiler optimization, hpcrun, hpcstruct, hpcprof, hpcviewer">
  <title>HPCToolkit Overview</title>
  <link rel='stylesheet' type='text/css' href='style/styles.css'>
</head>

<body>

<!-- ********************************************************************** -->

<script language="JavaScript" src="style/header-hpctoolkit.js"></script>

<!-- ********************************************************************** -->

<div id="main">


<p><i>(Note: More about HPCToolkit's methodology, utility and implementation can be found in in the <a href="papers.html">papers</a>.)</i>

<p>HPCToolkit consists of components for measuring the performance of fully-optimized executables generated by vendor compilers, analyzing application binaries to correlate measurements with program structure, and novel analysis techniques for pinpointing performance bottlenecks in parallel programs.


<h2>Motivating Principles</h2>

<p>We designed HPCToolkit to:

<ul>

<li> <i>Work at binary level for language independence.</i>
This enables HPCToolkit to support measurement and analysis of multi-lingual codes with external binary-only libraries.

<li> <i>Profile rather than adding code instrumentation.</i>
Sample-based profiling is less intrusive than code instrumentation and requires only very modest data volume.

<li> <i>Collect and correlate multiple performance metrics.</i>
Performance problems typically cannot be diagnosed with only one species of event.

<li> <i>Compute derived metrics to aid analysis.</i>
Synthetic metrics, such as memory bandwidth consumed, often provide insight for optimization.

<li> <i>Attribute costs very precisely.</i>
HPCToolkit is unique in its ability to associate measurements with dynamic calling context, loops, and inlined code.

</ul>

<h2>Methodological Overview</h2>


<p>From these principles we have devised a general methodology consisting of the workflow depicted in the adjacent figure.
The workflow is organized around four principal capabilities:

<table>
<tr>

<td>
<ul>
  <li> <i>measurement</i> of performance metrics while an application executes,
  <li> <i>analysis</i> of application binaries to recover program structure,
  <li> <i>correlation</i> of dynamic performance metrics with source code structure, and
  <li> <i>presentation</i> of performance metrics and associated source code.
</ul>

<p>First, one compiles and links one's application for a production run, using <i>full</i> optimization.
Second, one launches an application with HPCToolkit's measurement tool, which uses statistical sampling to collect a performance profile.
Third, one invokes HPCToolkit's tool for analyzing the application binary to recover information about files, functions, loops, and inlined code.
(For the most detailed attribution of application performance data using HPCToolkit, one should ensure that the compiler includes line map information in the object code it generates.
Since compilers often provide line map  information for fully-optimized code, this requirement need not require a special build process.)
Fourth, one combines information about an application's structure with dynamic performance measurements to produce a performance database.
Finally, one explores a performance database with an interactive viewer.

</td>

<td>
<img width=500 src="fig/hpctoolkit-workflow.jpg">
</td>

</tr>
</table>


<h3>Measurement</h3>
<p>HPCToolkit uses event-based sampling to measure and analyze program performance.
Sample events correspond to periodic interrupts induced by an interval timer or overflow of hardware performance counters measuring events such as cycles, instructions executed, cache misses, and memory bus transactions.
During an interrupt, HPCToolkit's call path profiler attributes samples to calling contexts.
To accurately measure code from "black box" vendor compilers, HPCToolkit uses on-the-fly binary analysis to enable stack-unwinding of fully optimized code <i>without compiler support</i>, even code that lacks frame pointers and uses optimizations such as tail calls.
The call path profiler will store sample counts and their associated calling contexts in a <i>calling context tree</i> (CCT).
</p>

<h3>Analysis and Correlation.</h3>
<p>To put measurements to use, HPCToolkit correlates them with source code abstractions.
To associate sample-based performance measurements of fully optimized binaries with source code structure, HPCToolkit uses binary analysis to recover information about procedures, loop nests, and inlined code.
For each procedure in the executable, the binary analyzer parses its machine code, identify branch instructions, build a control flow graph, and then uses interval analysis to identify loop nests within the control flow.
The binary analyzer then combines this information with line map information that is routinely recorded by vendor compilers in a way that enables it to associate samples associated with machine instructions to procedures and loops, even in the presence of optimizations such as inlining and loop transformations such as fusion, and compiler-generated loops from scalarization of Fortran 90 array operations or array copies induced by Fortran 90's calling conventions.
</p>


<!-- ********************************************************************** -->

<p class="lastupdated">Page last updated: 2008/06/14</p>

<!-- ********************************************************************** -->

<script language="JavaScript" src="style/footer-hpctoolkit.js"></script>

<!-- ********************************************************************** -->

</p>
</div> <!-- id=main -->

</body>
</html>


<!-- Local Variables: -->
<!-- eval: (add-hook 'write-file-hooks 'time-stamp) -->
<!-- time-stamp-start: "<p class=\"lastupdated\">Page last updated: " -->
<!-- time-stamp-format: "%:y/%02m/%02d" -->
<!-- time-stamp-end: "</p>" -->
<!-- time-stamp-line-limit: 10000 -->
<!-- End: -->
