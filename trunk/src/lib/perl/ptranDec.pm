## $Id$
## * BeginRiceCopyright *****************************************************
## 
## Copyright ((c)) 2002, Rice University 
## All rights reserved.
## 
## Redistribution and use in source and binary forms, with or without
## modification, are permitted provided that the following conditions are
## met:
## 
## * Redistributions of source code must retain the above copyright
##   notice, this list of conditions and the following disclaimer.
## 
## * Redistributions in binary form must reproduce the above copyright
##   notice, this list of conditions and the following disclaimer in the
##   documentation and/or other materials provided with the distribution.
## 
## * Neither the name of Rice University (RICE) nor the names of its
##   contributors may be used to endorse or promote products derived from
##   this software without specific prior written permission.
## 
## This software is provided by RICE and contributors "as is" and any
## express or implied warranties, including, but not limited to, the
## implied warranties of merchantability and fitness for a particular
## purpose are disclaimed. In no event shall RICE or contributors be
## liable for any direct, indirect, incidental, special, exemplary, or
## consequential damages (including, but not limited to, procurement of
## substitute goods or services; loss of use, data, or profits; or
## business interruption) however caused and on any theory of liability,
## whether in contract, strict liability, or tort (including negligence
## or otherwise) arising in any way out of the use of this software, even
## if advised of the possibility of such damage. 
## 
## ******************************************************* EndRiceCopyright *

# ----------------------------------------------------------------------
# $Id$
# $Author$
# $Date$
# $Revision$
# $Log$
# Revision 1.1  2003/04/21 21:55:05  slindahl
# Initial revision
#
# Revision 1.9  2002/11/27  16:23:45  eraxxon
# Fixed calculation of cycle counts when 'sample counts' are reported as time.
#
# Revision 1.8  2002/11/25  21:45:59  eraxxon
# Remove sample time rounding (affects profile data that reports a
# sample time rather than a sample count).
#
# Revision 1.7  2002/07/17  18:08:52  eraxxon
# Update copyright notices and RCS strings.
#
# Revision 1.6  2002/05/02  01:57:48  johnmc
# fixed regular expression to allow function names with $ among other things
#
# Revision 1.5  2002/04/12 02:28:50  rjf
# fill in displayName attribute
#
# Revision 1.4  2002/04/10  15:33:18  rjf
# fixed RE for end of header
#
# Revision 1.3  2002/03/26  13:43:01  eraxxon
# Fix error in RE for file names; misc. updates.
#
# Revision 1.3  2000/07/25  00:55:50  rjf
# Matching experiment name lines better
#
# Revision 1.2  2000/07/24  23:27:08  rjf
# Handle EV67 and EV5 events
#
# Revision 1.1  2000/07/19  22:58:29  rjf
# Initial revision
#
# RCSed versions.
#   The initial version knew only about EV6. Fixed parsing for EV67 
#   and EV5s.
#
# Revision -1.2  2000/05/04 20:42:29  xyuan
# This version assumes that only one counter is used for profiling and the
# profile is generated by using prof -lines.  In addition, no attempt to
# match the experiment type with its corresponding PAPI type is made.  The
# type of Alpha architecture (EV4, EV5, and etc) is ignored in this case.
#
# In the case of cycle statistics, the "samples" field in the line part of
# profile is replaced by "millisec".  Therefore, in order to calculate the
# number of samples, the number of the milliseconds is divided by the number
# of seconds covered by each sample, which is provided by the sentence "Each
# sample covers (m).00 byte(s) for x% of n seconds", and further divided by
# 1000.
# Revision -1.1  2000/05/04 20:26:24  xyuan
# Initial revision
#
# ----------------------------------------------------------------------

# ----------------------------------------------------------------------
#
# ptranDec.pm
#   A module transforming DEC profile output to XML style document
#
#   *********************************************************
#   ** only deal with the case where -lines option is used **
#   ** Assume that only one counter is used for profiling. **
#   *********************************************************
#
#   -- interface --
#
#    -- constructor --
#
#      new($inFileHandle, $outFileHandle)
#        create a new ptranDec object
#          $inFileHandle           the input file handle (DEC profile output)
#          $outFileHandle          the output file handle (XML document)
#
#    -- methods --
#
#      transform()
#        transform the SGI profile output to XML style document
#
# ----------------------------------------------------------------------

package ptranDec;

use strict;
use POSIX();
use PapiSpec();
use PROFILEXMLWriter();


# ----------------------------------------------------------------------
#
# Hardware counter descriptions
#   These hardware counter informations are currently not used.
#
# ----------------------------------------------------------------------

my %ChipFamilies = ( "EV4" => 0, "EV5" => 1, "EV6" => 2, "EV67" => 3 );

# ----------------------------------------------------------------------
#
# Hardware counter experiment types and corresponding PAPI event types
#   The PAPI mapping is not done.
#
# ----------------------------------------------------------------------

#my %experimentTypes =
#    (
#     
#     );

# ----------------------------------------------------------------------
#
# Scale Unit Type
#
# ----------------------------------------------------------------------

my $time = 'time';
my $event = 'event';
my %scaleUnitType = (
# EV6 events
		     cycles0 => $time, retinst => $event,
		     cycles1 => $time, retcondbranch => $event,
		     retdtb1miss => $event, retdtb2miss => $event,
		     retitbmiss => $event, retunaltrap => $event,
		     replay => $event,
# EV67 extension
		     bcashemisses => $event,
# EV5  events
		     issues => $event,
		     nonissues => $event,
                     splitissue => $event,
		     pipedry => $event,
		     singleissues => $event,
		     dualissues => $event,
		     flowchanges => $event,
		     intops => $event,
		     floatops => $event,
		     loads => $event,
		     stores => $event,
		     icacheacc => $event,
		     dcacheacc => $event,
		     longstalls => $event,
		     pcmispredicts => $event,
		     branchmispredicts => $event,
		     icachemisses => $event,
		     itbmisses => $event,
		     dcachldmisses => $event,
		     dtbmisses => $event,
		     ldsmerged => $event,
		     ldureplays => $event,
		     fullreplays => $event,
		     externalinput => $event,
		     memorybarriers => $event,
		     lockedloads => $event
		     );
		     
# ----------------------------------------------------------------------
#
# Regular expressions
#
# ----------------------------------------------------------------------

# regular expressions for uprofile/prof  profile listing header info.
# eraxxon: note that the first filename's RE (the program name) is
#   designed to accept all filenames that are valid in the shell.  The
#   second filename is therefore technically invalid, but we don't care
#   about it.
my $headerStartRE    = '^Profile listing generated';
my $executableNameRE = '^\s*prof\s+-lines\s+([^ ]+)\s+([\w\.]+)';

my $expNameRE1 = '^\s*\*\s+(\w[\d\w]*)\s*\((\d+)\s+in\s+(\d+)\)\s*:\s*(.*)\*\s*\n';
my $expNameRE2 = '^\s*\*\s+(\w[\d\w]*):\s*(\d+)[^\d]*(\d+)\s+(.*)\*\s*\n';

## my $headerEndRE      = '^\s*Each\s+sample\s+covers\s+[\d\.]+\s+byte\(s\)\s+for\s+([\d\.]+)%\s+of\s+([\d\.]+)\s+(events|seconds|samples)';
my $headerEndRE      = '^\s*Each\s+sample\s+covers\s+[\d\.]+\s+byte\(s\)\s+for\s+([^%]+)%\s+of\s+([\d\.]+)\s+(events|seconds|samples)';

# regular expressions for line lists
my $lineListStartRE  = '^\s*procedure\s*\(file\)\s+line\s+bytes\s+(samples|millisec)\s+%\s+cum\s*%';
my $mixedLineRE = '^\s*([^\s]+)\s*\(([^\)]+)\)\s+(\d*\.?\d*)\s+(\d*\.?\d*)\s+(\d*\.?\d*)\s+(\d*\.?\d*)';
my $pureLineRE  = '^\s*(\d+)\s*(\d*\.?\d*)\s+(\d*\.?\d*)\s+(\d*\.?\d*)\s+(\d*\.?\d*)';

my %fields = (
	      xmlWriter            => undef,
	      inFileHandle         => undef,
	      outFileHandle        => undef,
	      executableName       => undef,
	      experimentName       => undef,
	      marchingOrders       => undef,
	      cpuType              => undef,
	      fpuType              => undef,
	      numberOfCPUs         => undef,
	      clockFrequency       => undef,
	      totalSamples         => undef,
	      counterNumber        => undef,
	      counterName          => undef,
	      unit                 => undef,
	      samplesPerMilisec    => undef, # not always used
	      counterOverflowValue => undef, # cycles/sample
	      totalCounts          => undef,
	      );
    

# ----------------------------------------------------------------------
# -- new($inFileHandle, $outFileHandle) --
# ----------------------------------------------------------------------

sub new {
    my ($class, $inFileHandle, $outFileHandle) = @_;
    my $self = { %fields, };

    # create a new XMLWriter object
    $self->{xmlWriter} = new PROFILEXMLWriter($outFileHandle);
    if (! defined($self->{xmlWriter})) {
	die "cannot allocate a new XMLWriter object\n";
      }

    # record the input and output file handle
    $self->{inFileHandle} = $inFileHandle;
    $self->{outFileHandle} = $outFileHandle;
    
    bless $self, $class;
    return $self;
}

# ----------------------------------------------------------------------
# -- transform() --
#   reads in the profile from $inFileHandle and transforms and writes to
#   $outFileHandle
# ----------------------------------------------------------------------

sub transform {

    my ($self) = @_;
    my ($line, $inFileHandle);

    $inFileHandle = $self->{inFileHandle};

    # print "entering transform\n";
    
    # write a start tag for PROFILE element
    $self->{xmlWriter}->writePROFILEStartTag();
    
    # processes the profile
    $line = <$inFileHandle>;
    while ($line) {

	# process the header information of the profile
	if ($line =~ /$headerStartRE/) {
	    $line = $self->processHeader($line);
	    next;
	}

	# processes the line list of the profile
	if ($line =~ /$lineListStartRE/) {
	    $line = $self->processLineList($line);
	    next;
	}

	# read in another line
	$line = <$inFileHandle>;

    }

    # write an end tag for PROFILE element
    $self->{xmlWriter}->writePROFILEEndTag();
    
}

# ----------------------------------------------------------------------
# -- processHeader($line) --
#   dump the header into $outFileHandle and extract some experiment
#   infos
#   return the last line read
# ----------------------------------------------------------------------

sub processHeader {

    my ($self, $line) = @_;
    my $mhXMLWriter = $self->{xmlWriter};
    my $inFileHandle = $self->{inFileHandle};
    my $outFileHandle = $self->{outFileHandle};
    my @headerLines;

    # record the first line which is passed in as $line
    push @headerLines, $line;
    
    # process the rest of the header
    while (<$inFileHandle>) {

	# record the header line
	push @headerLines, $_;

	# when all the header is processed, breaks out of while loop
	if (/$headerEndRE/) {
	    last; # break
	}

	if (/$executableNameRE/) {
	    $self->{executableName} = $1;
	    $mhXMLWriter->setTargetName($1);
	}

	# Matches lines like
	# " *  cycles0 (1 in 1048576): Cycles  *"
	if (/$expNameRE1/) {
	    #my ($papiName, $papiNumber);
	    
	    #$papiName = $experimentTypes{$1};
	    #$papiNumber = $PapiSpec::symbolValueHashTable{$papiName};
	    
	    $self->{experimentName} = $1;
	    $mhXMLWriter->setNativeName($1);
	    $mhXMLWriter->setDisplayName($1);
	    #$mhXMLWriter->setPapiName($papiName);
	    #$mhXMLWriter->setPapiNumber($papiNumber);

	    $self->{marchingOrders} = $3;       
	    $self->{counterOverflowValue} = $3; # cycles/sample

	    my $restOfLine = $4;
	    my $scaleUnit;

	    $restOfLine =~ /^(.*)(\w)\s+/;
	    $self->{unit} = $1 . $2;
	    print STDERR "unit: $self->{unit} \n"
	}

	# Matches lines like 
	# "*  cycles0: 1 sample every 1048576 Cycles (0.001573 seconds)  * "
	if (/$expNameRE2/) {
	    #my ($papiName, $papiNumber);
	    
	    #$papiName = $experimentTypes{$1};
	    #$papiNumber = $PapiSpec::symbolValueHashTable{$papiName};
	    
	    $self->{experimentName} = $1;
	    $mhXMLWriter->setNativeName($1);
	    $mhXMLWriter->setDisplayName($1);
	    #$mhXMLWriter->setPapiName($papiName);
	    #$mhXMLWriter->setPapiNumber($papiNumber);

	    $self->{marchingOrders} = $3;
	    $self->{counterOverflowValue} = $3; # cycles/sample

	    my $restOfLine = $4;
	    my $scaleUnit;

	    # unit is the rest of the line, excluding parenthetical stuff.
	    if ( $restOfLine =~ /^(\w+(?:\s\w+)*)\s+\(?/ ) {
		$self->{unit} = $1;
	    }
	    # use parenthetical info to calculate samples/milliseconds
	    if ( $restOfLine =~ /\((\d*.?\d+)\s+seconds\)/ )  {
		$self->{samplesPerMillisec} = 1 / ($1 * 1000);
	    }
	    
	}

    }

    # process the marching order
    $mhXMLWriter->setPeriod($self->{counterOverflowValue});
	    
    # write a PROFILEHDR element
    $mhXMLWriter->writePROFILEHeader(\@headerLines);

    # return the last line
    return $_;

}

    
# ----------------------------------------------------------------------
# -- processLineList($line) --
#   extracts information from the line list
#   return the last line read
# ----------------------------------------------------------------------

sub processLineList {

    my ($self, $line) = @_;
    my ($lineNumber, $bytes, $counts, $samples, $percentage, $funcName,
	$compileUnit, $loadModule, $sourceFile);
    my ($mhXMLWriter, $inFileHandle);
    my ($curFuncCt);

    $mhXMLWriter = $self->{xmlWriter};
    $inFileHandle = $self->{inFileHandle};

    # write a start tag for PROGRAMSCOPETREE and PGM elements
    $mhXMLWriter->writeScopeTreeStartTag();
    $mhXMLWriter->writeSTPgmStartTag($self->{executableName});
    $curFuncCt = 0;

    # process all line infos
    while (<$inFileHandle>) {

	# match lines with function name and source file information first
	if (/$mixedLineRE/) {

	    $funcName = $1;
	    $loadModule = "";
	    $sourceFile = $2;
	    $compileUnit = "";
	    ($lineNumber, $bytes, $samples, $percentage) =
		($3, $4, $5, $6);

	    # begin a new function
	    if ($curFuncCt > 0) { # must close previous func first
	      $mhXMLWriter->writeSTProcEndTag();
	      $mhXMLWriter->writeSTFileEndTag();
	    } 
	    $mhXMLWriter->writeSTFileStartTag($sourceFile);
	    $mhXMLWriter->writeSTProcStartTag($funcName);
	    $curFuncCt += 1;
	}
	# match lines with pure line infos
	elsif (/$pureLineRE/) {
	    ($lineNumber, $bytes, $samples, $percentage) = ($1, $2, $3, $4);
	}
	# otherwise keep going
	else {
	    next;
	}
	
	# Sometimes the 'samples' column reports milliseconds rather
	# than a sample count.  If this is the case, convert the time
	# value into a sample value: (millisec) * (samples/millisec)
	if ($scaleUnitType{$self->{experimentName}} eq $time) {
	    $samples = $samples * $self->{samplesPerMillisec};
	}
	
	# Final value is cycle counts: (samples) * (cycles/sample)
	$counts = $samples * $self->{counterOverflowValue};
	
	
	# write out the line info (unused: $samples, $percentage)
	$mhXMLWriter->writeSTStmtStartTag($lineNumber, 0);
	$mhXMLWriter->writeSTMetricFormatTag($counts);
	$mhXMLWriter->writeSTStmtEndTag(); 
    }

    if ($curFuncCt > 0) { # must close last function
      $mhXMLWriter->writeSTProcEndTag();
      $mhXMLWriter->writeSTFileEndTag();
    }
    
    # write an end tag for PROGRAMSCOPETREE and PGM element
    $mhXMLWriter->writeSTPgmEndTag();
    $mhXMLWriter->writeScopeTreeEndTag();

    # read the last read line
    return $_;
}


1;

