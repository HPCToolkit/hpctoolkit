<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XED2: XED2 User Guide - Sun Feb 17 20:09:05 2008 </title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>XED command interface</h1>The command line tool called xed or xed.exe is built when you build the examples (<a class="el" href="group__EXAMPLES.html">Examples of using XED</a>) that come with XED. The xed-ex3 is just encode portion of the xed command line tool.<p>
This tool is useful for encoding and decoding or even decoding-then-re-encoding a single instruction or all the instructions in the text segment of an ELF binary (32 or 64b). For decoding, just jump to the examples.<p>
This section also explains a little language for writing the instructions for encode requests (-e option). I am constantly using this tool and updating it. The xed-ex3 (xed-ex3.exe) example is just the encoder portion of the xed command line tool.<p>
The SUPPRESSED operands emitted by the decoder are not used when encoding. They are ignored. They are not required to select an encoding.<p>
The syntax for encodable strings is as follows: <div class="fragment"><pre class="fragment">             Opcode[/width]   [operand [operand]]
</pre></div><p>
The width is a 8, 16, 32 or 64, indicating the effective operand width if it differs from the default. 8b operations generally require this. Or since most operations that default to 32b widths in 64b mode, it is required for 64b operation widths in 64b mode.<p>
The operand specifier is one of the following.<p>
<ul>
<li>A register name such as EAX or R8B, etc. Case does not matter.</li></ul>
<p>
<ul>
<li>An immediate specifier such as IMM(12ff) . Note: most shells require quotes because of the parens.</li></ul>
<p>
<ul>
<li>A displacement specifier such as DISP(0000001f) . Note: need the quotes.</li></ul>
<p>
<ul>
<li>A memory specifier that indicates the base register, index register, scale value, and displacement value. If one of the fields is not required, a - is necessary. The displacement is omittable. For example: MEM4(ESI,EAX,8,ff) or MEM4(EBX,-,-). The first one specifies that the memory address 4 bytes and should be ESI + EAX * 8 + 0xff. The second one specifies that EBX should be used to access 4 bytes of memory; note the displacement is omitted. A segment override can be specified as follows: MEM4(GS:EAX,-,-,-), by using a segment-name followed by a ":" before the base register. If there is no base register, you can use a "-", for example: MEM4(GS:-,-,11223344). One also needs to specify a memory operation width. This can be accomplished by indicating a number of bytes just after the MEM specifier. For example: MEM2(EAX,-,-) indicates a 2 byte memory operation.</li></ul>
<p>
<ul>
<li>An address generation specifer that has the same syntax as the above MEM() specifier, but is only used for LEA instructions. Example: AGEN(EAX,EBX,2,-)</li></ul>
<p>
Here is the help message:<p>
<div class="fragment"><pre class="fragment">% obj/xed -h
Usage: obj/xed [options]
One of the following is required:
  -i input_file             (decode file)
  -ide input_file           (decode/encode file)
  -d hex-string             (decode one instruction)
  -e instruction            (encode, must be last)
  -de hex-string            (decode-then-encode)
 
Optional arguments:
  -v verbosity  (0=quiet, 1=errors, 2=useful-info, 3=trace, 5=very verbose)
  -n number-of-instructions-to-decode (default 10,000, accepts K/M/G qualifiers)
  -I            (Intel SYSV syntax for disassembly)
  -A            (ATT SYSV syntax for disassembly)
  -16           (for LEGACY_16 mode)
  -32           (for LEGACY_32 mode, default)
  -64           (for LONG_64 mode w/64b addressing)
  -a32          (32b addressing, default, not in LONG_64 mode)
  -a16          (16b addressing, not in LONG_64 mode)
  -s32          (32b stack addressing, default, not in LONG_64 mode)
  -s16          (16b stack addressing, not in LONG_64 mode)
</pre></div><p>
Here are a couple of examples:<p>
<div class="fragment"><pre class="fragment">% xed -d 0000
ADD INT_ALU BASE  Opcode: 00  MODRM: 00 Bytes: 2
        Eb/EXPLICIT/RW Gb/EXPLICIT/R 
        ADD EffWidth: 8b
        MachineMode: LEGACY_32 AddrWidth: 32b StackAddrWidth: 32b
        MEM/EXPLICIT/RW REG/AL(REG8)/EXPLICIT/R 
        Read Write BASE= EAX(REG32) MemopLength = 1

        rFLAGS: of-mod sf-mod zf-mod af-mod pf-mod cf-mod Read:  Written: of sf zf af pf cf             writes

% xed -e ADD EAX EBX
Encodable! 01d8

xed -e ADD EAX 'MEM4(ESP,EBX,4)'
Encodable! 03049c

% xed -d 6a00
PUSH INT_ALU BASE  Opcode: 6a  Immed: 00 Bytes: 2
        Ib/EXPLICIT/R STACKPUSH/SUPPRESSED/R 
        PUSH EffWidth: 32b
        MachineMode: LEGACY_32 AddrWidth: 32b StackAddrWidth: 32b
        MEM/SUPPRESSED/W REG/ESP(REG32)/SUPPRESSED/RW IMM/EXPLICIT/R 
        Write SEG= SS BASE= ESP(REG32) MemopLength = 4
        IMMED: 00

        Does not use rFLAGS

% xed -e MOV EAX 'MEM4(SS:ESP,-,-)'
Encodable! 8b0424
</pre></div><p>
Or using the xed-ex3 example tool: <div class="fragment"><pre class="fragment">% obj/xed-ex3
Usage: obj/xed-ex3 [-16|-32|-64] [-a16|-a32] [-s16|-s32] encode-string
</pre></div><p>
The -16, -32 or -64 are for specifying the major mode of the machine. The -a16 and -a32 are for specifying 16 or 32 bit addressing. The default addressing mode in 64b mode is 64b addressing. The -s16 and -a32 are for specifying 16 or 32 bit stack addressing in 16 or 32 bit modes.<p>
<div class="fragment"><pre class="fragment">% obj/xed-ex3 -64 PUSH/64 RAX
Encode request:
PUSH Prefixes:  EffOpWidth: 64b EffAddrWidth: 64b
        MachineMode: LONG_64 AddrWidth: 64b StackAddrWidth: 32b
        REG/RAX(REG64)/EXPLICIT/RW 
        MemopLength = 0

Encodable! 50

% obj/xed-ex3 MOV 'MEM4(EAX,-,-)<span class="charliteral">' '</span>IMM(11223344)'
Encode request:
MOV Prefixes:  EffOpWidth: 32b EffAddrWidth: 32b
        MachineMode: LEGACY_32 AddrWidth: 32b StackAddrWidth: 32b
        MEM0/EXPLICIT/RW IMM/EXPLICIT/RW 
        TmpltIdx=0 BASE= EAX(REG32) MemopLength = 0
        IMMED: 0x11223344 <span class="keywordtype">signed</span>: 1144201745 starts@byte: 1

Encodable! c70011223344
</pre></div><h2><a class="anchor" name="ENCODE_EXAMPLE">
An example of using the encoder</a></h2>
The encoder language file which is part of the xed command line tool shows how to build up instructions from scratch. The example uses a string to drive the creation of the instruction, but that is just an example. Look at the parse_encode_request function for the required pieces.<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*BEGIN_LEGAL </span>
<span class="comment">Copyright (c) 2007, Intel Corp.</span>
<span class="comment">All rights reserved.</span>
<span class="comment"></span>
<span class="comment">Redistribution and use in source and binary forms, with or without</span>
<span class="comment">modification, are permitted provided that the following conditions are</span>
<span class="comment">met:</span>
<span class="comment"></span>
<span class="comment">    * Redistributions of source code must retain the above copyright</span>
<span class="comment">      notice, this list of conditions and the following disclaimer.</span>
<span class="comment"></span>
<span class="comment">    * Redistributions in binary form must reproduce the above</span>
<span class="comment">      copyright notice, this list of conditions and the following</span>
<span class="comment">      disclaimer in the documentation and/or other materials provided</span>
<span class="comment">      with the distribution.</span>
<span class="comment"></span>
<span class="comment">    * Neither the name of Intel Corporation nor the names of its</span>
<span class="comment">      contributors may be used to endorse or promote products derived</span>
<span class="comment">      from this software without specific prior written permission.</span>
<span class="comment"></span>
<span class="comment">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="comment">"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="comment">LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="comment">A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="comment">OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="comment">SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="comment">LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="comment">DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="comment">THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="comment">(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="comment">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment">END_LEGAL */</span>

<span class="comment">// This is an example of how to use the encoder from scratch in the context</span>
<span class="comment">// of parsing a string from the command line.  </span>


<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;iomanip&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;sstream&gt;</span>
<span class="preprocessor">#include &lt;cassert&gt;</span>
<span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<span class="preprocessor">#include "<a class="code" href="xed-interface_8h.html">xed-interface.h</a>"</span>
<span class="preprocessor">#include "<a class="code" href="xed-portability_8h.html">xed-portability.h</a>"</span>
<span class="preprocessor">#include "xed-examples-util.h"</span>
}
<span class="preprocessor">#include "xed-enc-lang.H"</span>




<span class="keyword">using namespace </span>std;
<span class="keyword">static</span> <span class="keywordtype">char</span> xed_enc_lang_toupper(<span class="keywordtype">char</span> c) {
    <span class="keywordflow">if</span> (c &gt;= <span class="charliteral">'a'</span> &amp;&amp; c &lt;= <span class="charliteral">'z'</span>)
        <span class="keywordflow">return</span> c-<span class="charliteral">'a'</span>+<span class="charliteral">'A'</span>;
    <span class="keywordflow">return</span> c;
}

<span class="keyword">static</span> string upcase(string s) {
    string t = <span class="stringliteral">""</span>;
    <a class="code" href="xed-types_8h.html#fca26ac4ba8456174630556310d0d60c">uint_t</a> len = static_cast&lt;uint_t&gt;(s.size());
    <a class="code" href="xed-types_8h.html#fca26ac4ba8456174630556310d0d60c">uint_t</a> i;
    <span class="keywordflow">for</span>(i=0 ; i &lt; len ; i++ ) 
        t = t + xed_enc_lang_toupper(s[i]);
    <span class="keywordflow">return</span> t;
}

<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
xed_split_args(<span class="keyword">const</span> string&amp; sep, 
               <span class="keyword">const</span> string&amp; input, 
               vector&lt;string&gt;&amp; output_array)
{
    <span class="comment">// returns the number of args</span>
    <span class="comment">// rip off the separator characters and split the src string based on separators.</span>
    
    <span class="comment">// find the string between last_pos and pos. pos is after last_pos</span>
    string::size_type last_pos = input.find_first_not_of(sep, 0);
    string::size_type pos = input.find_first_of(sep, last_pos);  
    <span class="keywordflow">if</span> (CLIENT_VERBOSE3)
        printf(<span class="stringliteral">"input %s\tlast_pos "</span> <a class="code" href="xed-portability_8h.html#5faee3534300d425bae3cddf5394cdfa">XED_FMT_U</a> <span class="stringliteral">" pos "</span> <a class="code" href="xed-portability_8h.html#5faee3534300d425bae3cddf5394cdfa">XED_FMT_U</a> <span class="stringliteral">"\n"</span>, 
               input.c_str() , <a class="code" href="xed-portability_8h.html#d5b19be27a5e8de0b9c4f2d16acf864b">STATIC_CAST</a>(<a class="code" href="xed-types_8h.html#fca26ac4ba8456174630556310d0d60c">uint_t</a>,last_pos), <a class="code" href="xed-portability_8h.html#d5b19be27a5e8de0b9c4f2d16acf864b">STATIC_CAST</a>(<a class="code" href="xed-types_8h.html#fca26ac4ba8456174630556310d0d60c">uint_t</a>,pos));
    <span class="keywordtype">int</span> i=0;
    <span class="keywordflow">while</span>( pos != string::npos &amp;&amp; last_pos != string::npos ) 
    {
        string a = input.substr(last_pos, pos-last_pos);
        output_array.push_back(a); 
        <span class="keywordflow">if</span> (CLIENT_VERBOSE3)
            printf(<span class="stringliteral">"\t\tlast_pos "</span> XED_FMT_U <span class="stringliteral">" pos "</span> XED_FMT_U <span class="stringliteral">" i %d\n"</span>, 
                   <a class="code" href="xed-portability_8h.html#d5b19be27a5e8de0b9c4f2d16acf864b">STATIC_CAST</a>(<a class="code" href="xed-types_8h.html#fca26ac4ba8456174630556310d0d60c">uint_t</a>,last_pos),
                   <a class="code" href="xed-portability_8h.html#d5b19be27a5e8de0b9c4f2d16acf864b">STATIC_CAST</a>(<a class="code" href="xed-types_8h.html#fca26ac4ba8456174630556310d0d60c">uint_t</a>,pos),
                   i);
        last_pos = input.find_first_not_of(sep, pos);
        pos = input.find_first_of(sep, last_pos);  
        i++;
    }
    <span class="keywordflow">if</span> (last_pos != string::npos &amp;&amp; pos == string::npos)
    {
        <span class="keywordflow">if</span> (CLIENT_VERBOSE3)
            printf(<span class="stringliteral">"\t\tGetting last substring at "</span> XED_FMT_U <span class="stringliteral">"\n"</span>, <a class="code" href="xed-portability_8h.html#d5b19be27a5e8de0b9c4f2d16acf864b">STATIC_CAST</a>(<a class="code" href="xed-types_8h.html#fca26ac4ba8456174630556310d0d60c">uint_t</a>,last_pos));
        string a = input.substr(last_pos); <span class="comment">// get the rest of the string</span>
        output_array.push_back(a);
        i++;
    }
    <span class="keywordflow">if</span> (CLIENT_VERBOSE3)
        printf(<span class="stringliteral">"\t returning %d\n"</span>,i);
    <span class="keywordflow">return</span> i;
}

vector&lt;string&gt; 
tokenize(<span class="keyword">const</span> string&amp; s,
         <span class="keyword">const</span> string&amp; delimiter) {
    vector&lt;string&gt; v;
    (void) xed_split_args(delimiter, s, v);
    <span class="keywordflow">return</span> v;
}


<span class="keywordtype">void</span> slash_split(<span class="keyword">const</span> string&amp; src,
                 string&amp; first, <span class="comment">// output</span>
                 string&amp;  second) <span class="comment">//output</span>
{
  string::size_type p = src.find(<span class="stringliteral">"/"</span>);
  <span class="keywordflow">if</span> (p == string::npos) {
    first = src;
    second = <span class="stringliteral">""</span>;
  }
  <span class="keywordflow">else</span> {
    first = src.substr(0,p);
    second = src.substr(p+1);
  }
}

<span class="keyword">class </span>immed_parser_t {
  <span class="keyword">public</span>:
    <span class="keywordtype">bool</span> valid;
    string immed;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width_bits;
    uint64_t immed_val;
    string tok0;

    immed_parser_t(<span class="keyword">const</span> string&amp; s, 
                   <span class="keyword">const</span> string&amp; arg_tok0) <span class="comment">//CONS</span>
        : valid(<a class="code" href="xed-types_8h.html#924dded66e355a2c955251063df9e97e">false</a>),
          tok0(arg_tok0)
    {
        vector&lt;string&gt; vs = tokenize(s,<span class="stringliteral">"(),"</span>);
        <span class="keywordflow">if</span> (vs.size() == 2) {
            <span class="keywordflow">if</span> (vs[0] == tok0) {
                string immed_str = vs[1];
                immed_val = convert_ascii_hex_to_int(immed_str.c_str());
                width_bits = immed_str.size()*4; <span class="comment">// nibbles to bits</span>
                valid = <span class="keyword">true</span>;
            }
        }
    }

    <span class="keywordtype">void</span>
    print(ostream&amp; o)<span class="keyword"> const </span>{
        o &lt;&lt; tok0 
          &lt;&lt; <span class="stringliteral">"("</span> ;
        <span class="keywordflow">if</span> (valid) 
            o &lt;&lt; hex &lt;&lt; immed_val &lt;&lt; dec;
        <span class="keywordflow">else</span> 
            o &lt;&lt; <span class="stringliteral">"???"</span>;
        o &lt;&lt; <span class="stringliteral">")"</span>;
    }

};

ostream&amp; operator&lt;&lt;(ostream&amp; o, <span class="keyword">const</span> immed_parser_t&amp; x) 
{
    x.print(o);
    <span class="keywordflow">return</span> o;
}


<span class="keyword">class </span>mem_bis_parser_t 
{
    <span class="comment">// parse: MEM[length]([segment:]base,index,scale[,displacement])</span>
    <span class="comment">// parse: AGEN(base,index,scale[,displacement])</span>
    <span class="comment">// The displacement is optional</span>
    <span class="comment">// The length of the memop is usually optional </span>
    <span class="comment">//   but required for x87 ops, for example.</span>
  <span class="keyword">public</span>:
    <span class="keywordtype">bool</span> valid;
    <span class="keywordtype">bool</span> mem;

    <span class="keywordtype">bool</span> agen;
    <span class="keywordtype">bool</span> disp_valid;
    string segment;
    string base;
    string index;
    string scale;
    string disp; <span class="comment">//displacement</span>
    <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edb">xed_reg_enum_t</a> segment_reg;
    <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edb">xed_reg_enum_t</a> base_reg;
    <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edb">xed_reg_enum_t</a> index_reg;
    uint8_t scale_val;


    int64_t disp_val;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> disp_width_bits;

    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mem_len;

    <span class="keywordtype">void</span>
    print(ostream&amp; o)<span class="keyword"> const </span>{
        <span class="keywordflow">if</span> (agen) 
            o &lt;&lt; <span class="stringliteral">"AGEN"</span>; 
        <span class="keywordflow">if</span> (mem) 
            o &lt;&lt; <span class="stringliteral">"MEM"</span>; 
        <span class="keywordflow">if</span> (mem_len) 
            o &lt;&lt; setw(1) &lt;&lt; mem_len;
        o &lt;&lt; <span class="stringliteral">"("</span>;
        <span class="keywordflow">if</span> (segment_reg != <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a>)
            o &lt;&lt; segment_reg &lt;&lt; <span class="stringliteral">":"</span>;
        o &lt;&lt; base_reg;
        o &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; index_reg 
          &lt;&lt; <span class="stringliteral">","</span> 
          &lt;&lt; (<span class="keywordtype">unsigned</span> int) scale_val;
        <span class="keywordflow">if</span> (disp_valid) 
            o &lt;&lt;  <span class="stringliteral">","</span> &lt;&lt; disp;
        o &lt;&lt; <span class="stringliteral">")"</span>;
     
    }
  
    mem_bis_parser_t(<span class="keyword">const</span> string&amp; s) <span class="comment">//CONS</span>
        : valid(<a class="code" href="xed-types_8h.html#924dded66e355a2c955251063df9e97e">false</a>),
          disp_valid(<a class="code" href="xed-types_8h.html#924dded66e355a2c955251063df9e97e">false</a>),
          base(<span class="stringliteral">"INVALID"</span>),
          index(<span class="stringliteral">"INVALID"</span>),
          scale(<span class="stringliteral">"1"</span>),
          segment_reg(<a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a>),
          base_reg(<a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a>),
          index_reg(<a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a>),
          disp_val(0),
          disp_width_bits(0),
          mem_len(0)
    {

        mem = <span class="keyword">false</span>;
        agen = <span class="keyword">false</span>;
        vector&lt;string&gt; vs = tokenize(s,<span class="stringliteral">"(),"</span>);
        <a class="code" href="xed-types_8h.html#fca26ac4ba8456174630556310d0d60c">uint_t</a> ntokens = static_cast&lt;uint_t&gt;(vs.size());
        <span class="keywordflow">if</span> (ntokens &gt;= 2 &amp;&amp; ntokens &lt;= 5) {
            <span class="keywordflow">if</span> (vs[0] == <span class="stringliteral">"AGEN"</span>) {
                agen = <span class="keyword">true</span>;
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vs[0].substr(0,3) == <span class="stringliteral">"MEM"</span>) {
                mem = <span class="keyword">true</span>;
                <span class="keywordflow">if</span> (vs[0].size() &gt; 3) {
                    string len = vs[0].substr(3);
                    mem_len = strtol(len.c_str(),0,0);
                    <span class="comment">//printf("mem_len  = " XED_FMT_U "\n", mem_len);</span>
                }
            }
            <span class="keywordflow">else</span>             {
                <span class="keywordflow">return</span>;
            }

            segment = <span class="stringliteral">"INVALID"</span>;
            string seg_and_base = upcase(vs[1]);
            vector&lt;string&gt; sb = tokenize(seg_and_base,<span class="stringliteral">":"</span>);
            <span class="keywordtype">int</span> seg_and_base_tokens = <a class="code" href="xed-portability_8h.html#d5b19be27a5e8de0b9c4f2d16acf864b">STATIC_CAST</a>(<span class="keywordtype">int</span>,sb.size());
            <span class="keywordflow">if</span> (seg_and_base_tokens == 1) {
                segment = <span class="stringliteral">"INVALID"</span>;
                base = sb[0];
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (seg_and_base_tokens == 2) {
                <span class="keywordflow">if</span> (agen) {
                    xedex_derror(<span class="stringliteral">"AGENs cannot have segment overrides"</span>);
                }
                segment = sb[0];
                base = sb[1];
            }
            <span class="keywordflow">else</span>            {
                printf(<span class="stringliteral">"seg_and_base_tokens = %d\n"</span>,seg_and_base_tokens);
                xedex_derror(<span class="stringliteral">"Bad segment-and-base specifier."</span>);
            }

            <span class="keywordflow">if</span> (base == <span class="stringliteral">"-"</span> || base == <span class="stringliteral">"NA"</span>) {
                base = <span class="stringliteral">"INVALID"</span>;
            }
            <span class="keywordflow">if</span> (ntokens &gt; 2) {
                index = upcase(vs[2]);
                <span class="keywordflow">if</span> (index == <span class="stringliteral">"-"</span> || index == <span class="stringliteral">"NA"</span>) {
                    index = <span class="stringliteral">"INVALID"</span>;
                }
            }

            <span class="keywordflow">if</span> (ntokens &gt; 3) {
                scale = vs[3];
                <span class="keywordflow">if</span> (scale == <span class="stringliteral">"-"</span> || scale == <span class="stringliteral">"NA"</span>) {
                    scale = <span class="stringliteral">"1"</span>;
                }
            }
            <span class="keywordflow">if</span> (scale == <span class="stringliteral">"1"</span> || scale == <span class="stringliteral">"2"</span> || scale == <span class="stringliteral">"4"</span> || scale == <span class="stringliteral">"8"</span>) {
                valid=<span class="keyword">true</span>;
                scale_val = <a class="code" href="xed-portability_8h.html#d5b19be27a5e8de0b9c4f2d16acf864b">STATIC_CAST</a>(uint8_t,strtol(scale.c_str(), 0, 10));
                segment_reg = <a class="code" href="xed-reg-enum_8h.html#370f75460cc8548e5d6fee562c3b70ce">str2xed_reg_enum_t</a>(segment.c_str());
                base_reg = <a class="code" href="xed-reg-enum_8h.html#370f75460cc8548e5d6fee562c3b70ce">str2xed_reg_enum_t</a>(base.c_str());
                index_reg = <a class="code" href="xed-reg-enum_8h.html#370f75460cc8548e5d6fee562c3b70ce">str2xed_reg_enum_t</a>(index.c_str());

                <span class="comment">// look for a displacement</span>
                <span class="keywordflow">if</span> (ntokens == 5 &amp;&amp; vs[4] != <span class="stringliteral">"-"</span>) {
                    disp = vs[4];
                    disp_valid = <span class="keyword">true</span>;
                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nibbles = <a class="code" href="xed-portability_8h.html#d5b19be27a5e8de0b9c4f2d16acf864b">STATIC_CAST</a>(<span class="keywordtype">int</span>,disp.size());
                    <span class="keywordflow">if</span> (nibbles &amp; 1) {
                        <span class="comment">// ensure an even number of nibbles</span>
                        string zero(<span class="stringliteral">"0"</span>);
                        disp = zero + disp;
                        nibbles++;
                    }
                    disp_val = convert_ascii_hex_to_int(disp.c_str());
                    disp_width_bits = nibbles*4; <span class="comment">// nibbles to bits</span>
                }
            }

        }
    
    }
};

ostream&amp; operator&lt;&lt;(ostream&amp; o, <span class="keyword">const</span> mem_bis_parser_t&amp; x) {
  x.print(o);
  <span class="keywordflow">return</span> o;
}

<a class="code" href="group__ENC.html#gc19a60430b05a2baa08faeff10258cbe">xed_encoder_request_t</a> parse_encode_request(ascii_encode_request_t&amp; areq) {
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
    <a class="code" href="group__ENC.html#gc19a60430b05a2baa08faeff10258cbe">xed_encoder_request_t</a> req;
    <a class="code" href="group__ENC.html#g7cde0a73e3610011bd03517ab8d9452c">xed_encoder_request_zero_set_mode</a>(&amp;req,&amp;(areq.dstate)); <span class="comment">// calls xed_encoder_request_zero()</span>

    <span class="comment">/* This is the important function here. This encodes an instruction from scratch.</span>
<span class="comment">       </span>
<span class="comment">    You must set:</span>
<span class="comment">    the machine mode (machine width, addressing widths)</span>
<span class="comment">    the effective operand width</span>
<span class="comment">    the iclass</span>
<span class="comment">    for some instructions you need to specify prefixes (like REP or LOCK).</span>
<span class="comment">    the operands:</span>
<span class="comment">           operand kind (XED_OPERAND_{AGEN,MEM0,MEM1,IMM0,IMM1,RELBR,PTR,REG0...REG15}</span>
<span class="comment">           operand order </span>
<span class="comment">                    xed_encoder_request_set_operand_order(&amp;req,operand_index, XED_OPERAND_*);</span>
<span class="comment">                    where the operand_index is a sequential index starting at zero.</span>
<span class="comment"></span>
<span class="comment">           operand details </span>
<span class="comment">                     FOR MEMOPS: base,segment,index,scale,displacement for memops, </span>
<span class="comment">                  FOR REGISTERS: register name</span>
<span class="comment">                 FOR IMMEDIATES: immediate values</span>
<span class="comment">       </span>
<span class="comment">     */</span>
    

    <span class="keywordflow">switch</span>(<a class="code" href="group__INIT.html#ga90c43e356f6bac5d61dcb9e9164689e">xed_state_get_machine_mode</a>(&amp;(areq.dstate))) {
        <span class="comment">// set the default width.</span>
      <span class="keywordflow">case</span> <a class="code" href="xed-machine-mode-enum_8h.html#286815a07cc8dce7f4c337d9d254e1de4a58eec921c0a919d466a2c42af95940">XED_MACHINE_MODE_LONG_64</a>:
        <a class="code" href="group__ENC.html#g2cbe305437a330b24c0e49007e056c60">xed_encoder_request_set_effective_operand_width</a>(&amp;req, 32);
        <a class="code" href="group__ENC.html#g6edb580dfbc56b4acdc22c31df45fd21">xed_encoder_request_set_effective_address_size</a>(&amp;req, 64);
        <span class="keywordflow">break</span>;

      <span class="keywordflow">case</span> <a class="code" href="xed-machine-mode-enum_8h.html#286815a07cc8dce7f4c337d9d254e1dea80063c35e5edd5739b5d473707f4f6c">XED_MACHINE_MODE_LEGACY_32</a>:
      <span class="keywordflow">case</span> <a class="code" href="xed-machine-mode-enum_8h.html#286815a07cc8dce7f4c337d9d254e1de94a9e8c737df6a81d590c27a9191625c">XED_MACHINE_MODE_LONG_COMPAT_32</a>:
        <a class="code" href="group__ENC.html#g2cbe305437a330b24c0e49007e056c60">xed_encoder_request_set_effective_operand_width</a>(&amp;req, 32);
        <a class="code" href="group__ENC.html#g6edb580dfbc56b4acdc22c31df45fd21">xed_encoder_request_set_effective_address_size</a>(&amp;req, 32);
        <span class="keywordflow">break</span>;

      <span class="keywordflow">case</span> <a class="code" href="xed-machine-mode-enum_8h.html#286815a07cc8dce7f4c337d9d254e1de81aba1eddf1e00ab4fe6856c2d5cfe83">XED_MACHINE_MODE_LEGACY_16</a>:
      <span class="keywordflow">case</span> <a class="code" href="xed-machine-mode-enum_8h.html#286815a07cc8dce7f4c337d9d254e1de9dbdbe4d50745469a4c73b8b355c62cb">XED_MACHINE_MODE_LONG_COMPAT_16</a>:
        <a class="code" href="group__ENC.html#g2cbe305437a330b24c0e49007e056c60">xed_encoder_request_set_effective_operand_width</a>(&amp;req, 16);
        <a class="code" href="group__ENC.html#g6edb580dfbc56b4acdc22c31df45fd21">xed_encoder_request_set_effective_address_size</a>(&amp;req, 16);
        <span class="keywordflow">break</span>;

      <span class="keywordflow">default</span>:
        assert(0);
    }

    <span class="comment">//FIXME: allow changing the effective address size from the above defaults.</span>

    vector&lt;string&gt; tokens = tokenize(areq.command,<span class="stringliteral">" "</span>);
    <span class="comment">// first token has the operand and our temporary hack for the immediate</span>

    string first, second;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> token_index = 0;

    <span class="keywordflow">while</span>(token_index &lt; tokens.size()) {
        slash_split(tokens[token_index], first, second);
        <span class="keywordflow">if</span> (CLIENT_VERBOSE3)
            printf( <span class="stringliteral">"[%s][%s][%s]\n"</span>, tokens[0].c_str(), first.c_str(), second.c_str());

        <span class="keywordflow">if</span> (token_index == 0 &amp;&amp; first == <span class="stringliteral">"REP"</span>) {
            <a class="code" href="group__ENC.html#g92571117c652c2355358ca4afd28c5b7">xed_encoder_request_set_rep</a>(&amp;req);
            token_index++;
            <span class="keywordflow">continue</span>;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token_index == 0 &amp;&amp; first == <span class="stringliteral">"REPNE"</span>) {
            <a class="code" href="group__ENC.html#g28ce8afadcfb592cfe3f36fa5d3fda91">xed_encoder_request_set_repne</a>(&amp;req);
            token_index++;
            <span class="keywordflow">continue</span>;
        }
  
        token_index++;
        <span class="keywordflow">break</span>;
    }

    <span class="comment">// we can attempt to override the mode </span>
    <span class="keywordflow">if</span> (second == <span class="stringliteral">"8"</span>) 
        <a class="code" href="group__ENC.html#g2cbe305437a330b24c0e49007e056c60">xed_encoder_request_set_effective_operand_width</a>(&amp;req, 8);
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (second == <span class="stringliteral">"16"</span>) 
        <a class="code" href="group__ENC.html#g2cbe305437a330b24c0e49007e056c60">xed_encoder_request_set_effective_operand_width</a>(&amp;req, 16);
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (second == <span class="stringliteral">"32"</span>) 
        <a class="code" href="group__ENC.html#g2cbe305437a330b24c0e49007e056c60">xed_encoder_request_set_effective_operand_width</a>(&amp;req, 32);
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (second == <span class="stringliteral">"64"</span>) 
        <a class="code" href="group__ENC.html#g2cbe305437a330b24c0e49007e056c60">xed_encoder_request_set_effective_operand_width</a>(&amp;req, 64);

    first = upcase(first);
    <a class="code" href="xed-iclass-enum_8h.html#aac14887efb58dc90badb71262573543">xed_iclass_enum_t</a> iclass =  <a class="code" href="xed-iclass-enum_8h.html#c78130f69f5ec4b898fc570ad8681c06">str2xed_iclass_enum_t</a>(first.c_str());
    <span class="keywordflow">if</span> (iclass == <a class="code" href="xed-iclass-enum_8h.html#aac14887efb58dc90badb712625735437fd4f674cd9733d91132080614f281fd">XED_ICLASS_INVALID</a>) {
        ostringstream os;
        os &lt;&lt; <span class="stringliteral">"Bad instruction name: "</span> &lt;&lt; first;
        xedex_derror(os.str().c_str());
    }
    <a class="code" href="group__ENC.html#g5c17ede76d6be221908d31b0377175cb">xed_encoder_request_set_iclass</a>(&amp;req, iclass );

    <a class="code" href="xed-types_8h.html#fca26ac4ba8456174630556310d0d60c">uint_t</a> memop = 0;
    <a class="code" href="xed-types_8h.html#fca26ac4ba8456174630556310d0d60c">uint_t</a> regnum = 0;
    <span class="comment">// put the operands in the request. Loop through tokens </span>
    <span class="comment">// (skip the opcode iclass, handled above)</span>
    <a class="code" href="xed-types_8h.html#fca26ac4ba8456174630556310d0d60c">uint_t</a> operand_index = 0;
    <span class="keywordflow">for</span>( i=token_index; i &lt; tokens.size(); i++, operand_index++ ) {
        string str_res_reg, second_x;
        slash_split(tokens[i], str_res_reg, second_x);
        str_res_reg = upcase(str_res_reg);
        <span class="comment">// prune the AGEN or MEM(base,index,scale[,displacement]) text from str_res_reg</span>
        <span class="comment">// FIXME: add MEM(immed) for the OC1_A and OC1_O types????</span>
        mem_bis_parser_t mem_bis(str_res_reg);
        <span class="keywordflow">if</span> (mem_bis.valid) {
            <span class="keywordflow">if</span> (mem_bis.mem) {
                <span class="keywordflow">if</span> (memop == 0) {
                    <span class="comment">// Tell XED that we have a memory operand</span>
                    <a class="code" href="group__ENC.html#g6a3d3301f69578aeccf29ce41eb89581">xed_encoder_request_set_mem0</a>(&amp;req);
                    <span class="comment">// Tell XED that the mem0 operand is the next operand:</span>
                    <a class="code" href="group__ENC.html#gda8206e8148b22feaf7b7e4a491fbc1e">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a33b594d6f19eb9277ccce735c79fc2b28e">XED_OPERAND_MEM0</a>);
                }
                <span class="keywordflow">else</span> {
                    <a class="code" href="group__ENC.html#g98e04279fcc6a673ac8acd2c9b87e9ad">xed_encoder_request_set_mem1</a>(&amp;req);
                    <span class="comment">// Tell XED that the mem1 operand is the next operand:</span>
                    <a class="code" href="group__ENC.html#gda8206e8148b22feaf7b7e4a491fbc1e">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a33556f96b12f59bf39bc02082da3a083a4">XED_OPERAND_MEM1</a>);
                }
                memop++;
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mem_bis.agen) {
                <span class="comment">// Tell XED we have an AGEN</span>
                <a class="code" href="group__ENC.html#g052c0edd23cca8477a64ad864a188b09">xed_encoder_request_set_agen</a>(&amp;req);
                <span class="comment">// The AGEN is the next operand</span>
                <a class="code" href="group__ENC.html#gda8206e8148b22feaf7b7e4a491fbc1e">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a3348110e0aa58fa1830b3ded9a3ff0e432">XED_OPERAND_AGEN</a>);
            }
            <span class="keywordflow">else</span> 
                assert(mem_bis.agen || mem_bis.mem);

            <span class="comment">// fill in the memory fields</span>
            <a class="code" href="group__ENC.html#gdd28aa6759b1dfd5090a8ebc2f151a57">xed_encoder_request_set_base0</a>(&amp;req, mem_bis.base_reg);
            <a class="code" href="group__ENC.html#g5947798ae78f68147ac18a124a498b4d">xed_encoder_request_set_index</a>(&amp;req, mem_bis.index_reg);
            <a class="code" href="group__ENC.html#g11676b3f2eaf0fe9163776965449b197">xed_encoder_request_set_scale</a>(&amp;req, mem_bis.scale_val);
            <a class="code" href="group__ENC.html#ge4493ae0364f81df78b0d7ee81fdd825">xed_encoder_request_set_seg0</a>(&amp;req, mem_bis.segment_reg);

            <span class="keywordflow">if</span> (mem_bis.mem_len) 
                <a class="code" href="group__ENC.html#g2d75f7dac34ba6fd05e5866b88800525">xed_encoder_request_set_memory_operand_length</a>(&amp;req, mem_bis.mem_len ); <span class="comment">// BYTES</span>
            <span class="keywordflow">if</span> (mem_bis.disp_valid)
                <a class="code" href="group__ENC.html#gb8feb6a0845282f85ae52de761823ac1">xed_encoder_request_set_memory_displacement</a>(&amp;req,
                                                            mem_bis.disp_val,
                                                            mem_bis.disp_width_bits/8);
            <span class="keywordflow">continue</span>;
        }

        immed_parser_t imm(str_res_reg, <span class="stringliteral">"IMM"</span>);
        <span class="keywordflow">if</span> (imm.valid) {
            <span class="keywordflow">if</span> (CLIENT_VERBOSE3) 
                printf(<span class="stringliteral">"Setting immediate value to "</span> <a class="code" href="xed-portability_8h.html#0a9d7f95b66014f70a711ea0558c2a19">XED_FMT_LX</a> <span class="stringliteral">"\n"</span>, imm.immed_val);
            <a class="code" href="group__ENC.html#g58f9cf56fc57bc070a811436114233f5">xed_encoder_request_set_uimm0_bits</a>(&amp;req, 
                                               imm.immed_val,
                                               imm.width_bits);
            <a class="code" href="group__ENC.html#gda8206e8148b22feaf7b7e4a491fbc1e">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a3300f3a04470e3ae430e375dedb6b4d4ec">XED_OPERAND_IMM0</a>);
            <span class="keywordflow">continue</span>;
        }
        immed_parser_t simm(str_res_reg, <span class="stringliteral">"SIMM"</span>);
        <span class="keywordflow">if</span> (simm.valid) {
            <span class="keywordflow">if</span> (CLIENT_VERBOSE3) 
                printf(<span class="stringliteral">"Setting immediate value to "</span> <a class="code" href="xed-portability_8h.html#0a9d7f95b66014f70a711ea0558c2a19">XED_FMT_LX</a> <span class="stringliteral">"\n"</span>, simm.immed_val);
            <a class="code" href="group__ENC.html#g9649c9b1bf5e1bc9c426a188b6aefb70">xed_encoder_request_set_simm</a>(&amp;req, 
                                         <a class="code" href="xed-portability_8h.html#d5b19be27a5e8de0b9c4f2d16acf864b">STATIC_CAST</a>(int32_t,simm.immed_val),
                                         simm.width_bits/8); <span class="comment">//FIXME</span>
            <a class="code" href="group__ENC.html#gda8206e8148b22feaf7b7e4a491fbc1e">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a3300f3a04470e3ae430e375dedb6b4d4ec">XED_OPERAND_IMM0</a>);
            <span class="keywordflow">continue</span>;
        }
        immed_parser_t imm2(str_res_reg, <span class="stringliteral">"IMM2"</span>);
        <span class="keywordflow">if</span> (imm2.valid) {
            <span class="keywordflow">if</span> (imm2.width_bits != 8)
                xedex_derror(<span class="stringliteral">"2nd immediate must be just 1 byte long"</span>);
            <a class="code" href="group__ENC.html#ge3f0c785f467652d065bea767f170bef">xed_encoder_request_set_uimm1</a>(&amp;req, imm2.immed_val);
            <a class="code" href="group__ENC.html#gda8206e8148b22feaf7b7e4a491fbc1e">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a33f5f6a168c4a1b3e53773a38f7f052f11">XED_OPERAND_IMM1</a>);
            <span class="keywordflow">continue</span>;
        }

        immed_parser_t disp(str_res_reg, <span class="stringliteral">"BRDISP"</span>);
        <span class="keywordflow">if</span> (disp.valid) {
            <span class="keywordflow">if</span> (CLIENT_VERBOSE3) 
                printf(<span class="stringliteral">"Setting  displacement value to "</span> <a class="code" href="xed-portability_8h.html#0a9d7f95b66014f70a711ea0558c2a19">XED_FMT_LX</a> <span class="stringliteral">"\n"</span>, disp.immed_val);
            <a class="code" href="group__ENC.html#gd366543273026967e7b1e73d21e473a7">xed_encoder_request_set_branch_displacement</a>(&amp;req,
                                                        <a class="code" href="xed-portability_8h.html#d5b19be27a5e8de0b9c4f2d16acf864b">STATIC_CAST</a>(uint32_t,disp.immed_val),
                                                        disp.width_bits/8); <span class="comment">//FIXME</span>
            <a class="code" href="group__ENC.html#gda8206e8148b22feaf7b7e4a491fbc1e">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a336eeab62720e3ae7f7d53a32cafbb1bc0">XED_OPERAND_RELBR</a>);
            <a class="code" href="group__ENC.html#g1b1eb97c09170002eaa290aa9c4ca005">xed_encoder_request_set_relbr</a>(&amp;req);
            <span class="keywordflow">continue</span>;
        }

        immed_parser_t ptr_disp(str_res_reg, <span class="stringliteral">"PTR"</span>);
        <span class="keywordflow">if</span> (ptr_disp.valid) {
            <span class="keywordflow">if</span> (CLIENT_VERBOSE3) 
                printf(<span class="stringliteral">"Setting pointer displacement value to "</span> <a class="code" href="xed-portability_8h.html#0a9d7f95b66014f70a711ea0558c2a19">XED_FMT_LX</a> <span class="stringliteral">"\n"</span>, ptr_disp.immed_val);
            <a class="code" href="group__ENC.html#gd366543273026967e7b1e73d21e473a7">xed_encoder_request_set_branch_displacement</a>(&amp;req,
                                                        <a class="code" href="xed-portability_8h.html#d5b19be27a5e8de0b9c4f2d16acf864b">STATIC_CAST</a>(uint32_t,ptr_disp.immed_val),
                                                        ptr_disp.width_bits/8); <span class="comment">//FIXME</span>
            <a class="code" href="group__ENC.html#gda8206e8148b22feaf7b7e4a491fbc1e">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a337b6a7827f66e7f32d2fe9227e58820cf">XED_OPERAND_PTR</a>);
            <a class="code" href="group__ENC.html#gf1e5d909590a0e6010595dedd9ed05ad">xed_encoder_request_set_ptr</a>(&amp;req);
            <span class="keywordflow">continue</span>;
        }

        <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edb">xed_reg_enum_t</a> reg = <a class="code" href="xed-reg-enum_8h.html#370f75460cc8548e5d6fee562c3b70ce">str2xed_reg_enum_t</a>(str_res_reg.c_str());
        <span class="keywordflow">if</span> (reg == <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a>) {
            ostringstream os;
            os &lt;&lt; <span class="stringliteral">"Bad register name: "</span> &lt;&lt; str_res_reg &lt;&lt; <span class="stringliteral">" on operand "</span> &lt;&lt; i;
            xedex_derror(os.str().c_str()); <span class="comment">// dies</span>
        }
        <span class="comment">// The registers operands aer numbered starting from the first one</span>
        <span class="comment">// as XED_OPERAND_REG0. We incremenet regnum (below) every time we add a</span>
        <span class="comment">// register operands.</span>
        <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a33">xed_operand_enum_t</a> r = <a class="code" href="xed-portability_8h.html#d5b19be27a5e8de0b9c4f2d16acf864b">STATIC_CAST</a>(<a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a33">xed_operand_enum_t</a>,<a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a3304d716e747292fdf8bacd58d3c7ffe4c">XED_OPERAND_REG0</a> + regnum);
        <span class="comment">// store the register identifer in the operand storage field</span>
        <a class="code" href="group__ENC.html#g0b32708e3be77ac90334b107940548a7">xed_encoder_request_set_reg</a>(&amp;req, r, reg);
        <span class="comment">// store the operand storage field name in the encode-order array</span>
        <a class="code" href="group__ENC.html#gda8206e8148b22feaf7b7e4a491fbc1e">xed_encoder_request_set_operand_order</a>(&amp;req, operand_index, r);
        regnum++;
    } <span class="comment">// for loop</span>

    <span class="keywordflow">return</span> req;
}
</pre></div> 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sun Feb 17 20:09:05 2008 for XED2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
