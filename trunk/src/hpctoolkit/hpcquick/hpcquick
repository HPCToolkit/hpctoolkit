#! /usr/bin/env perl

# Note: Using the following 'fool proof' method of starting Perl will
# cause problems unless HPCTOOLKIT stuff has been added to the shell
# initialization file.  The exec will start a new shell and 'hpqquick' will
# not be found unless shell's initialization file sets the PATH.  This
# is probably not what we want.

#eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
#& eval 'exec perl -S $0 $argv:q'
#if 0;

## $Id$
## * BeginRiceCopyright *****************************************************
## 
## Copyright ((c)) 2002, Rice University 
## All rights reserved.
## 
## Redistribution and use in source and binary forms, with or without
## modification, are permitted provided that the following conditions are
## met:
## 
## * Redistributions of source code must retain the above copyright
##   notice, this list of conditions and the following disclaimer.
## 
## * Redistributions in binary form must reproduce the above copyright
##   notice, this list of conditions and the following disclaimer in the
##   documentation and/or other materials provided with the distribution.
## 
## * Neither the name of Rice University (RICE) nor the names of its
##   contributors may be used to endorse or promote products derived from
##   this software without specific prior written permission.
## 
## This software is provided by RICE and contributors "as is" and any
## express or implied warranties, including, but not limited to, the
## implied warranties of merchantability and fitness for a particular
## purpose are disclaimed. In no event shall RICE or contributors be
## liable for any direct, indirect, incidental, special, exemplary, or
## consequential damages (including, but not limited to, procurement of
## substitute goods or services; loss of use, data, or profits; or
## business interruption) however caused and on any theory of liability,
## whether in contract, strict liability, or tort (including negligence
## or otherwise) arising in any way out of the use of this software, even
## if advised of the possibility of such damage. 
## 
## ******************************************************* EndRiceCopyright *


# ----------------------------------------------------------------------
#
# hpcquick  -- R. Fowler  July, 2000
#   
# A Perl script to help new users get started quickly with 'hpcview'.
# This script processes profile data files, creates a simple configuration 
# file and runs 'hpcview' using that configuration.
# 
# To get started --
#   -1.  Set the environment variable $HPCTOOLKIT to the installed location
#        of HPCToolkit, and execute "source $HPCTOOLKIT/Sourceme-csh" or 
#        "source $HPCTOOLKIT/Sourceme-sh" to set other environment variables 
#        and modify your PATH.
#    0.  Go to the directory in which you want to run your program and
#        in which you will collect profiling information.
#    1.  Run your program under ssrun (SGI/MIPS) or uprofile (Compaq/Alpha) 
#        several times to gather raw data.
#    2.  Run hpcquick with arguments specifying the paths to your
#        source code and the names of files output by ssrun.  
#    3.  Point your web browser at the resulting database.
#    (4) If the results don't satisfy you, modify the outputs of hpcquick
#        (a sequence of commands and a 'hpcview' configuration file) to 
#        do what you need.
#       
# Step 1 creates a set of binary files containing your profiling
#   information.
# Step 2 converts the binary files into the form expected by
#   'hpcview'.  It then runs 'hpcview' on those files to create a
#   subdirectory called HPCQUICK and to fill it with browsable
#   performance information.
# Step 3 browses the data.
#   There are two useful side effects of Step 2.  It echos the stream
#   of commands it uses to a log file.  It also creates an 'hpcview'
#   configuration file.  The easy way to migrate to more complex uses
#   of 'hpcview' (Step 3) is to create a script containing
#   modifications to the command sequence, and to modify the
#   configuration file to meet your requirements.
#
# ----------------------------------------------------------------------

# Todo notes (eraxxon):
#
# I have significantly revised hpcquick to 'sort-of' work along the
# following lines.  However, more revisions are needed to beautify
# (improving maintainability and extensibility).  The motivation
# behind all this is that PROFILE files are now the standard format
# for profile data.  Instead of trying to extract metric names et
# al. from profile filenames, we want to rely on ptran/xprof/papiprof
# to produce a PROFILE file, extract information from this and then
# produce the hpcview database.  We have to know just enough about
# binary formats to known when to run ptran et al, but that is it.
# Another motivation is that we want to be able to process PROFILE
# files directly.
#
# Note: Generally speaking, the metric names in the data structures should
# refer to PROFILE metrics and data.
#
# 1. Produce PROFILE info for all binary profiles. (ssrun, umon.out, etc.)
#    - Convert to one or more binary profiles to PROFILE info (stored
#      in a temporary filename since we don't know how to extract
#      metric names).
#    - Associate raw profile files with PROFILE file (for later use).
#    - Result is a list of {PROFILE, rawprofile} structs
#
# 2. Examine PROFILE files and init intermediate data structures
#    - Set data structures (metric types, etc.) based on PROFILE info.
#    - For PROFILE files with assoc. raw profile files, rename the temp
#      PROFILE to a good name based on the metrics within. 
# 
# 3. Output hpcview related files based on info in data structures.
#
# ** Does not currently support uprofile output. **

# ----------------------------------------------------------------------

use HPCToolkitVersionInfo;
use FileHandle();

STDOUT->autoflush(1); 

#print STDOUT "path $ENV{PATH} \n";

# ----------------------------------------------------------------------

$usage = 
"Usage: 
  hpcquick [-V] -I dir1 dir2 ... dirN  [-S structure]  -P prof1 prof2 ... profM
  
Given a list of paths to directories containing interesting program 
source code files, an optional program structure file created by the
'bloop' tool, and a list of profile files, 1) creates an 'hpcview' 
configuration file and a browsable database in the current directory.
All shell commands are captured into a log file.

Following is a list of the various profile files accepted.  If needed,
they will automatically be converted into the PROFILE format for
hpcview (using the vendor's 'prof' tool and 'ptran').
  o binary output from SGI's ssrun
  o XML PROFILE files from xprof, papiprof and ptran

Options:
  -V: print version information
  -I: dir1...dirN specify a list of directories -- relative or absolute -- 
      containing source code to which performance data should be 
      correlated.  In order to search a directory *and* recursively search 
      all of its descendents, append an escaped '*' after the last slash,
      e.g., /mypath/\\* (escaping is for the shell).
  -S: Optional program structure from 'bloop'.
  -P: prof1...profM specify a list of profile files.
";

#   o [binary output from Alpha-Tru64's uprofile] 

# ----------------------------------------------------------------------

# fields of the configuration XML file

my %configuration = (
		     title            => undef,
		     incDirs          => undef,
		     expTypes         => undef,
		     displayNames     => undef,
		     metrics          => [ ], # array of 'metric'
		     dumpFlag         => undef,
		     );

my %names = (
	     hashTable  => undef,
	     total      => 0,
	     totals     => undef,
	     indices    => undef,
	     names      => undef,
	     );

my %metric = (
	      expType      => undef,
	      displayName  => undef,
	      rawProfFiles => undef, # raw profile files for the metric
	      PROFILEfile  => undef, # the PROFILE file
	      PROFILEmid   => undef, # id of the metric within PROFILE
	      );

# ----------------------------------------------------------------------

my $ssrunType = 0;
my $uprofileType = 1;
my $PROFILEType = 2;

# ----------------------------------------------------------------------

my $pxmlExt        = '.pxml';
my $PROFILEFileRE  = '.+\.pxml';
my $ssrunFileRE    = '(.*)\.(\w+)\.([fm]\d+)';

my $xmlAttrRE      = '\s*=\s*\"([^\"]+)\"'; # grabs everything between ""

#  my $titleOpt      = '-title';
## my $configFileOpt = '-config';
## my $dumpOpt       = '-n';
## my $groupRE       = '^-grp(=(\w+))?';
## my $singleRE      = '^-sng(=(\w+))?';
my $verOpt          = '-V';
my $incOpt          = '-I';
my $profOpt         = '-P';
my $structOpt       = '-S';

my $configFile = "hpcquick.xml";
my $logFile = "hpcquick.log";

my $profileCmd = "prof";
my $ptranCmd = "ptran";
my $remove = "/bin/rm";
my $tmpFile = ".tmp";


#
# initialize the configuration data structure
#

# contains included directories
$configuration{incDirs} = { %names, };
$configuration{incDirs}->{hashTable} = { };
$configuration{incDirs}->{totals} = [ ];
$configuration{incDirs}->{indices} = [ ];
$configuration{incDirs}->{names} = [ ];

# includes all different experiment types
$configuration{expTypes} = { %names, };
$configuration{expTypes}->{hashTable} = { };
$configuration{expTypes}->{totals} = [ ];
$configuration{expTypes}->{indices} = [ ];
$configuration{expTypes}->{names} = [ ];

# includes all different display names
$configuration{displayNames} = { %names, };
$configuration{displayNames}->{hashTable} = { };
$configuration{displayNames}->{totals} = [ ];
$configuration{displayNames}->{indices} = [ ];
$configuration{displayNames}->{names} = [ ];

# includes information for each metric
$configuration{metrics} = [ ];
$structFile = "";

# ----------------------------------------------------------------------
# 'main': process the command line arguments
# ----------------------------------------------------------------------

my $argc = scalar(@ARGV);

if ($argc < 1) {
    printUsageAndExit($0);
}

my $i = 0;
while ($i < $argc) {

  # option: version
  if ($ARGV[$i] eq $verOpt) {
      printVersionAndExit($0);
  }
  # option: program structure
  if ($ARGV[$i] eq $structOpt) {
      $structFile = $ARGV[$i + 1];
      $i++;
  }
  # option: include directories
  elsif ($ARGV[$i] eq $incOpt) {
      while (isArgument($ARGV[$i + 1]) == 1) {
	  $i++;
	  processInclude(\%configuration, $ARGV[$i]);
      }
  }
  # profile files
  elsif ($ARGV[$i] eq $profOpt) {
      while (isArgument($ARGV[$i + 1]) == 1) {
	  $i++;
	  processProfile(\%configuration, $ARGV[$i]);
      }
  }
  # something not recognized
  else {
      print STDOUT "Invalid argument: '$ARGV[$i]'\n";
      printUsageAndExit($0);
  }
  
  # point to the next argument
  $i++;
}

# ------------------------------------------------------
# several option checks
# ------------------------------------------------------

if (!defined($configFile)) {
    print STDOUT "Internal Error: Missing config file name\n";
    printUsageAndExit($0);
}

if (!defined($configuration{title})) {
    print STDOUT "Internal Error: Missing title\n";
    printUsageAndExit($0);
}

if ($#{$configuration{metrics}} < 0) {
    print STDOUT "No valid performance data files specified.\n";
    printUsageAndExit($0);
}

# ------------------------------------------------------
# create output files
# ------------------------------------------------------
createOutputFiles(\%configuration, $configFile, $logFile);
exit(0);



# ----------------------------------------------------------------------
# isArgument
#   find out whether the word is an argument or option flag or undefined
#   return 0 if it is not defined
#   return 1 if it is an argument
#   return 2 if it is not an argument
# ----------------------------------------------------------------------

sub isArgument {
    my $argument = shift;
    if (!defined($argument)) {
	return 0;
    }
    if ($argument eq $verOpt
	|| $argument eq $structOpt 
	|| $argument eq $incOpt
	|| $argument eq $profOpt) {
	return 2;
    }
    return 1;
}

# ----------------------------------------------------------------------
# printUsageAndExit, printVersionAndExit
# ----------------------------------------------------------------------

sub printUsageAndExit {
    my $command = shift; # not used now
    print STDOUT ${usage};
    exit(-1);
}

sub printVersionAndExit {
    my $command = shift; # not used now
    print STDERR "hpcquick: ", $HPCToolkitVersionInfo::info, "\n";
    exit(-1);
}


# ----------------------------------------------------------------------

# ----------------------------------------------------------------------
# processInclude
#   Given a ref to a configuration data structure and an include file
#   path, perform sanity check and store the path within structure.
# ----------------------------------------------------------------------

sub processInclude {
    my ($config, $include) = @_;

    if (!defined($config->{incDirs}->{hashTable}->{$include})) {
	if (isValidSrcPath($include)) {
	    print STDOUT "Adding source path: '$include'\n";
	    $config->{incDirs}->{total}++;
	    $config->{incDirs}->{hashTable}->{$include} = 0;
	    push @{$config->{incDirs}->{names}}, $include;
	}
	else {
	    print STDOUT "Invalid argument to -I: '$include' not a directory.\n";
	    printUsageAndExit($0);
	}
    }
}

# ----------------------------------------------------------------------
# isValidSrcPath
#   Given a path to used in a PATH element, test whether it is valid.
#   Returns 1 or 0.
# ----------------------------------------------------------------------

sub isValidSrcPath {
    my ($path) = @_;

    # This is a recursive path is the last character is '*'.  If it
    # exists, strip it off. (Using regexp is inefficient but it
    # shouldn't matter.)
    $path =~ s/\*$//;

    if (-d $path && -e $path) {
	return 1;
    } else {
	return 0;
    }
}


# ----------------------------------------------------------------------

# ----------------------------------------------------------------------
# processProfile
#   Given a ref to a configuration data structure and a profile file,
#   perform sanity checks and store info within structure.
#
#   Note: In theory a metric may be defined with multiple raw profile
#   files, but we currently do not support this.  In this case, all
#   the profile data would be incorporated into one metric in a
#   PROFILE file.  *** To reiterate: Currently, there will be one
#   metric per raw profile file. ***
#
#   If we are already given a PROFILE file, we may have multiple
#   metrics within it.  (In this case several metrics will refer to
#   the same PROFILE file.)
#
# ----------------------------------------------------------------------

sub processProfile {
    my ($config, $profile) = @_;
    
    # test whether the file exists
    if ( !(-e $profile && -r $profile) ) {
	print STDOUT "Invalid or non-existent profile file: '$profile'\n";
	printUsageAndExit($0);
    }
    print STDOUT "Using performance data from file: '$profile'\n";
    
    # extract the title from the first profile
    if (!defined($config->{title})) {
	$config->{title} = constructTitleForProfile($profile);
    }
    
    # For each metric from this profile file, add metric to list
    my $metricsRef = findMetricsForProfile($profile);
    my $numMetrics = scalar(@{$metricsRef});
    if ($numMetrics == 0) {
	print STDOUT "Could not find metrics for profile file: '$profile'\n";
	printUsageAndExit($0);
    }
    
    for (my $i = 0; $i < $numMetrics; $i++) {

	my $aMetric = { %metric, };
	my $expType = $metricsRef->[$i]->{expType};
	my $displayName = $metricsRef->[$i]->{displayName};
	#print STDOUT "exptype = $expType\n";
	#print STDOUT "dispname = $displayName\n";
	
	# sets aMetric->expType, displayName
	processMetric($config, $aMetric, $expType, $displayName);
	
	# set aMetric->rawProfFiles, PROFILEfile, PROFILEmid
	if (getProfileType($profile) == $PROFILEType) {
	    $aMetric->{PROFILEfile} = $profile;
	    $aMetric->{PROFILEmid} = $metricsRef->[$i]->{PROFILEmid};
	} else {
	    my $rawProfFiles = [ ];
	    push @$rawProfFiles, $profile;
	    $aMetric->{rawProfFiles} = $rawProfFiles;
	}
	
	# Add this metric to the list
	push @{$config->{metrics}}, $aMetric;
    }

}

# ----------------------------------------------------------------------
# findMetricsForProfile
#   Given a profile file, return an array ref with all metrics
#   associated with it
# ----------------------------------------------------------------------

sub findMetricsForProfile {
    my ($profile) = @_;

    if (getProfileType($profile) == $PROFILEType) {
	return findMetricsForPROFILE($profile);
    } else {
	my $metrics = [ ];
	my $aMetric = { %metric, };
	my $i = 0;

	$aMetric->{expType} = findMetricForBinProfile($profile);
	$aMetric->{displayName} = $aMetric->{expType};
	$metrics[$i] = $aMetric;
	print STDOUT " *** $aMetric->{expType}\n";
	return \@metrics;
    }
}

# ----------------------------------------------------------------------
# constructTitleForProfile
#   Finds some tolerable title for this profile.  $profile should exist.
# ----------------------------------------------------------------------

# FIXME: It would be far superior to always find the title from the
# PROFILE files (see notes at top).

sub constructTitleForProfile {
    my ($profile) = @_;

    my $title;

    if (getProfileType($profile) == $PROFILEType) {

	my $profileHandle = new FileHandle();
	$profileHandle->open("< $profile");

	while (<$profileHandle>) {
	    my $line = $_;
	    if ($line =~ /<TARGET /) {
		($title) = ($line =~ /name$xmlAttrRE/);
		last;
	    }
	}
	$profileHandle->close();
	
    } else {
	$profile =~ /$ssrunFileRE/;
	$title = $1;

	if (!defined($title)) { 
	    $title = "<notitle>"; # hack for unmon.out 
	}
    }
    #print STDOUT "*** Title: $title\n";
    return $title;
}

# ----------------------------------------------------------------------
# getProfileType
#   Given a profile file, returns one of 'ssrunType', 'uprofileType',
#   'PROFILEType'
# ----------------------------------------------------------------------

sub getProfileType {
    my ($profile) = @_;

    # FIXME: we should detect uprofile better
    if ($profile =~ /$PROFILEFileRE/) {
	return $PROFILEType;
    } elsif ($profile =~ /$ssrunFileRE/) {
	return $ssrunType;
    } else {
	# We have to do some heavy lifting: Open and examine contents.
	my $header = "";
	my $profileHandle = new FileHandle();
	$profileHandle->open("< $profile");
	
	my $type = $uprofileType; 
	my $sz = 256; 
	my $ret = read $profileHandle, $header, $sz;
	if ($ret == $sz) {
	    if ($header =~ /<!DOCTYPE PROFILE /s) {
		$type = $PROFILEType;
	    }
	}
	$profileHandle->close();
	
	return $type;
    }
}

# ----------------------------------------------------------------------
# findMetricsForBinProfile
#   find the experiment type given a binary ssrun profile file name
# ----------------------------------------------------------------------

# FIXME: We should be extracting this stuff from PROFILE (see notes at top)

sub findMetricForBinProfile {
    my $fileName = shift;
    
    if ($fileName =~ /$ssrunFileRE/) {
	return $2;
    } else {
	return "_metric_";  # hack for umon.out
    }
}

# ----------------------------------------------------------------------
# findMetricsForPROFILE
#   Given a profile file, return an array ref with all metrics
#   associated with it. Assume the file exists.  
# ----------------------------------------------------------------------

sub findMetricsForPROFILE {
    my ($profile) = @_;

    my $metrics = [ ];
    
    my $profileHandle = new FileHandle();
    $profileHandle->open("< $profile");
    
    my $i = 0;
    while (<$profileHandle>) {
	my $line = $_;
	
	if ($line =~ /<METRIC /) {
	    my $aMetric = { %metric, };
	    
	    my ($nm) = ($line =~ /displayName$xmlAttrRE/);
	    my ($id) = ($line =~ /shortName$xmlAttrRE/);
	    print STDOUT "  Adding PROFILE metric '$nm'\n";
    
	    $aMetric->{expType} = $nm;
	    $aMetric->{displayName} = $nm;
	    $aMetric->{PROFILEmid} = $id;
	    $metrics[$i] = $aMetric;
	    $i++;
	}
	if ($line =~ /<\/METRICS>/) {
	    last;
	}
    }
    $profileHandle->close();

    return \@metrics;
}


# ----------------------------------------------------------------------
# processMetric
#   Given a ref to a configuration data structure and experiment name
#   Test whether the experiment type and display name exist
#     if yes, increase its number
#     if not, insert the new name into the array and hash table
# ----------------------------------------------------------------------

sub processMetric {
    my ($config, $aMetric, $expType, $expName) = @_;
    #print STDOUT "processMetric:\n";
    #print STDOUT "  -", @{$config->{expTypes}->{totals}}, "\n";
    #print STDOUT "  -", @{$config->{displayNames}->{totals}}, "\n";
    #print STDOUT "  $expType, $expName\n";

    my $expTypeIndex = $config->{expTypes}->{hashTable}->{$expType};
    my $expNameIndex = $config->{displayNames}->{hashTable}->{$expName};
    
    if (!defined($expTypeIndex)) {
	$expTypeIndex = $config->{expTypes}->{total}++;
	$config->{expTypes}->{hashTable}->{$expType} = $expTypeIndex;
	push @{$config->{expTypes}->{names}}, $expType;
	push @{$config->{expTypes}->{totals}}, 1;
	push @{$config->{expTypes}->{indices}}, 0;
    }
    else {
	$config->{expTypes}->{totals}->[$expTypeIndex]++;
    }
    if (!defined($expNameIndex)) {
	$expNameIndex = $config->{displayNames}->{total}++;
	$config->{displayNames}->{hashTable}{$expName} = $expNameIndex;
	push @{$config->{displayNames}->{names}}, $expName;
	push @{$config->{displayNames}->{totals}}, 1;
	push @{$config->{displayNames}->{indices}}, 0;
    }
    else {
	$config->{displayNames}->{totals}->[$expNameIndex]++;
    }
    $aMetric->{expType} = $expTypeIndex;
    $aMetric->{displayName} = $expNameIndex;
    #print STDOUT "  -", @{$config->{expTypes}->{totals}}, "\n";
    #print STDOUT "  -", @{$config->{displayNames}->{totals}}, "\n";
}


# ----------------------------------------------------------------------

# ----------------------------------------------------------------------
# createOutputFiles
#   Given a configuration data structure,
#   write out a configuration file,  and
#   execute the commands to generate the input files to hpcview.
#   the commands are also output to $logFile
#
# ----------------------------------------------------------------------

sub createOutputFiles {
    my ($config, $out, $log) = @_;
    my $outFHndl = new FileHandle();
    my $logFHndl = new FileHandle();
    my $i;
    my $numMetrics = scalar(@{$config->{metrics}});

    $outFHndl->open("> $out");
    $logFHndl->open("> $log");

    # ------------------------------------------------------
    # Create PROFILE files for any metrics that need it
    # (Note: we also deal with duplicate metric names here)
    # ------------------------------------------------------
    $i = 0;
    for ($i = 0; $i < $numMetrics; $i++) {
	my $metric = $config->{metrics}[$i];

	# both name and display name are defined according to whether
	# there are multiple instances of them.  If there are,
	# distingish by appending a cardinal number
	my $expType = $metric->{expType};
	my $expTypeQ = $config->{expTypes}->{names}[$expType];
	if ($config->{expTypes}->{totals}[$expType] > 1) {
	    $expTypeQ .= "-" . $config->{expTypes}->{indices}[$expType]++;
	}
	
	my $dispNm = $metric->{displayName};
	my $dispNmQ = $config->{displayNames}->{names}[$dispNm];
	if ($config->{displayNames}->{totals}[$dispNm] > 1) {
	    $dispNmQ .= "-" . $config->{displayNames}->{indices}[$dispNm]++;
	}
	
	#print STDOUT "expTypeQ = $expTypeQ\n";
	#print STDOUT "dispNmQ = $dispNmQ\n";
	$metric->{expType} = $expTypeQ;    # save for later (FIXME: ugly)
	$metric->{displayName} = $dispNmQ; # save for later (FIXME: ugly)
	
	# if the PROFILEfile is undefined, we must create it
	if (!defined($metric->{PROFILEfile})) {
	    print STDOUT "Processing raw performance data file...\n";
	    
	    # FIXME: Only for ssrun
	    my $PROFILE = $metric->{rawProfFiles}[0];
	    $PROFILE =~ s/$ssrunFileRE/$1.$expTypeQ$pxmlExt/;
	    if ($PROFILE eq $metric->{rawProfFiles}[0]) {
		$PROFILE .= ".$expTypeQ$pxmlExt"; # 
	    }
	    
	    my $command = "$profileCmd -lines";
	    foreach $file (@{$metric->{rawProfFiles}}) {
		$command .= " $file";
	    }
	    $command .= " | $ptranCmd > $PROFILE";

	    print STDOUT "  $command\n";
	    print {$logFHndl} "$command\n";
	    system($command);

	    $metric->{PROFILEfile} = $PROFILE;
	    $metric->{PROFILEmid} = 0; # default 
	}
    }
    print STDOUT "\n";

    # ------------------------------------------------------
    # Create hpcview configuation file
    # ------------------------------------------------------
    print STDOUT "Creating hpcview configuration file...\n";

    # print start document tag
    print {$outFHndl} "<HPCVIEW>\n\n";

    # print title
    print {$outFHndl} "<TITLE name=\"", xmlEsc($config->{title}), "\"/>\n\n";

    # print paths
    $i = 0;
    for ($i = 0; $i < $config->{incDirs}->{total}; $i++) {
	my $incdir = xmlEsc($config->{incDirs}->{names}[$i]);
	print {$outFHndl} "<PATH name=\"", $incdir, "\"/>\n";
    }
    print {$outFHndl} "\n";
    
    # print structure file
    if ($structFile ne "") {
        print {$outFHndl} "<STRUCTURE name=\"", xmlEsc($structFile), "\"/>";
	print {$outFHndl} "\n\n";
    }

    # print metrics
    $i = 0;
    for ($i = 0; $i < $numMetrics; $i++) {
	my $metric = $config->{metrics}[$i];
	
	# print METRIC start tag
	print {$outFHndl} 
	  "<METRIC name=\"", xmlEsc($metric->{expType}), "\" ",
	  "displayName=\"", xmlEsc($metric->{displayName}), "\"";
	
	if ($i == 0) { print {$outFHndl} " sortBy=\"true\""; }
	print {$outFHndl} ">\n";
	
	# print FILE subelement
	print {$outFHndl} 
	  "  <FILE name=\"", xmlEsc($metric->{PROFILEfile}), "\" ",
	  "select=\"", xmlEsc($metric->{PROFILEmid}), "\"/>\n";

	# print METRIC end tag
	print {$outFHndl} "</METRIC>\n\n";
    }
    
    # print end document tag
    print {$outFHndl} "</HPCVIEW>\n";

    $outFHndl->close();

    # ------------------------------------------------------
    # Run hpcview
    # ------------------------------------------------------
    print STDOUT "Running hpcview to create browsable database...\n";

    my $hpcquickdb = "hpcquick.db";
    if (-d $hpcquickdb || -e $hpcquickdb) {
	print STDOUT "  Warning: database directory '$hpcquickdb' exists; creating unique name.\n";
	$hpcquickdb .= "-" . $$; # append pid (if this exists, too bad)
    }

    my $command = "hpcview -h $hpcquickdb -z $out";
    print {$logFHndl} "$command\n";
    system($command);
    
    $logFHndl->close();

    print STDOUT "\n";

    # ------------------------------------------------------
    # Finalization
    # ------------------------------------------------------
    print STDOUT "Created files: '$out', '$log'\n";
    print STDOUT "Browsable database: './$hpcquickdb/index.html'\n"
}
    

# ----------------------------------------------------------------------
# -- xmlEsc($content) --
#   return a string with <, >, & and " replaced with &lt;, &gt;, &amp;
#   and &quot;.
# ----------------------------------------------------------------------

sub xmlEsc {

    # FIXME: Is there a way to make simulate C statics without placing
    # these at the top of the file to force evaulation?
    my $ampersand = "&";
    my $amp = "&amp;";
    my $quoteMark = "\"";
    my $quot = "&quot;";
    my $leftAngleBracket = "<";
    my $lt = "&lt;";
    my $rightAngleBracket = ">";
    my $gt = "&gt;";

    my ($content) = @_;
    if (!defined($content)) {
	return $content;
    }

    $content =~ s/$ampersand/$amp/g;
    $content =~ s/$quoteMark/$quot/g;

    $content =~ s/$leftAngleBracket/$lt/g;
    $content =~ s/$rightAngleBracket/$gt/g;
    return $content;
}

