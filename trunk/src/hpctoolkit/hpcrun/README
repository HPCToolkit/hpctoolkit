$Id$
=============================================================================
==
== README
==
== John Mellor-Crummey and Nathan Tallent, Rice University
==
=============================================================================

Contents:
  0. Overview
  1. Using
  2. A Few Details

=============================================================================

-1. N.B.
--------------------

hpcrun/hpcprof should be regarded as "beta" software. 


0. Overview
--------------------

This directory contains a prototype of the hpcrun profiler.  It
consists of hpcrun and hpcprof, tools for collecting and processing
profiling data, and is designed to be used with HPCToolkit's viewer.
hpcrun can profile unmodified applications using either PAPI or
native-processor events, create multiple profiles in one run and
alleviate world hunger.  (Caveat emptor...)

hpcrun launches the PAPI profiler on an unmodified application binary
using a preloaded library that intercepts the application's execution
during program launch.  When the application's execution is
intercepted, the hpcrun library determines the process' list of load
modules (including DSOs) and prepares PAPI_sprofil for profiling over
each load module.  Once the profiler is initialized, control is passed
back to the application.  When the application exits, control returns
to the hpcrun library, which calls finalization routines and writes
the profiling data to a binary file for later processing.

By default, hpcrun will profile every process spawned by the profiled
command and generate separate output for each process.  An option can
turn off this behavior.  In order to generate multiple profiles,
hpcrun requires corresponding hardware support.

hpcprof processes data collected from hpcrun, correlates it with
source file information and produces text, html or PROFILE output.
Users can use the text and html output to obtain a quick overview of
program performance.  This output consists of 1) summary lists of load
modules, files, procedures and lines sorted by profiling metric counts
and 2) source files with annotated metric information in their
margins.  Uses can use the PROFILE output with HPCView (from HPCToolkit)
in order to do a top-down analysis of the profile information.
PROFILE output should be used with HPCTools 3.5.1 or later.

hpcrun/prof is designed primarily to be used on ia64-Linux and
i686-Linux.  In theory it could be used on any system that supports
library preloading and PAPI, but sometimes better options are
available.  For example, alpha-Tru64 users will want to profile using
DCPI (HPCToolkit's xprof provides a good way of making this data
usable).

N.B.: We have not tested html output.

Parts of the hpcprof profiler have been adapted from Version 0.12 of
The Visual Profiler by Curtis L. Janssen.

=============================================================================

1. Using
--------------------

Be warned: This is still a prototype.

1.1. Prerequisites
----

* PAPI: hpcrun requires use of PAPI3.  As of this writing, one should
  use the CVS version of PAPI since it contains fixes for bugs we have
  identified.

* Kernel: 
    For Linux-IA64, you will need kernel 2.4.18 or higher (which includes
    pfmon support). 

    For Linux-x86, you will need a custom kernel that has been patched
    with perfctr.

    More information can be found at http://icl.cs.utk.edu/projects/papi.

We have tested with GCC 2.96, 3.2, 3.3.3; Intel 6.0, 7.0.

1.2.
----

hpcrun refers to events using either standard PAPI or native-processor
names.  Users should know that PAPI events do not always directly
refer to a native event counted by a given processor's performance
counters.  This is true *even if* a PAPI event exists for a given
platform.  In cases where no direct hardware counter is available,
PAPI may attempt to simulate an event counter using some combination
of other performance counter information.

1.3. To try it out:
----
  
0. Open "Makefile.include" in an editor and set variables.

     CC, CXX:          C and C++ compiler
     PAPI_INCLUDE_DIR, PAPI_LIB_DIR: 
                       locations to PAPI includes and library
     BINUTILS_DIR:     location of a GNU binutils installation 
                       (we recommend use of our modified version which 
                       can be obtained using the same CVS repository: 
                       cvs co binutils)

1. Open the file Sourceme-sh or Sourceme-csh, depending on your
   shell. These environment variables need to be set before using
   hpcrun.  After you have set the variables, source the file.

     HPCRUN_HOME         - the location of hpcrun
     HPCRUN_PAPILIB_PATH - the directory where libpapi.so lives 
     
2. Make hpcrun/hpcprof:
     make

3. Kick the tires
  
   1. List events available on your system. WARNING: currently, native
      event listing can be overwhelming.

      hpcrun -L

   2. See usage information:

      hpcrun
      hpcprof

4. Take a test drive

   1. Build test2

      cd test2
      make

   2. Collect profiling info.  A file to hold the profile histogram
      will be generated with a file name in the format
      <command>.<event1>.<hostname>.<pid>

      hpcrun -e PAPI_TOT_CYC:1000021 ./test2
         
   3. View a text summary of the profiling info:

      hpcprof -e test2 test2.PAPI_TOT_CYC.<hostname>.<pid>

   4. Create PROFILE output of the profiling info:

      hpcprof -p test2 test2.PAPI_TOT_CYC.<hostname>.<pid>

   5. Some other events you can try (and approximate periods). Note
      that appropriate period values can vary depending on your system
      and application.
        PAPI_TOT_INS - 1000021
        PAPI_FLOPS   - 1000021
        PAPI_L1_ICM  - 1019
        PAPI_L1_DCM  - 1019 or 101
      
      hpcrun -e PAPI_L1_DCM:1019 test2

   6. Create text summaries and PROFILES with multiple events:

      hpcprof -e test2  <list_of_profiles...>

      hpcprof -p test2  <list_of_profiles...>
   
=============================================================================

2. A Few Details
--------------------

2.1. hpcrun
----

Files:
  hpcrun.c/h
  hpcpapi.c/h
  preload.c
  map.c/h
  io.c/h

The files 'hprun.c' and 'preload.c' contain the main source code; the
other files are ancillary and contain brief descriptions at the top so
that it shouldn't be too difficult to divine their purpose.

'hpcrun.c' is the interface to the profiling library.  It parses
options,prepares the environment for the profiling library, forks a
new process and exec's the application to be profiled.

'preload.c' contains the bulk of the code for the profiling library.
The library is automatically loaded using the linker's LD_PRELOAD
environment variable.  Setting this variable causes the loader to load
the referened file *before* anything else is loaded.  Since libraries
can have initialization/finalization routines that are automatically
executed upon load/unload, execution control first passes to this
library.  Options are passed to it via environment variables.

The initialization routine (using the special name '_init') prepares
the library for intercepting the libc_start routine, which is the
launch point of every application.  The _init routine uses dlsym to
get a handle to the libc_start function that we are going to
intercept.  The interception is done by defining a symbol with exactly
the same prototype (C declaration) as the function to intercept:
because this library is loaded first the linker finds our symbol first
and passes control to our intercepting libc_start.  Profiling is then
initialized and execution is passed back to the intercepted function
using the handle that was obtained via dlsym.  The application then
runs normally.

We obtain a list of loaded modules (including DSOs) by examing the
data found in /proc/pid/maps (or /proc/self/maps).

After the application is finished, control passes back to the hpcrun
library.  Profiling is stopped and the data is written to a binary
output file.

2.2. hpcprof
----

Files:
  hpcprof.cc/h
  summary.cc/h
  proffile.cc/h
  loadmodule.cc/h
  PROFILE.dtd.h

hpcprof is still rough, though it should now produce useful
information.  We have tested text and PROFILE output, but not html.

You can pass multiple profile files with the same or different events.
When more than one event with the same period is detected, collective
events (min, max, sum) are automatically created to provide aggregate
info.  These collective events are output in text and html modes, but
are removed from PROFILE output.

The PROFILE format should be fairly self-explanatory.  Metric counts
(M) are embedded within a program scope tree, with a program (PGM),
load modules (LM), files (F), procedures (P), and statements (S).  The
format supports multiple metrics and thus each metric in the scope
tree is identified by a short name previously assigned in the header
information.  Note that unlike the text and html mode, metrics counts
are not given in terms of *sample* counts but rather as estimated
*event* counts, i.e., (samples) * (events/sample).

=============================================================================


