$Id$
=============================================================================
==
== README
==
== John Mellor-Crummey and Nathan Tallent, Rice University
== March 4, 2003
==
=============================================================================

Contents:
  0. Overview
  1. Using
  2. A Few Details

=============================================================================

0. Overview
--------------------

This directory contains a prototype of the papiprof profiler.  It
consists of papirun and papiprof, tools for collecting, processing and
viewing profiling data.

papirun launches the PAPI profiler on an unmodified application binary
using a preloaded library that intercepts the application's execution
during program launch.  When the application's execution is
intercepted, the papirun library determines the process' list of load
modules (including DSOs) and prepares PAPI_sprofil for profiling over
each load module.  Once the profiler is initialized, control is passed
back to the application.  When the application exits, control returns
to the papirun library, which calls finalization routines and writes
the profiling data to a binary file for later processing.

By default, papirun will profile every process spawned by the profiled
command and generate separate output for each process.  An option can
turn off this behavior.

papiprof processes data collected from papirun, correlates it with
source file information and produces text, html or PROFILE output.
Users can use the text and html output to obtain a quick overview of
program performance.  This output consists of 1) summary lists of load
modules, files, procedures and lines sorted by profiling metric counts
and 2) source files with annotated metric information in their
margins.  Uses can use the PROFILE output with HPCView (from HPCTools)
in order to do a top-down analysis of the profile information.
PROFILE output should be used with HPCTools 3.5.1 or later.

N.B.: We have not tested html output.

Parts of the papiprof profiler have been adapted from Version 0.12 of
The Visual Profiler by Curtis L. Janssen.

=============================================================================

1. Using
--------------------

Be warned: This is still a prototype.

While we intend papiprof to be ported to a number of platforms, we
have only tested it on ia64-Linux and i686-Linux.

1.1. PAPI:
----
papirun refers to events using their 'standardized' PAPI names.  Users
should know that PAPI events do not always directly refer to a native
event counted by a given processor's performance counters.  This is
true *even if* a PAPI event exists for a given platform.  In cases
where no direct hardware counter is available, PAPI may attempt to
simulate an event counter using some combination of other performance
counter information.

1.2. PAPI and ia64-Linux:
----
For IA64 support, you will need PAPI 2.3.1 or greater and a kernel of
2.4.18 or higher (which includes pfmon support). You can find more
PAPI information at http://icl.cs.utk.edu/projects/papi.

[FIXME: does this apply any more?]
N.B.: hvprof can crash when the PAPI overflow threshold is too low.
Not surprisingly, sensitivity to low thresholds varies with the PAPI
event; commonly occuring events produce greater sensitivity.  For
example, to profile issued instructions on an Itanium2 chip, you
should almost certainly avoid thresholds much lower than 100,000.  In
contrast, to profile instruction or data cache misses, the threshold
could reasonably be much smaller.  Note that given the speed of the
Itanium/Itanium2 chips and the amount of overhead necessary for
profiling, you will almost certainly want to avoid very low thresholds
anyway.

[FIXME]
If you are an user of the IA64 NCSA cluster (currently running kernel
2.4.16), you can use a custom version of PAPI 2.1.0 tailored for
pfmon-0.06a and kernel 2.4.16.  This version uses software timer
interrupts instead of hardware counter interrupts and will be a little
more inaccurate.  However, it will still produce helpul information.
The custom verion is currently located in '/u/ac/mucci/papi/src';
thanks go to Phil Mucci.

1.3. Compiler notes:
----
We have tested with GCC 2.96, 3.2; Intel 6.0, 7.0.

1.4. To try it out:
----
  
0. Open "Makefile.include" in an editor and set variables.

     CC, CXX:          C and C++ compiler
     PAPIINC, PAPILIB: locations to PAPI includes and library
     BFDINC, BFDLIB:   locations to GNU BFD includes and libraries

1. Open the file Sourceme-sh or Sourceme-csh, depending on your
   shell. These environment variables need to be set before using
   papirun.  After you have set the variables, source the file.

     PAPIRUN_HOME         - the directory you have installed papiprof in
     PAPIRUN_PAPILIB_PATH - the directory that libpapi.so lives in
     
2. Make papirun/papiprof:
     make

3. Kick the tires
  
   1. List PAPI events available on your system.

      papirun -L

   2. See usage information:

      papirun
      papiprof

4. Take a test drive

   1. Build test2

      cd test2
      make

   2. Collect profiling info.  A file to hold the profile histogram
      will be generated with a file name in the format
      <command><papi_event><process_id>.

      papirun -p 1000021 test2
         
   3. View a text summary of the profiling info:

      papiprof -e test2 test2.PAPI_TOT_CYC.pid

   4. Create PROFILE output of the profiling info:

      papiprof -p test2 test2.PAPI_TOT_CYC.pid

   5. Some other events you can try (and approximate periods). Note
      that appropriate period values can vary depending on your system
      and application.
        PAPI_TOT_INS - 1000021
        PAPI_FLOPS   - 1000021
        PAPI_L1_ICM  - 1019
        PAPI_L1_DCM  - 1019 or 101
      
      papirun -e PAPI_L1_DCM -p 1019 test2

   6. Create text summaries and PROFILES with multiple events:

      papiprof -e test2  <list_of_profiles...>

      papiprof -p test2  <list_of_profiles...>
   
=============================================================================

2. A Few Details
--------------------

2.1. papirun
----

Files:
  papirun*
  papirun.h
  preload.c
  events.c/h
  flags.c/h
  io.c/h
  map.c/h

The file 'preload.c' contains the main source code; the other files
are ancillary and contain brief descriptions at the top so that it
shouldn't be too difficult to divine their purpose.

Options are passed to 'preload.c' via environment variables.  The
'papirun' script processes all the arguments and sets a number of
corresponding environment variables which are later read by the
papirun library.

The library is automatically loaded using the linker's LD_PRELOAD
environment variable.  Setting this variable causes the loader to load
the referened file *before* anything else is loaded.  Since libraries
can have initialization/finalization routines that are automatically
executed upon load/unload, execution control first passes to this
library.

The initialization routine (using the special name '_init') prepares
the library for intercepting the libc_start routine, which is the
launch point of every application.  The _init routine uses dlsym to
get a handle to the libc_start function that we are going to
intercept.  The interception is done by defining a symbol with exactly
the same prototype (C declaration) as the function to intercept:
because this library is loaded first the linker finds our symbol first
and passes control to our intercepting libc_start.  Profiling is then
initialized and execution is passed back to the intercepted function
using the handle that was obtained via dlsym.  The application then
runs normally.

We obtain a list of loaded modules (including DSOs) by examing the
data found in /proc/pid/maps (or /proc/self/maps).

After the application is finished, control passes back to the papirun
library.  Profiling is stopped and the data is written to a binary
output file.

2.2. papiprof
----

Files:
  papiprof.cc/h
  loadmodule.cc/h
  proffile.cc/h
  summary.cc/h
  PROFILE.dtd.h

papiprof is still rough, though it should now produce useful
information.  We have tested text and PROFILE output, but not html.

You can pass multiple profile files with the same or different events.
When more than one event with the same period is detected, collective
events (min, max, sum) are automatically created to provide aggregate
info.  These collective events are output in text and html modes, but
are removed from PROFILE output.

The PROFILE format should be fairly self-explanatory.  Metric counts
(M) are embedded within a program scope tree, with a program (PGM),
load modules (LM), files (F), procedures (P), and statements (S).  The
format supports multiple metrics and thus each metric in the scope
tree is identified by a short name previously assigned in the header
information.  Note that unlike the text and html mode, metrics counts
are not given in terms of *sample* counts but rather as estimated
*event* counts, i.e., (samples) * (events/sample).

=============================================================================
