#!/bin/sh
# Testing: set -x: line by line (set -n: syntax)
# set -x

# $Id$
## * BeginRiceCopyright *****************************************************
 # Copyright ((c)) 2002, Rice University 
 # All rights reserved.
 # 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are
 # met:
 # 
 # * Redistributions of source code must retain the above copyright
 #   notice, this list of conditions and the following disclaimer.
 # 
 # * Redistributions in binary form must reproduce the above copyright
 #   notice, this list of conditions and the following disclaimer in the
 #   documentation and/or other materials provided with the distribution.
 # 
 # * Neither the name of Rice University (RICE) nor the names of its
 #   contributors may be used to endorse or promote products derived from
 #   this software without specific prior written permission.
 # 
 # This software is provided by RICE and contributors "as is" and any
 # express or implied warranties, including, but not limited to, the
 # implied warranties of merchantability and fitness for a particular
 # purpose are disclaimed. In no event shall RICE or contributors be
 # liable for any direct, indirect, incidental, special, exemplary, or
 # consequential damages (including, but not limited to, procurement of
 # substitute goods or services; loss of use, data, or profits; or
 # business interruption) however caused and on any theory of liability,
 # whether in contract, strict liability, or tort (including negligence
 # or otherwise) arising in any way out of the use of this software, even
 # if advised of the possibility of such damage.
## ******************************************************* EndRiceCopyright *

## **************************************************************************
##
## File: 
##    hpcrun: Launch the call stack profiler by setting up a preloaded
##    library that will intercept an application's execution and start
##    the profiler.  This script processes arguments and passes them
##    to the profiling library through environment variables.
##
## Author:
##    Written by Nathan Tallent, Rice University.
##    
## **************************************************************************

#############################################################################

# If this script can't find its own install prefix, or if the script
# is moved elsewhere, then set HPCTOOLKIT here.
# HPCTOOLKIT=/path/to/install/prefix

# Relative paths are relative to HPCTOOLKIT.
hpcfnbounds_dir='libexec/hpctoolkit'
libcsprof_dir='lib/hpctoolkit'
libmonitor_dir='@LIBMONITOR_RUN_DIR@'
papi_libdir='@OPT_PAPI_LIBPATH@'

# umask -S g=rwx,o=rwx # temporary check
# umask -S -p # see change

ulimit_works='' # default to NO on jacquard

# One can set personal defaults here, instead of changing source code.
# These values will be overriden by commandline options.
opt_out_path=""
opt_lush_agents="";
opt_period=""
opt_memsize=""
opt_event=""
opt_verbosity=""
opt_debug=""
opt_debug_wait=""
opt_papi=""
opt_ev_list=''
opt_trace=""
opt_quiet=''

#######################

# Use mechanism below to turn on default -dd options

#dd_list="UNW_CONFIG PREFER_BP"
#L2="$dd_list "

#####################

# These option variables cannot be modified with personal defaults.

cmd_to_profile=""

#############################################################################

# Note: All function names are prefixed with 'f_' in order to make
# function calls very clear.

cmd="$0"

hpc_path_to_root=..
@export_hpctoolkit@

# Relative paths are relative to HPCTOOLKIT.
case "$hpcfnbounds_dir" in
  /* ) ;;
  * ) hpcfnbounds_dir="${HPCTOOLKIT}/${hpcfnbounds_dir}" ;;
esac
case "$libcsprof_dir" in
  /* ) ;;
  * ) libcsprof_dir="${HPCTOOLKIT}/${libcsprof_dir}" ;;
esac
case "$libmonitor_dir" in
  /* ) ;;
  * ) libmonitor_dir="${HPCTOOLKIT}/${libmonitor_dir}" ;;
esac
case "$papi_libdir" in
  /* ) ;;
  * ) papi_libdir="${HPCTOOLKIT}/${papi_libdir}" ;;
esac

f_usage()
{
  cat <<EOF
Usage:
   hpcrun [profiling-options] <command> [command-arguments]
   hpcrun [info-options]

Options: Informational
  -V, --version        Print version information.
  -h, --help           Print help.

Options: Profiling (Defaults shown in curly brackets {})
  -o <outpath>, --output <outpath>
     The directory in which to store profiles collected with hpcrun.
     By default, hpcrun stores call stack profile files (suffix .csp)
     and log files (suffix .log) in a subdirectory of the current 
     directory. 

     If PBS or the Sun Grid Engine is being used for job control, the 
     default subdirectory name will have the form 
     hpctoolkit-<yourappname>-measurements-<jobid>, where <yourappname>
     is the name of your executable, and <jobid> corresponds
     to a job identifier from PBS or the Sun Grid Engine.

     If you are not using PBS or the Sun Grid Engine for job control, 
     then the name of the default output directory will have the form 
     hpctoolkit-<yourappname>-measurements. 

     If you measure multiple runs of the same executable with hpcrun 
     from within the same working directory without specifying an output 
     path using -o or running under a batch system's job control, profiles 
     from multiple runs will be placed in the same output directory.  The 
     only way to distinguish profiles from multiple runs will be by their 
     creation times or the measurement data that the profiles contain.

  -e <event>[@<period>], --event <event>[@<period>]
     This argument is used to specify an event that hpcrun should
     use as the basis for statistical sampling along with the event 
     period.  This argument may be used multiple times to specify that 
     multiple events should be used as sample sources. Each event can 
     have a distinct period.

     If no event is specified, the default event specification is
     WALLCLOCK@5000 (a sample event every 5000 microseconds). You may
     specify a shorter or longer period for WALLCLOCK events. Your 
     operating system may silently ensure that your period is not too 
     short and round your specified period up to the system's minimum. 
     If you want to know your system's minimum period, check the man 
     page for setitimer for further information. 

     Besides the WALLCLOCK event, one can also use hardware performance
     counter events to measure execution behavior. hpcrun uses the PAPI 
     library to provide access to hardware performance counter events.  
     If you have not configured HPCToolkit to use the PAPI library, you 
     will be unable to measure hardware performance counter events.

     The PAPI library supports a large collection of hardware counter 
     events.  Some events have standard names across all platforms, e.g. 
     PAPI_TOT_CYC, the event that measures total cycles. In addition to 
     events whose names begin with the PAPI_ prefix, platforms also 
     provide access to a set of native events with names that are 
     specific to the platform's processor. A complete list of events
     supported by the PAPI library for your platform may be obtained by 
     running the command "hpcrun-flat -L". Any event whose name begins
     with the PAPI_ prefix that is listed as "Profilable" can be used
     as an event in a -e specification. Any native event may be used as
     a sampling source. For hardware performance counter events, the
     PERIOD component of a -e specification indicates the sampling period 
     in terms of the number of events between samples.

     Restrictions:
     
     hpcrun supports only the WALLCLOCK event based on the Linux interval 
     timer and hardware performance counter events supported by the PAPI 
     library.

     The WALLCLOCK event is triggered by the Unix itimer feature. The "PERIOD"
     component of the WALLCLOCK event is the number of microseconds between
     samples.

     In a single execution, you cannot measure both the WALLCLOCK event
     and PAPI events; you may however measure multiple PAPI events in a
     single execution.

     EXAMPLE
       hpcrun -e PAPI_TOT_INS@1000000 -e PAPI_FP_INS@100000 A_PROGRAM

       The above command line would sample A_PROGRAM every 1,000,000 instructions
       and every 100,000 floating point instructions.

NOTES:
* hpcrun uses preloaded shared libraries to initiate profiling. For this
  reason, modifications to the hpcrun launcher script will be necessary to 
  profile programs that use library preloading.

* hpcrun cannot be used to profile setuid commands since preloading of shared
  libraries is not permitted for setuid programs.
EOF
}


#  -t 
#
#      Record a call path trace in addition to call path profile. Each trace
#      record is 12 bytes in length (4 bytes to hold the identify of a call path, and
#      8 bytes to hold a time stamp). [ 1 Dec 2008  - Recording and visualizing 
#      call path traces is an experimental capability. ] 


f_version()
{
  cat <<EOF
hpcrun: A member of HPCToolkit, version @PACKAGE_VERSION@
EOF
}


f_erroneous_option()
{
  cat <<EOF
hpcrun: Unknown option switch: $@
Type 'hpcrun --help' for more information.
EOF
}


f_checkenv()
{
  RLD_LIB="${libcsprof_dir}/libcsprof.so:${libmonitor_dir}/libmonitor.so"

  # preload our library first before loading all of those specified in
  # the application binary (signified by DEFAULT).
  # this turns our sampling on at the beginning of the application
  # when our library is loaded.

  sysname=`uname`

  if [ "$sysname" = "OSF1" ]; then
    _RLD_LIST="${RLD_LIB}:DEFAULT"
  else
    LD_PRELOAD="${RLD_LIB}"
  fi
}

# args: ($1, $2): (string_to_check, string_for_error_msg[optional])
f_error_on_nil()
{
  if [ -z "$1" ]; then
    if [ -n "$2" ]; then printf "$2"; fi
    f_usage
    exit 1
  fi
}

# args: ($1, $2): (option, option_value)
f_opt_check()
{
  # 'option_value' should be non-nil
  f_error_on_nil "$2" "** no value for option $1\n"
    
  # 'option_value' should not start with '-'
  if ( echo "$2" | grep '^-.*' >/dev/null 2>&1 ); then
    printf "** invalid value for option $1: $2\n"
    f_usage
    exit 1
  fi
}

# args: ($1..$n): all arguments given to this script
f_getoptions()
{
  # We can't easily use 'getopt' or 'getopts' because we have to
  # protect options given to the command to profile.

  if [ -z "$1" ]; then
    f_usage
    exit 0
  fi

  # parse argument list
  while [ $# -ge 1 ]; do
    case $1 in
      # special options
      -h | --help)
        f_usage; exit 0;
        ;;

      -V | --version)
        f_version; exit 0;
        ;;

      -md)  opt_monitor_debug=1 ;;
      -dd)  shift; 
            dd_list="$L2$1"
	    L2="$dd_list "
            ;;
      -d)  opt_debug_wait=1;
            ;;

       # general options
      -a) 
        shift; opt_lush_agents="$1";
        f_opt_check "-a" "${opt_lush_agents}";
        ;;

      -e | --event) 
        shift; 
        # replace : separator with @ to retain support for old syntax
	LLL=`echo $1 | tr ':' '@'`
        opt_ev_list="$LL$LLL";
	LL="$opt_ev_list "
        ;;

      -L)
        # shift; opt_debug="$1";
        # f_opt_check "-L" "${opt_debug}";
	opt_debug=1
        ;;

      -lm | --low-memsize )
	shift
	export HPCRUN_LOW_MEMSIZE="$1"
	;;

      -ms | --memsize )
	shift
	export HPCRUN_MEMSIZE="$1"
	;;

      -o | --output)
        shift; opt_out_path="$1"; 
        f_opt_check "-o" "${opt_out_path}";
        ;;

      -t) 
        opt_trace=1
        ;;

      -q)
        opt_quiet=1
	;;
      -*)
        f_erroneous_option $1;
        exit 1;
        ;;

      *) break ;;
    esac
    shift
  done

  # FIXME: this is fundamentally broken if args contain spaces.
  cmd_to_profile="$*"
  f_error_on_nil "${cmd_to_profile}" "** no command to profile\n";
}

# get the executable from the list of (remaining) args
f_getexec()
{
    _EXEC=$1
}

# assumes: all hpcrun control variables have been set
#
# adds the unwind nm file to the LD_PRELOAD
#
f_prepareenv()
{
  sysname=`uname`

  # export the profiler library
  if [ $sysname = "OSF1" ]; then
    export _RLD_LIST
  else
    export LD_PRELOAD
  fi

  export CSPROF_NM_COMMAND="${hpcfnbounds_dir}/hpcfnbounds"

  # export profiler options
  if [ -n "${opt_lush_agents}" ]; then
    CSPROF_OPT_LUSH_AGENTS="${opt_lush_agents}"
    export CSPROF_OPT_LUSH_AGENTS
  fi
  if [ -n "${opt_out_path}" ]; then
    CSPROF_OPT_OUT_PATH="${opt_out_path}"
    export CSPROF_OPT_OUT_PATH
  fi
#  if [ -n "${opt_period}" ]; then
#    CSPROF_OPT_SAMPLE_PERIOD="${opt_period}"
#    export CSPROF_OPT_SAMPLE_PERIOD
#  fi
#  if [ -n "${opt_memsize}" ]; then
#    CSPROF_OPT_MEM_SZ="${opt_memsize}"
#    export CSPROF_OPT_MEM_SZ
#  fi
  if [ -n "${opt_ev_list}" ]; then
    HPCRUN_EVENT_LIST="${opt_ev_list}"
  else
    HPCRUN_EVENT_LIST="WALLCLOCK@5000"
  fi
  export HPCRUN_EVENT_LIST
  if [ -n "${opt_debug}" ]; then
    CSPROF_OPT_DEBUG="${opt_debug}"
    export CSPROF_OPT_DEBUG
  fi
  if [ -n "${opt_debug_wait}" ]; then
    export CSPROF_WAIT=1
  fi
  if [ -n "$dd_list" ]; then
    export HPCRUN_DEBUG_FLAGS=$dd_list
  fi
  if [ -n "$opt_monitor_debug" ]; then
    export MONITOR_DEBUG=1
  fi
  if [ -n "${opt_trace}" ]; then
    export CSPROF_OPT_TRACE=1
  fi
  if [ -n "${opt_quiet}" ]; then
    export HPCRUN_QUIET=1
  fi


  # Make sure that `.' is in the PATH so that we can find the command
  # to profile if in the current directory. [We can get around this,
  # but for now it is the quickest thing.] 
  export PATH=".:${PATH}" 

  # set up the LD_LIBRARY_PATH
  case "$papi_libdir" in
      /* )
	  LD_LIBRARY_PATH="${papi_libdir}:$LD_LIBRARY_PATH"
	  ;;
  esac
  export LD_LIBRARY_PATH
}

#############################################################################
# Main
#############################################################################
# $n: argument n, with $0 being the command name
# $*: all arguments from $1 to $n

f_checkenv 

f_getoptions "$@"
f_getexec $cmd_to_profile

#
# Sanity checks before launching the application.
#
# In the dynamic case, verify that the application and libcsprof are
# either both 32-bit or both 64-bit.  Give a pass to scripts,
# statically-linked binaries (which we don't really support via
# hpcrun) and programs on PATH (for now).
#
if test -x "$_EXEC" ; then
  file_out=`file -L "$_EXEC"`
  echo "$file_out" | grep -E -i -e 'elf.*dynamic' >/dev/null 2>&1
  if test $? -eq 0 ; then
    appl_bit=`expr "$file_out" : '.*ELF.*\([0-9][0-9].bit\)'`
    file_out=`file -L "${libcsprof_dir}/libcsprof.so"`
    csprof_bit=`expr "$file_out" : '.*ELF.*\([0-9][0-9].bit\)'`
    if test "$appl_bit" != "$csprof_bit" ; then
      echo "cannot run application $_EXEC" 1>&2
      echo "application is $appl_bit but hpctoolkit is $csprof_bit" 1>&2
      exit 1
    fi
  fi
fi

f_prepareenv

if [ ${ulimit_works}x != x ]; then
   ulimit -c unlimited
fi
if [ -n "${opt_debug}" ]; then
  echo hpcrun script LD_PRELOAD = $LD_PRELOAD
  echo HPCRUN_DEBUG_FLAGS = $HPCRUN_DEBUG_FLAGS
  echo event list = $HPCRUN_EVENT_LIST
fi
#
# !!! WOW !!
# prevent wierdo error:
# *** glibc detected *** double free or corruption (out): 0x0000000000501030 ***
#
#export MALLOC_CHECK_=0
exec ${cmd_to_profile}
