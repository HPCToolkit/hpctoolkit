#!/usr/bin/env python
#
# Summarize the .log and .hpcrun files in an HPCToolkit measurements
# directory.
#
# Usage: ./hpclist [-ah] [directory]
#
#  -a adds summary info for blocks and errors
#  -h displays the help message
#
# $Id$
#

import getopt
import os
import re
import sys

# Global variables
DATA = []
DIRLIST = []
BASE2INDEX = {}
MAX_TID = 0
NUM_ERRORS = 0

# Constants
BLOCKS = 'blocks'
ERRORS = 'errors'
SAMPLES = 'samples'
BASE = 'base'
FILESIZE = 'filesize'
NAME = 'name'

# Regular expressions
summary_re = re.compile(r'recorded:\s*(\d+).+blocked:\s*(\d+).+errant:\s*(\d+)')


def warn(mesg):
    global NUM_ERRORS
    print >>sys.stderr, mesg
    NUM_ERRORS += 1
    return


def usage():
    print '''usage: %s [-ah] [directory]

  -a, --all
    include summary info for blocked and errant samples

  -h, --help
    display this message

The directory is an HPCToolkit measurements directory,
or else the current directory if omitted.''' % sys.argv[0]
    sys.exit(0)


#
# Hpcrun and log file names:
#   <program-name>-<mpi-rank>-<thread-id>-<machine-id>-<pid>.hpcrun
#   <program-name>-<mpi-rank>-<thread-id>-<machine-id>-<pid>.log
#
def parse_name(fname, ext):
    l = fname[0 : len(fname) - len(ext)].rsplit('-', 4)
    if len(l) != 5:
        return (None, None)
    base = '-'.join([l[0], l[1], l[3], l[4]])
    tid = int(l[2])
    return (base, tid)


def do_log_file(fname):
    global DATA, BASE2INDEX

    (base, tid) = parse_name(fname, '.log')
    if not base:
        warn('bad .log file name: %s' % fname)
        return
    try:
        file = open(fname, 'r')
    except IOError:
        warn('unable to open: %s' % fname)
        return

    l = file.readline()
    while l:
        if l.startswith('SUMMARY'):
            obj = re.search(summary_re, l)
            if not obj:
                warn('bad SUMMARY line in: %s' % fname)
                file.close
                return
            samples, blocks, errors = map(int, obj.groups())
            DATA.append(
                { BLOCKS : blocks,
                  ERRORS : errors,
                  SAMPLES : samples,
                  BASE : base })
            BASE2INDEX[base] = len(DATA) - 1
            break
        l = file.readline()
    else:
        warn('unable to find SUMMARY line in: %s' % fname)

    file.close
    return


def do_hpcrun_file(fname):
    global DATA, BASE2INDEX, MAX_TID

    (base, tid) = parse_name(fname, '.hpcrun')
    if not base:
        warn('bad .hpcrun file name: %s' % fname)
        return
    try:
        n = BASE2INDEX[base]
    except KeyError:
        warn('missing or corrupt .log file for: %s' % fname)
        return
    if DATA[n][BASE] != base:
        warn('internal DATA corruption for: %s' % fname)
        return

    try:
        st = os.stat(fname)
    except OSError:
        warn('unable to stat: %s' % fname)
        return
    MAX_TID = max(tid, MAX_TID)
    DATA[n][(tid, FILESIZE)] = st.st_size
    DATA[n][(tid, NAME)] = fname
    return


def display_metric(title, label, metric):
    global DATA

    DATA.sort(lambda x, y : cmp(x[metric], y[metric]))
    nproc = len(DATA)
    total = sum([elt[metric] for elt in DATA])

    print '=' * 72
    if isinstance(metric, tuple):
        tid = metric[0]
        print '%s, thread %d' % (title, tid)
    else:
        tid = 0
        print title
    print
    print '%7s  %14s  %s' % ('rank', label, 'file')
    if nproc <= 16:
        for n in range(nproc):
            print '%7d  %14d  %s' % (
                n, DATA[n][metric], DATA[n][(tid, NAME)])
    else:
        for dec in range(11):
            n = (dec * (nproc - 1)) / 10
            print '%6d%%  %14d  %s' % (
                (10 * dec), DATA[n][metric], DATA[n][(tid, NAME)])
    print
    print 'processes: %d, average: %0.1f' % (nproc, total / float(nproc))
    return


#
# Main program.
#
try:
    opts, args = getopt.getopt(sys.argv[1:], 'ah', ['all', 'help'])
except getopt.GetoptError:
    usage()

opt_display_all = False
for opt, arg in opts:
    if opt in ('-a', '--all'):
        opt_display_all = True
    elif opt in ('-h', '--help'):
        usage()
    else:
        sys.exit('unknown option: %s' % opt)

# Read and process .log and .hpcrun files.
if len(args) > 0:
    try:
        os.chdir(args[0])
    except OSError:
        sys.exit('unable to cd to: %s' % args[0])

DIRLIST = os.listdir('.')
for file in DIRLIST:
    if file.endswith('.log'):
        do_log_file(file)
if len(DATA) == 0:
    sys.exit('no valid .log files')

for file in DIRLIST:
    if file.endswith('.hpcrun'):
        do_hpcrun_file(file)

# Print the summaries.
if opt_display_all:
    display_metric('Blocked Samples', 'blocks', BLOCKS)
    display_metric('Errant Samples', 'errors', ERRORS)
display_metric('Recorded Samples', 'samples', SAMPLES)
for t in range(MAX_TID + 1):
    display_metric('File Size', 'size', (t, FILESIZE))

print '=' * 72

# Warn if there were any errors.
if NUM_ERRORS > 0:
    print
    print '!! Warning: summary finished with %d errors !!' % NUM_ERRORS
    print

