#!/usr/bin/env python
#
# Summarize the .log and .hpcrun files in an HPCToolkit measurements
# directory.
#
# Usage: ./hpclist [-ah] [directory]
#
#  -a adds summary info for blocks and errors
#  -h displays the help message
#
# $Id$
#

import getopt
import os
import re
import sys

# Global variables
DATA = []
DIRLIST = []
PID2INDEX = {}
MAX_TID = 0
NUM_ERRORS = 0

# Constants
BLOCKS = 'blocks'
ERRORS = 'errors'
SAMPLES = 'samples'
FILESIZE = 'filesize'
PID = 'pid'
NAME = 'name'

# Regular expressions
log_re = re.compile(r'-(\d+)\.log')
hpcrun_re = re.compile(r'-(\d+)-[0-9a-fA-F]+-(\d+).hpcrun')
summary_re = re.compile(r'recorded:\s*(\d+).+blocked:\s*(\d+).+errant:\s*(\d+)')


def warn(mesg):
    global NUM_ERRORS
    print >>sys.stderr, mesg
    NUM_ERRORS += 1
    return


def usage():
    print '''usage: %s [-ah] [directory]

  -a, --all
    include summary info for blocked and errant samples

  -h, --help
    display this message

The directory is an HPCToolkit measurements directory,
or else the current directory if omitted.''' % sys.argv[0]
    sys.exit(0)
    

def do_log_file(fname):
    global DATA, PID2INDEX

    obj = re.search(log_re, fname)
    if not obj:
        warn('bad .log file name: %s' % fname)
        return
    pid = int(obj.group(1))

    try:
        file = open(fname, 'r')
    except IOError:
        warn('unable to open: %s' % fname)
        return

    l = file.readline()
    while l:
        if l.startswith('SUMMARY'):
            obj = re.search(summary_re, l)
            if not obj:
                warn('bad SUMMARY line in: %s' % fname)
                file.close
                return
            samples, blocks, errors = map(int, obj.groups())
            DATA.append(
                { BLOCKS : blocks,
                  ERRORS : errors,
                  SAMPLES : samples,
                  PID : pid })
            PID2INDEX[pid] = len(DATA) - 1
            break
        l = file.readline()
    else:
        warn('unable to find SUMMARY line in: %s' % fname)

    file.close
    return


def do_hpcrun_file(fname):
    global DATA, PID2INDEX, MAX_TID

    obj = re.search(hpcrun_re, fname)
    if not obj:
        warn('bad .hpcrun file name: %s' % fname)
        return
    tid, pid = map(int, obj.groups())
    n = PID2INDEX[pid]
    if DATA[n][PID] != pid:
        warn('internal DATA corruption for: %s' % fname)
        return

    try:
        st = os.stat(fname)
    except OSError:
        warn('unable to stat: %s' % fname)
        return
    MAX_TID = max(tid, MAX_TID)
    DATA[n][(tid, FILESIZE)] = st.st_size
    DATA[n][(tid, NAME)] = fname
    return


def display_metric(title, label, metric):
    global DATA
    
    DATA.sort(lambda x, y : cmp(x[metric], y[metric]))
    nproc = len(DATA)
    total = sum([elt[metric] for elt in DATA])

    print '=' * 72
    if isinstance(metric, tuple):
        tid = metric[0]
        print '%s, thread %d' % (title, tid)
    else:
        tid = 0
        print title
    print
    print '%7s  %14s  %s' % ('rank', label, 'file')
    if nproc <= 16:
        for n in range(nproc):
            print '%7d  %14d  %s' % (
                n, DATA[n][metric], DATA[n][(tid, NAME)])
    else:
        for dec in range(11):
            n = (dec * (nproc - 1)) / 10
            print '%6d%%  %14d  %s' % (
                (10 * dec), DATA[n][metric], DATA[n][(tid, NAME)])
    print
    print 'processes: %d, average: %0.1f' % (nproc, total / float(nproc))
    return


#
# Main program.
#
try:
    opts, args = getopt.getopt(sys.argv[1:], 'ah', ['all', 'help'])
except getopt.GetoptError:
    usage()

opt_display_all = False
for opt, arg in opts:
    if opt in ('-a', '--all'):
        opt_display_all = True
    elif opt in ('-h', '--help'):
        usage()
    else:
        sys.exit('unknown option: %s' % opt)

# Read and process .log and .hpcrun files.
if len(args) > 0:
    try:
        os.chdir(args[0])
    except OSError:
        sys.exit('unable to cd to: %s' % args[0])
        
DIRLIST = os.listdir('.')
for file in DIRLIST:
    if file.endswith('.log'):
        do_log_file(file)
if len(DATA) == 0:
    sys.exit('no valid .log files')

for file in DIRLIST:
    if file.endswith('.hpcrun'):
        do_hpcrun_file(file)

# Print the summaries.
if opt_display_all:
    display_metric('Blocked Samples', 'blocks', BLOCKS)
    display_metric('Errant Samples', 'errors', ERRORS)
display_metric('Recorded Samples', 'samples', SAMPLES)
for t in range(MAX_TID + 1):
    display_metric('File Size', 'size', (t, FILESIZE))

print '=' * 72

# Warn if there were any errors.
if NUM_ERRORS > 0:
    print
    print '!! Warning: summary finished with %d errors !!' % NUM_ERRORS
    print

