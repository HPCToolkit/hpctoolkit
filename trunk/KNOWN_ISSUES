HPCToolkit's new call path profiler (hpcrun) is currently in a pre-release state.
While researchers at Rice University use it regularly for analysis of program
performance, there are several known issues that might cause problems for 
others when using it on large-scale parallel systems. The scale of the 
parallelism makes it increasingly likely that one of several known bugs
(that are the focus of ongoing development efforts) may cause problems.

Known bugs:

- When dynamic loading is used extensively, it is possible that multiple load 
  modules will map to the same place in a program's address space over the course of
  a program's execution. Additional support in HPCToolkit is needed to correctly
  distinguish when the same addresses may map to different load modules at different
  times during an execution. Presently, all samples that involve addresses that
  map to more than one load module are resolved by mapping them to the LAST load
  module that was visible at a particular address range. While we have observed
  that this problem occurs in practice with OpenMPI programs (the OpenMPI 
  implementation makes extensive use of dynamic libraries), typically this problem
  affects the accuracy of attributing only a handful of samples. If this problem
  occurs during execution, hpcrun writes a message to stderr indicating that the
  problem has occurred, and then records more detailed information to a log that
  indicates how many samples whose attribution it might effect.

- When hpcrun is invoked with debugging options turned on, it may print log messages 
  not only when processing samples, but also when threads are created or dynamic 
  loading of shared libraries occurs. Presently hpcrun's messaging subsystem 
  acquires a lock before writing to stderr or a log file to avoid unwanted 
  interleaving of output from different threads. It is possible (though it has never
  been observed) that a sample event may occur while an output lock is held. If
  the thread holding a messaging subsystem lock is hit with a sample event while 
  holding the lock, this can cause deadlock. This situation has never been encountered
  in practice, but it is possible. Presently, the messaging system is being overhauled
  and the interaction between synchronous and asynchronous entries into hpcrun's
  run-time library is being overhauled to avoid the potential for such race conditions.
