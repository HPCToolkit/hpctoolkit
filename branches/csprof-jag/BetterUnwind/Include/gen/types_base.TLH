/*BEGIN_LEGAL 
Intel Open Source License 

Copyright (c) 2002-2005 Intel Corporation 
All rights reserved. 
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.  Redistributions
in binary form must reproduce the above copyright notice, this list of
conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.  Neither the name of
the Intel Corporation nor the names of its contributors may be used to
endorse or promote products derived from this software without
specific prior written permission.
 
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR
ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
END_LEGAL */
/*
**
** @ORIGINAL_AUTHOR: Robert Muth
*/

/*! @file
  this headerfile contains defines the (additional) types needed by @ref LEVEL_BASE
 */

/*
** This file is also included by c files, so do not introduce any C++ stuff in here.
** For example, do not use C++ style comments
*/

#ifndef TYPES_BASE_H
#define TYPES_BASE_H

#define B_VERBOSE 1
#define B_BRIEF 0  

typedef VOID (*AFUNPTR)();
typedef VOID *(*THREAD_STARTROUTINE)(void *);
typedef VOID (*DESTRUCTFUN)(void*);

static inline USIZE USIZE_INVALID() {return ~(0L);}

#ifdef __GNUC__
#define STRTOUINT64 strtoull
#define STRTOINT64  strtoll
#else
#define STRTOUINT64 strtoul
#define STRTOINT64  strtol
#endif

#define STRTOFLT64  strtod

/*
** this hack allows for better utilization of the base ins stripe.
*/

typedef UINT16 OPCODE;

static inline  OPCODE OPCODE_INVALID() {return  0;}
static inline BOOL OPCODE_valid(OPCODE opc){ return opc != 0;}

#if defined(TARGET_LINUX) || defined(TARGET_MAC)
#define KNOB_ONLY_ON_UNIX "1"
#else
#define KNOB_ONLY_ON_UNIX "0"
#endif

#if defined(TARGET_LINUX)
#define KNOB_ONLY_ON_LINUX "1"
#else
#define KNOB_ONLY_ON_LINUX "0"
#endif

#if defined(TARGET_MAC)
#define KNOB_ONLY_ON_MAC "1"
#else
#define KNOB_ONLY_ON_MAC "0"
#endif

#if defined(TARGET_IA32E)
#define KNOB_ONLY_ON_IA32E "1"
#else
#define KNOB_ONLY_ON_IA32E "0"
#endif

#if defined(TARGET_IA32) || defined(TARGET_IA32E)
#define KNOB_ONLY_ON_IA32_IA32E "1"
#else
#define KNOB_ONLY_ON_IA32_IA32E "0"
#endif

#if defined(TARGET_IA32E) || defined(TARGET_IPF)
#define KNOB_ONLY_ON_IA32E_IPF "1"
#else
#define KNOB_ONLY_ON_IA32E_IPF "0"
#endif

#if defined(TARGET_IPF)
#define KNOB_ONLY_ON_IPF "1"
#define KNOB_ONLY_OFF_IPF "0"
#else
#define KNOB_ONLY_ON_IPF "0"
#define KNOB_ONLY_OFF_IPF "1"
#endif

#if defined(TARGET_IPF) || defined(TARGET_WINDOWS)
#define KNOB_ONLY_ON_IPF_WIN "1"
#else
#define KNOB_ONLY_ON_IPF_WIN "0"
#endif

#if (defined(TARGET_IA32) || defined(TARGET_IA32E)) && defined(TARGET_LINUX)
#define KNOB_ONLY_ON_IA32_IA32E_LINUX "1"
#else
#define KNOB_ONLY_ON_IA32_IA32E_LINUX "0"
#endif

#define HEX(val) 0x##val

class STAT;
class STAT_NORM;

/*! @ingroup PTRACE
  x
*/

#if defined(TARGET_MAC)

// For Mach-O
typedef struct 
{
    // Name of the dynamic loader
    const CHAR *_loaderFname;
    
    VOID *_pinclientint;
    CHAR *_charmversion;

    // preferred virtual address of the first segment mapped (not including the Pagezero segment)
    ADDRINT _preferredStartAddr;

    // This is the location that the miniloader will store the actualLoadAddr
    ADDRINT * _actualStartAddrLoc;
    
    // actual virtual address of the first segment mapped
    ADDRINT _actualStartAddr;
    
    // preferred virtual address of the very first instruction executed
    ADDRINT _preferredEntryAddr;

    // preferred address of the location where the header of this image is mapped to
    ADDRINT _preferredMhAddr;
    
    // This is the location that the miniloader will store the load offset
    ADDRINT * _loadOffsetLoc;

    // Load offset will be copied from LoadOffsetLoc to here
    // We need to copy because miniloader may not run in same address space
    ADDRINT _loadOffset;

} ImageLoaderInfo;

#else

// For ElF
typedef struct 
{
    ADDRINT _brk;
    ADDRINT _phdr;
    ADDRINT _entry;
    UINT32 _phnum;
    const CHAR *_loaderFname;
    VOID *_pinclientint;
    CHAR *_charmversion;

    // This is the location that the miniloader will store the load offset
    ADDRINT * _loadOffsetLoc;

    // Load offset will be copied from LoadOffsetLoc to here
    // We need to copy because miniloader may not run in same address space
    ADDRINT _loadOffset;

} ImageLoaderInfo;
#endif

#define SYSCALL syscall

#endif
