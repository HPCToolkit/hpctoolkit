#!/bin/sh
# Testing: set -x: line by line (set -n: syntax)
# set -x

## * BeginRiceCopyright *****************************************************
##
## $HeadURL$
## $Id$
##
## -----------------------------------
## Part of HPCToolkit (hpctoolkit.org)
## -----------------------------------
## 
## Copyright ((c)) 2002-2009, Rice University 
## All rights reserved.
## 
## Redistribution and use in source and binary forms, with or without
## modification, are permitted provided that the following conditions are
## met:
## 
## * Redistributions of source code must retain the above copyright
##   notice, this list of conditions and the following disclaimer.
## 
## * Redistributions in binary form must reproduce the above copyright
##   notice, this list of conditions and the following disclaimer in the
##   documentation and/or other materials provided with the distribution.
## 
## * Neither the name of Rice University (RICE) nor the names of its
##   contributors may be used to endorse or promote products derived from
##   this software without specific prior written permission.
## 
## This software is provided by RICE and contributors "as is" and any
## express or implied warranties, including, but not limited to, the
## implied warranties of merchantability and fitness for a particular
## purpose are disclaimed. In no event shall RICE or contributors be
## liable for any direct, indirect, incidental, special, exemplary, or
## consequential damages (including, but not limited to, procurement of
## substitute goods or services; loss of use, data, or profits; or
## business interruption) however caused and on any theory of liability,
## whether in contract, strict liability, or tort (including negligence
## or otherwise) arising in any way out of the use of this software, even
## if advised of the possibility of such damage. 
## 
## ******************************************************* EndRiceCopyright *

## **************************************************************************
##
## File: 
##   hpcrun: Launch the call stack profiler by setting up a preloaded
##   library that will intercept an application's execution and start
##   the profiler.  This script processes arguments and passes them
##   to the profiling library through environment variables.
##
## Author:
##   Written by Nathan Tallent, Rice University.
##    
## **************************************************************************

# ***************************************************************************

# If this script can't find its own install prefix, or if the script
# is moved elsewhere, then set HPCTOOLKIT here.
# HPCTOOLKIT=/path/to/install/prefix

# Relative paths are relative to HPCTOOLKIT.
hpcfnbounds_dir='libexec/hpctoolkit'
hpcrun_dir='lib/hpctoolkit'
libmonitor_dir='@LIBMONITOR_RUN_DIR@'
papi_libdir='@OPT_PAPI_LIBPATH@'

# umask -S g=rwx,o=rwx # temporary check
# umask -S -p # see change

ulimit_works='' # default to NO on jacquard

# One can set personal defaults here, instead of changing source code.
# These values will be overriden by commandline options.
opt_out_path=""
opt_lush_agents="";
opt_period=""
opt_memsize=""
opt_event=""
opt_verbosity=""
opt_debug=""
opt_debug_wait=""
opt_papi=""
opt_ev_list=''
opt_trace=""
opt_quiet=''

# ***************************************************************************

cmd_to_profile=""

cmd="$0"

hpc_path_to_root=..
@export_hpctoolkit@

# Relative paths are relative to HPCTOOLKIT.
case "$hpcfnbounds_dir" in
  /* ) ;;
  * ) hpcfnbounds_dir="${HPCTOOLKIT}/${hpcfnbounds_dir}" ;;
esac
case "$hpcrun_dir" in
  /* ) ;;
  * ) hpcrun_dir="${HPCTOOLKIT}/${hpcrun_dir}" ;;
esac
case "$libmonitor_dir" in
  /* ) ;;
  * ) libmonitor_dir="${HPCTOOLKIT}/${libmonitor_dir}" ;;
esac
case "$papi_libdir" in
  /* ) ;;
  * ) papi_libdir="${HPCTOOLKIT}/${papi_libdir}" ;;
esac


# ***************************************************************************
#
# ***************************************************************************

hpc_usage()
{
  cat <<EOF
Usage:
  hpcrun [profiling-options] <command> [command-arguments]
  hpcrun [info-options]

hpcrun profiles the execution of an arbitrary command <command> using
statistical sampling (rather than instrumentation).  It collects
per-thread call path profiles that represent the full calling context of
sample points.  Sample points may be generated from multiple simultaneous
sampling sources.  hpcrun profiles complex applications that use forks,
execs, threads, and dynamic linking/unlinking; it may be used in conjuction
with parallel process launchers such as MPICH's mpiexec and SLURM's srun.

To profile a statically linked executable, make sure to link with hpclink.

To configure hpcrun's sampling sources, specify events and periods using
the -e/--event option.  For an event 'e' and period 'p', after every 'p'
instances of 'e', a sample is generated that causes hpcrun to inspect the
and record information about the monitored <command>.

When <command> terminates, a profile measurement databse will be written to
the directory:
  hpctoolkit-<command>-measurements[-<jobid>]
where <jobid> is a PBS or Sun Grid Engine job identifier.

hpcrun enables a user to abort a process and write the partial profiling
data to disk by sending the Interrupt signal (INT or Ctrl-C).  This can be
extremely useful on long-running or misbehaving applications.

Options: Informational
  -l, -L --list-events List available events. (N.B.: some may not be
                       profilable)
  -V, --version        Print version information.
  -h, --help           Print help.

Options: Profiling (Defaults shown in curly brackets {})
  -e <event>[@<period>], --event <event>[@<period>]
                       An event to profile and its corresponding sample
                       period. <event> may be either a PAPI, native
                       processor event or WALLCLOCK (microseconds).  May pass
                       multiple times as implementations permit.
                       {WALLCLOCK@5000}.

                       N.B.: WALLCLOCK and hardware events cannot be mixed.
  -o <outpath>, --output <outpath>
                       Directory for output data.
                       {hpctoolkit-<command>-measurements[-<jobid>]}

                       Bug: Without a <jobid> or an output option, multiple
                       profiles of the same <command> will be placed in the
                       same output directory.

NOTES:
* hpcrun uses preloaded shared libraries to initiate profiling.  For this
  reason, it cannot be used to profile setuid programs.
* hpcrun may not be able to profile programs that themselves use preloading.

EOF
}


#  -t 
#
#      Record a call path trace in addition to call path profile. Each trace
#      record is 12 bytes in length (4 bytes to hold the identify of a call path, and
#      8 bytes to hold a time stamp). [ 1 Dec 2008  - Recording and visualizing 
#      call path traces is an experimental capability. ] 


hpc_version()
{
  cat <<EOF
hpcrun: A member of HPCToolkit, version @PACKAGE_VERSION@
EOF
}


hpc_erroneous_option()
{
  cat <<EOF
hpcrun: Unknown option switch: $@
Type 'hpcrun --help' for more information.
EOF
}


# args: ($1, $2): (string_to_check, string_for_error_msg[optional])
hpc_error_on_nil()
{
  if [ -z "$1" ]; then
    if [ -n "$2" ]; then printf "$2"; fi
    hpc_usage
    exit 1
  fi
}


# args: ($1, $2): (option, option_value)
hpc_opt_check()
{
  # 'option_value' should be non-nil
  hpc_error_on_nil "$2" "** no value for option $1\n"
    
  # 'option_value' should not start with '-'
  if ( echo "$2" | grep '^-.*' >/dev/null 2>&1 ); then
    printf "** invalid value for option $1: $2\n"
    hpc_usage
    exit 1
  fi
}


# args: ($1..$n): all arguments given to this script
hpc_getoptions()
{
  # We can't easily use 'getopt' or 'getopts' because we have to
  # protect options given to the command to profile.

  if [ -z "$1" ]; then
    hpc_usage
    exit 0
  fi

  # parse argument list
  while [ $# -ge 1 ]; do
    case $1 in
      # special options
      -h | --help)
        hpc_usage; exit 0;
        ;;

      -V | --version)
        hpc_version; exit 0;
        ;;

      -md)  opt_monitor_debug=1 ;;
      -dd)  shift; 
            dd_list="$L2$1"
	    L2="$dd_list "
            ;;
      -d)  opt_debug_wait=1;
            ;;

       # general options
      -a) 
        shift; opt_lush_agents="$1";
        hpc_opt_check "-a" "${opt_lush_agents}";
        ;;

      -e | --event) 
        shift; 
	# Please FIXME: dynamically scoped LLL and LL variables???
        # BUG!: replace : separator with @ to retain support for old syntax
	#LLL=`echo $1 | tr ':' '@'`
	LLL="$1"
        opt_ev_list="$LL$LLL";
	LL="$opt_ev_list "
        ;;

      -L | -l | --list-events)
	opt_ev_list=LIST
	LL="$opt_ev_list "
	add_cmd_if_empty=yes
        ;;

      -lm | --low-memsize )
	shift
	export HPCRUN_LOW_MEMSIZE="$1"
	;;

      -ms | --memsize )
	shift
	export HPCRUN_MEMSIZE="$1"
	;;

      -o | --output)
        shift; opt_out_path="$1"; 
        hpc_opt_check "-o" "${opt_out_path}";
        ;;

      -t) 
        opt_trace=1
        ;;

      -q)
        opt_quiet=1
	;;
      -*)
        hpc_erroneous_option $1;
        exit 1;
        ;;

      *) break ;;
    esac
    shift
  done

  # FIXME: this is fundamentally broken if args contain spaces.
  cmd_to_profile="$*"
  if test -z "$cmd_to_profile" && test "x$add_cmd_if_empty" = xyes ; then
    cmd_to_profile=/bin/ls
  fi
  hpc_error_on_nil "${cmd_to_profile}" "** no command to profile\n";
}


# get the executable from the list of (remaining) args
# Look for the executable on PATH and return full path if there.
# The file tests don't look for programs on PATH.

hpc_getexec()
{
  _EXEC="$1"

  case "$_EXEC" in
    */* )
      ;;
    * )
      OLDIFS="$IFS"
      IFS=:
      for dir in $PATH ; do
	if test -x "$dir/$_EXEC" ; then
	  _EXEC="$dir/$_EXEC"
	  break
	fi
      done
      IFS="$OLDIFS"
      ;;
  esac
}


hpc_prepareenv()
{
  # --------------------------------------------------------
  # export profiler options
  # --------------------------------------------------------

  export CSPROF_NM_COMMAND="${hpcfnbounds_dir}/hpcfnbounds"

  if [ -n "${opt_lush_agents}" ]; then
    CSPROF_OPT_LUSH_AGENTS="${opt_lush_agents}"
    export CSPROF_OPT_LUSH_AGENTS
  fi
  if [ -n "${opt_out_path}" ]; then
    CSPROF_OPT_OUT_PATH="${opt_out_path}"
    export CSPROF_OPT_OUT_PATH
  fi
  if [ -n "${opt_ev_list}" ]; then
    if [ "${opt_ev_list}" = "RETCNT" ]; then
      HPCRUN_EVENT_LIST="WALLCLOCK@5000 RETCNT"
    else
      HPCRUN_EVENT_LIST="${opt_ev_list}"
    fi  
  else
    HPCRUN_EVENT_LIST="WALLCLOCK@5000"
  fi
  export HPCRUN_EVENT_LIST
  if [ -n "${opt_debug}" ]; then
    CSPROF_OPT_DEBUG="${opt_debug}"
    export CSPROF_OPT_DEBUG
  fi
  if [ -n "${opt_debug_wait}" ]; then
    export CSPROF_WAIT=1
  fi
  if [ -n "$dd_list" ]; then
    export HPCRUN_DEBUG_FLAGS=$dd_list
  fi
  if [ -n "$opt_monitor_debug" ]; then
    export MONITOR_DEBUG=1
  fi
  if [ -n "${opt_trace}" ]; then
    export CSPROF_OPT_TRACE=1
  fi
  if [ -n "${opt_quiet}" ]; then
    export HPCRUN_QUIET=1
  fi

  # --------------------------------------------------------
  # PATH
  # --------------------------------------------------------
  # Make sure that `.' is in the PATH so that we can find the command
  # to profile if in the current directory. [We can get around this,
  # but for now it is the quickest thing.] 
  export PATH=".:${PATH}" 

  # --------------------------------------------------------
  # LD_PRELOAD (N.B.: whitespace-separated)
  # --------------------------------------------------------
  my_preload="${hpcrun_dir}/libhpcrun.so ${libmonitor_dir}/libmonitor.so"

  if [ -z "${LD_PRELOAD}" ]; then
    LD_PRELOAD="${my_preload}"
  else
    LD_PRELOAD="${my_preload} ${LD_PRELOAD}"
  fi

  unset my_preload
  export LD_PRELOAD

  # --------------------------------------------------------
  # LD_LIBRARY_PATH
  # --------------------------------------------------------
  if [ -z "${LD_LIBRARY_PATH}" ]; then
    LD_LIBRARY_PATH="${papi_libdir}"
  else
    LD_LIBRARY_PATH="${papi_libdir}:${LD_LIBRARY_PATH}"
  fi

  export LD_LIBRARY_PATH

  # --------------------------------------------------------
  # 
  # --------------------------------------------------------

  if [ -n "${opt_debug}" ]; then
    echo "LD_PRELOAD:         \"${LD_PRELOAD}\""
    echo "HPCRUN_DEBUG_FLAGS: \"${HPCRUN_DEBUG_FLAGS}\""
    echo "HPCRUN_EVENT_LIST:  \"${HPCRUN_EVENT_LIST}\""
  fi
}


# ***************************************************************************
# Main
# ***************************************************************************

# $n: argument n, with $0 being the command name
# $*: all arguments from $1 to $n

hpc_getoptions "$@"

hpc_getexec $cmd_to_profile

#
# Sanity checks before launching the application.
#
# In the dynamic case, verify that the application and libhpcrun are
# either both 32-bit or both 64-bit.  Give a pass to scripts and
# statically-linked binaries (which we don't really support via
# hpcrun).
#
if test -x "$_EXEC" ; then
  file_out=`file -L "$_EXEC"`
  echo "$file_out" | grep -E -i -e 'elf.*dynamic' >/dev/null 2>&1
  if test $? -eq 0 ; then
    appl_bit=`expr "$file_out" : '.*ELF.*\([0-9][0-9].bit\)'`
    file_out=`file -L "${hpcrun_dir}/libhpcrun.so"`
    hpcrun_bit=`expr "$file_out" : '.*ELF.*\([0-9][0-9].bit\)'`
    if test "$appl_bit" != "$hpcrun_bit" ; then
      echo "cannot run application $_EXEC" 1>&2
      echo "application is $appl_bit but hpctoolkit is $hpcrun_bit" 1>&2
      exit 1
    fi
  fi
fi

# Look for _mp_init in the binary and set -dd OMP_SKIP_MSB if there.
# _EXEC needs to be full path for nm to find it.

nm "$_EXEC" 2>/dev/null | grep -e ' _mp_init' >/dev/null 2>&1
if test $? -eq 0 ; then
  dd_list="OMP_SKIP_MSB $dd_list"
fi

hpc_prepareenv

if [ ${ulimit_works}x != x ]; then
   ulimit -c unlimited
fi

exec ${cmd_to_profile}
