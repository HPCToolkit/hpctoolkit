.\" $Id: monitor.3,v 1.10 2007/02/15 18:10:51 mucci Exp $
.TH monitor 3 2005-1-24
.SH NAME
monitor \- user callbacks for library, process and thread initialization/creation/destruction
.SH SYNOPSIS
.nf
.B #include <monitor.h>
.sp
Callbacks from libmonitor.so to the user's shared library:
.BI "void monitor_init_library(void);"
.BI "void monitor_fini_library(void);"
.BI "void monitor_init_process(char *" process ", int " argc ", char ** " argv ", unsigned " tid );
.BI "void monitor_fini_process();"
.BI "void monitor_init_thread_support();"
.BI "void *monitor_init_thread(unsigned "tid );
.BI "void monitor_fini_thread(void *"init_thread_data );
.BI "void monitor_dlopen(const char *"library );
.BR
.BR
Functions/variables exported by libmonitor.so:
.BI "void monitor_real_dlopen(const char *" filename ", int " flags );
.BI "int monitor_real_execve(const char *" filename ", char *" const argv[], char *const envp[] );
.BI "void monitor_real_exit(int);"
.BI "pid_t monitor_real_fork(void);"
.BI "long monitor_gettid();"
.BI "int monitor_force_fini_process();"
.BI "extern int monitor_opt_debug;"
.BI "extern int monitor_opt_error;"
.if

.SH DESCRIPTION

The \fBmonitor\fP library is designed to make the implementation of
performance monitoring tools simple and easy. The functions listed
above that are marked as optional are meant to be defined in a user
provided shared library. Extra care is taken to appropriately handle important
events such as all forms of \fBfork()\fP, \fBexec()\fP as well as
variants of \fBexit()\fP, \fBabort()\fP, and \fBassert()\fP. Also, 
signal handlers for SIGABRT and SIGABRT are installed unless the user
installs his own handlers inside \fBmonitor_init_process()\fP or 
\fBmonitor_init_library()\fP. Of course, the actual application 
could override these.
.PP
The library is intended to be used with LD_PRELOAD or the equivalent
on your platform. This means that monitor \fBDOES NOT WORK WITH 
STATIC BINARIES\fP. The mechanism is to define LD_PRELOAD to point to
the user's library FIRST and then libmonitor.so. Then any process that
runs (and associated threads, forks, and sub-shells) will execute any of
these call backs that are defined. See the man page on \fBld.so\fP or the example
code in this distribution for more information how to use LD_PRELOAD.
.PP
On platforms that support weak symbols (like GNU/Linux), the above 
functions are marked as such. This means
that if they are not defined by the user, dummy stubs are used and thus
no symbols are reported as undefined at run-time. Thus,
a very simple performance tool could simply just define one callback
(like \fBmonitor_init_process()\fP) and not worry about \fBld.so\fP
reporting undefined symbols and your tool crashing.
.PP
\fBmonitor_init_library()\fP is called after \fBmonitor\fP initializes
itself but BEFORE anything else does (like the C library). This means
that the user should be careful when installing code for this callback.
Since this callback executes so early in the load process, various 
important functions may not work properly. It is highly
recommended that the only thing that be done in this callback is to either
dynamically load new libraries with \fBdlopen()\fP or load symbols of
the current executable with \fBdlsym()\fP to be further with calls in
the user's tool. Please note that \fBmonitor_init_library()\fP is not 
called when the target applications forks. It only runs when 
the run-time linker loads libmonitor.so.
.PP
\fBmonitor_fini_library()\fP is there for completeness sake and it is
called when the shared library is unloaded from the address space,
upon a SIGINT, SIGABRT, \fBabort()\fP, \fBassert()\fP or bypasses
normal termination by calling \fB_exit()\fP. The last five behaviors
must be explicitly enabled with \fBmonitor_opt_error\fP. The same
warning applies, there is no guarantee that any part of the system or
C library is functioning at this point. Really, don't do anything here
if you don't have to, use \fBmonitor_fini_process()\fP
instead. \fBmonitor_fini_library()\fP is also called before an
\fBexec()\fP as part of the parent process' cleanup.
.PP
\fBmonitor_init_process()\fP is called just prior to entry of the main
program. It is here that the user's tool should perform the bulk of
its initialization. It is also called after \fBfork()\fP inside the child process.
Be careful with your handling of argc and argv, as any modifications 
will be passed along to \fBmain()\fP.
.PP
\fBmonitor_fini_process()\fP is called after main returns and should be
used instead of \fBatexit()\fP, which doesn't always work if the process
doesn't finish cleanly. This routine is also called upon SIGINT,
SIGABRT, \fBassert()\fP, \fBabort()\fP if the appropriate optioons are set.
It is always called before \fBexec()\fP routines that look like they could 
succeed. The library does \fBaccess()\fP checks on the arguments to exec to defer
calling this routine as long as possible.. As this routine runs before any libraries are unmapped, all
routines in the C libraries and other dynamically loaded libraries are
safe to use. If MONITOR_NONZERO_EXIT is set, this hook will also 
be called when \fBexit()\fP is called with a non-zero argument.
.PP
\fBmonitor_init_thread_support()\fP is called ONCE just before
\fBpthread_create()\fP runs. It simply allows the user's code to prepare
for multithreaded operation, i.e.to initiatize thread safe data
structures, mutexes etc.  \fBmonitor_init_thread()\fP is called from
WITHIN the new thread's context or ON the new thread's LWP, just
before the entry point specified to \fBpthread_create()\fP. This is very
useful for doing accounting of metrics that need first person access
to a kernel contexts (like hardware performance
counters).
.PP
\fBmonitor_fini_thread()\fP is handled by calls to
\fBpthread_cleanup_push()\fP and \fBpthread_cleanup_pop()\fP. The calls 
\fBmonitor_init_thread()\fP and \fBmonitor_fini_thread()\fP are unique in
that the first can return some thread specific data which is then
passed to the second. This can be used to hold state without having to
manage thread specific data or make use of native thread local
storage constructs. This hook requires special attention when 
targeting the GCC 4/OpenMP implementation. This is because that 
implementation does not return from the function passed to 
\fBpthread_create()\fP and thus never calls the cleanup handler. 
For this case, we have implemented a workaround using 
\fBGOMP_parallel_start()\fP. The side effects here are
that \fBmonitor_fini_thread()\fP is called for all threads as specified
by \fBomp_get_max_threads()\fP. Please ensure robustness in your software 
by handling this case gracefully. Note that ill-behaved applications
that do not guarantee thread completion through \fBpthread_join()\fP,
\fBpthread_exit()\fP or by returning from the function passed to \fBpthread_create()\fP
do not currently receive the callbacks. A warning is issued to stderr should
monitor detect unfinished threads. If you have any ideas how to handle these
cases, please let us know. See the BUGS file in the distribution
for more information.
.PP
\fBmonitor_dlopen()\fP is called just \fBafter successful\fP execution of
\fBdlopen()\fP. It is called after so that the tool could inspect
the proc filesystem for information on the new library.
.PP
External variables/functions defined by the \fBmonitor\fP library:
.PP
\fBmonitor_force_fini_process()\fP forces the monitor library to call the 
process finish handler \fBmonitor_fini_process()\fP and update it's
internal state to reflect that fact. This may include forcing threads
to run their \fBmonitor_fini_thread()\fP callbacks. This is useful when 
using run-time systems that have an API call that cleans up the process before
the traditional \fBexit()\fP call, like MPI and \fBMPI_Finalize()\fP.
Monitor will guard against multiple invocations of the process
finish handlers, even if the process subsequently calls \fBexit()\fP. 
.PP
\fBmonitor_real_exit()\fP is a direct call to the system exit function,
bypassing any and all monitor functionality. Use this in your  
error handlers in your tools if you want to avoid callbacks. The same is
true for the rest of the \fBmonitor_real\fP functions. 
.PP
\fBmonitor_gettid()\fP returns the thread identifier of the
calling thread if threads have been enabled by the library. Note that
calling this before one receives a \fBmonitor_init_thread_support()\fP 
may result in unintentionally initializing the thread library. This can
happen if the code links with the \fBpthread\fP library but doesn't
actually use it. If the executable is not linked with the thread library
then \fBmonitor_gettid()\fP returns 0. 
.PP
\fBmonitor_opt_debug\fP simply enables debugging of the \fBmonitor\fP
library. By setting this variable to a non-zero value, debug messages
are logged to stderr. The messages do not follow any consistent
formatting rules. You can preempt the setting of this variable by setting
the environment variable MONITOR_DEBUG to be any string.
.PP
\fBmonitor_opt_error\fP controls whether or not the
\fBmonitor_fini_library()\fP and \fBmonitor_fini_process()\fP callback
routines are made upon abnormal program events. Values for this
variable may be AND'ed together. The default is that the above
routines are never called unless the program exits normally (with a
zero exit status). The valid flags for this
variable are \fBMONITOR_NONZERO_EXIT\fP, \fBMONITOR_SIGINT\fP and
\fBMONITOR_SIGABRT\fP. The latter can be used to catch executions of
\fBassert()\fP and \fBabort()\fP in the application code. You can
preempt the setting of this variable by setting the environment variable
MONITOR_OPTIONS to any combination of the above strings as well as
the string MONITOR_DEBUG.
.PP
Both of the above variables should be set inside the
\fBmonitor_init_library()\fP callback to have the desired effect.
.PP
Note that debugging messages are generated only if the library has
been compiled with DEBUG. Messages are sent to standard error in the form:
libmonitor debug: (processid,pthreadid).

.SH SEE ALSO
\fBld.so(8),
dlopen(3),
dlsym(3),
abort(3),
assert(3),
atexit(3),
exit(2),
exit(3),
fork(2),
execve(2),
access(2),
pthread_create(3),
pthread_cleanup_push(3),
pthread_cleanup_pop(3),
monitor-config(1),
\fP

.SH BUGS 
No known bugs other than the fact that this is only guaranteed to work on Linux/x86/x86_64/ia64. This code must be built with gcc. Additional bugs should be reported to the author via the OSPAT Development mailing lists Be sure to mention the word MONITOR somewhere in the subject line.

.SH AUTHOR
\fBmonitor\fP was written by Philip J. Mucci of the Innovative Computing Laboratory while on sabbatical at the Parallel Center for Computers at the Royal Institute of Technology in Stockholm, Sweden. This library contains a bit of code from HPCToolkit, written by Nathan Tallent and John Mellor-Crummey of Rice University. Please see http://www.cs.utk.edu/~mucci, http://icl.cs.utk.edu,  and http://www.pdc.kth.se for more information. 

.SH COPYRIGHT
This software is \fBCOMPLETELY OPEN SOURCE\fP. If you incorporate any portion of this software, I would appreciate an acknowledgement in the appropriate places. Should you find monitor useful, please considering making a contribution in the form of hardware, software or plain old cash.
