# make sure we execute perl
eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
& eval 'exec perl -S $0 $argv:q'
if 0;

# $Id$
## * BeginRiceCopyright *****************************************************
## 
## Copyright ((c)) 2002, Rice University 
## All rights reserved.
## 
## Redistribution and use in source and binary forms, with or without
## modification, are permitted provided that the following conditions are
## met:
## 
## * Redistributions of source code must retain the above copyright
##   notice, this list of conditions and the following disclaimer.
## 
## * Redistributions in binary form must reproduce the above copyright
##   notice, this list of conditions and the following disclaimer in the
##   documentation and/or other materials provided with the distribution.
## 
## * Neither the name of Rice University (RICE) nor the names of its
##   contributors may be used to endorse or promote products derived from
##   this software without specific prior written permission.
## 
## This software is provided by RICE and contributors "as is" and any
## express or implied warranties, including, but not limited to, the
## implied warranties of merchantability and fitness for a particular
## purpose are disclaimed. In no event shall RICE or contributors be
## liable for any direct, indirect, incidental, special, exemplary, or
## consequential damages (including, but not limited to, procurement of
## substitute goods or services; loss of use, data, or profits; or
## business interruption) however caused and on any theory of liability,
## whether in contract, strict liability, or tort (including negligence
## or otherwise) arising in any way out of the use of this software, even
## if advised of the possibility of such damage. 
## 
## ******************************************************* EndRiceCopyright *

###############################################################################
#
#  File:
#     makedtdstring
#
#  Description:
#     turn a DTD into a string
#
#  History:
#     15 Oct 1999 -- John Mellor-Crummey -- created 
#
###############################################################################

# set perl to flush the buffer after each print
use strict;
use warnings;

use FileHandle;
STDOUT->autoflush(1); 

use Getopt::Std;

###############################################################################

my $the_program = "makedtdstrings";
my $the_usage = 
"Usage: 
  ${the_program} <dtd-file>

Converts <dtd-file> into a header file and sends output to stdout.

  -h : print help
";

#[-o <header-file>]

###############################################################################
# argument parsing 
###############################################################################

my $options = 'h';

my %opts = ();
getopts($options, \%opts);

if (defined($opts{'h'})) {
    printUsageAndExit();
}

###############################################################################
# driver
###############################################################################

my $numArgs = scalar(@ARGV);

if ($numArgs != 1) {
    printErrorAndExit("Invalid number of arguments!\n")
}

my $inputfile = $ARGV[0];


#foreach $arg (@ARGV) {
#    push(@inputfiles, $arg); 
#};

#foreach $file (@inputfiles) {
#    outputstring($file);
#};

outputstring($inputfile);

###############################################################################

sub outputstring
{
    my ($file) = @_;
    unless (open(READ_FILE, "<$file")) { 
	print "unable to open input file ", $file, ".\n";
	return;
    };
    #$out = $file;
    #$out =~ s/\.dtd$//;
    #$out .= ".h";
    #unless (open(WRITE_FILE, ">$out")) { 
    #   print "unable to open output file ", $out, ".\n";
    #   return;
    #};
    
    my $prev = -1;
    print STDOUT "\"";
    while (<READ_FILE>) 
    {
	my $current = $_;
	my $len = length $current;
	my $line = substr $current, 0, $len - 1;
	printf STDOUT "%s\\n", $line;
    };
    printf STDOUT "\";\n";
    
    close(READ_FILE);
    #close(WRITE_FILE);
    #printf "result in file %s.\n",  $out; 
}


###############################################################################

# printUsageAndExit
sub printUsageAndExit 
{
  my ($command) = @_; # not used now
  print STDOUT ${the_usage};
  exit(-1);
}

# printErrorAndExit
sub printErrorAndExit 
{
  my ($msg) = @_;
  if (defined($msg)) {
    print STDOUT "${msg}";
  }
  print STDOUT "Try `${the_program} -h' for more information.\n";
  exit(-1);
}
