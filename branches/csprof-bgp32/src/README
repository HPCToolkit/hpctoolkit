$Id: README 493 2006-04-25 20:45:34Z froydnj $

=============================================================================
==
== README
==
== Location: 
==
=============================================================================

This is the README for csprof.

Contents:
  0. Overview
  1. Using
  2. A Few Details

=============================================================================

0. Overview
--------------------

This directory contains a prototype of the csprof call stack profiler.
We plan for it to eventually be packaged with our HPCToolkit.

csprof profiles an unmodified application binary using a preloaded
library that automatically initializes profiling.  Once the profiler
is initialized, control is passed back to the application.  When the
application exits, control returns to the csprof library, which calls
finalization routines and writes the profiling data to a binary file
for later processing.  csprof is based on libpfm 2.0+ (by Stephane
Eranian) and libunwind (by David Mosberger).

We have written the first draft of a tool to translate the data from the
profiler into an XML format that we plan to display with our HPCView tool.
Currently HPCView cannot display the data and we just read the XML.

The code will be under an open source license, most likely the BSD-like
license that we have been using for our HPCToolkit.

csprof will profile processes spawned by the profiled command and
generate separate output for each process. (We need to add an option
to turn this off.)

csprof cannot profile any programs that are restricted from using
LD_PRELOAD (for security reasons), such as setuid applications.

1. Using
--------------------

csprof requires the following:
  * Itanium machine with a 2.4.18+ kernel

  * libpfm 2.0+ (http://www.hpl.hp.com/research/linux/perfmon/)

  * libunwind-0.2-pre2 (ftp://ftp.hpl.hp.com/pub/linux-ia64)
    (libunwind can be a little difficult to install.  Version .9x has
     recently been released, but when I tried installing it I found
     that some of the tests failed; I can't track this down at the
     moment.)

Once these are installed csprof is ready to be built.  The
configurable make variables are in 'Makeinclude.config'.  If you
installed libpfm and libunwind in a standard location searched by the
runtime loader and compiler (e.g. /usr/local) you shouldn't ned to
change anything.  Otherwise the *PFM and *UNWIND variables should be
edited apprpriately.

To configure: 
  Edit 'Makeinclude.config' as necessary.
  Edit 'Sourcme-{sh, csh}' to correctly set CSPROF_HOME.  Source the file.

To build:
  make 

To test:
  cd test2
  make
  [type 'csprof' to see an overview of options]
  csprof test2

  Output will be sent to csprof.<hostid>-<pid>.csp. [We need to fix
  this to include the profiled program's name.]

To translate:
  xcsprof test2 <csprof_output_file>  > test2.cspxml
  
  We had hoped to have a good way of viewing the data in place by now...
  <sigh>.


2. A Few Details
--------------------

Here are some big-picture implementation details that some users may
find interesting.  Most of the text has been taken from comments
from within the code.

1. The library is automatically loaded using the runtime loader's
LD_PRELOAD enironiment variable.  Control automatically goes to the
library's _init function before it is passed to the program's "main"
routine. (This fact can be used to set up so-called interception
routines.)  Similarly, when the process ends, control automatically
comes back to the library's _fini function.

2. We use pfmon as the interface to the Itanium's hardware performance
counters.  To perform statistical profiles, we direct pfmon to issue a
signal every time a certain number of 'events' has occurred.  (An
event description can actually be quite complicated -- see the pfmon
documentation for more ojn this.)  We then register a signal handler
which uses libunwind to collect a sample of of the stack.

3. In PC-profiling, one can allocate memory for histograms of counters
that correspond to regions of code before profiling begins.  However,
for call stack profiling, it not possible to initially determine the
memory necessary for storing call stack samples.  Because of this,
csprof is faced with potentially needing to allocate memory from a
signal handler.  To avoid calling malloc, csprof uses its own
implementation of privately managed dynamic memory.  The memory is
implemented with large memory maps that use the system's swap space
for backing (in contrast to a file or some other shared device).  When
csprof needs to allocate space to store a call stack sample, typically
all that needs to be done is to move a pointer within a memory mapped
region.  When space in one pool of dynamic store becomes low, another
pool will be allocated.  Since creating new memory stores adds
profiling overhead, csprof allows a user to change the initial size of
the memory store.

4. We want the profiler to have as little as possible effect on the
monitored program as possible.  This includes not only execution time
overhead but cache pollution as well.  Thus, while collecting call
stack samples we try to exploit memory locality as much as possible.
Call stack samples are collected in the same array until a resize is
necessary.  Similarly, we have designed the data structure used to
store the call stack samples so as to minimize the amount of memory
that must be touched to insert a new sample.

[Specifically: Call stack samples are stored in a variable degree-tree
where each node may have zero or more children and each node contains
a single instruction pointer value.  Call stack samples are
represented implicitly by a path from some node x (where x may or may
not be a leaf node) to the tree root (with the root being the bottom
of the call stack).]

[We maintain two cached arrays: one contains a copy of the most recent
backtrace (with the first element being the *top* of the call stack);
the other contains corresponding node pointers into the tree (where
the last element will point to the tree root).  We try to resize these
arrays as little as possible.]

[When inserting a call stack sample, we compare the current and cached
backtrace starting from what would be the bottom of the call stack (or
the root node of the sample tree).  When we find a mismatch, we use
the cached tree node array to find the corresponding node in the tree
so that further comparisons and updates can be made in the tree as
necesary.]

CSPROF_BACKTRACE_CACHE_INIT_SZ
CSPROF_MEM_SZ_INIT


-----------------------------------------------------------------------------

tar: 

clean test2
tar cvf csprof.tar csprof
