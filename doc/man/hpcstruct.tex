%% $Id$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[english]{article}
\usepackage[latin1]{inputenc}
\usepackage{babel}
\usepackage{verbatim}

%% do we have the `hyperref package?
\IfFileExists{hyperref.sty}{
   \usepackage[bookmarksopen,bookmarksnumbered]{hyperref}
}{}

%% do we have the `fancyhdr' or `fancyheadings' package?
\IfFileExists{fancyhdr.sty}{
\usepackage[fancyhdr]{latex2man}
}{
\IfFileExists{fancyheadings.sty}{
\usepackage[fancy]{latex2man}
}{
\usepackage[nofancy]{latex2man}
\message{no fancyhdr or fancyheadings package present, discard it}
}}

%% do we have the `rcsinfo' package?
\IfFileExists{rcsinfo.sty}{
\usepackage[nofancy]{rcsinfo}
\rcsInfo $Id$
\setDate{\rcsInfoLongDate}
}{
\setDate{2018/07/05}
\message{package rcsinfo not present, discard it}
}

\setVersionWord{Version:}  %%% that's the default, no need to set it.
\setVersion{=PACKAGE_VERSION=}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{Name}{1}{hpcstruct}{The HPCToolkit Performance Tools}{The HPCToolkit Performance Tools}{hpcstruct:\\ Recovery of Static Program Structure}

\Prog{hpcstruct} recovers the static program structure of \emph{fully optimized} object code for use with an \textbf{HPCToolkit} correlation tool.
In particular, \Prog{hpcstruct}, recovers source code procedures and loop nests, detects inlining, and associates procedures and loops with object code addresses.
See \HTMLhref{hpctoolkit.html}{\Cmd{hpctoolkit}{1}} for an overview of \textbf{HPCToolkit}.

\end{Name}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Synopsis}

\Prog{hpcstruct} \oOpt{options} \Arg{binary}
\Prog{hpcstruct} \oOpt{options} \Arg{measurement directory of GPU-accelerated application}

Typical usage:\\ \\
\SP\SP\SP\Prog{hpcstruct} \Arg{binary} \\ \\
which creates \File{basename(}\Arg{binary}\File{).hpcstruct}.
\SP\SP\SP\Prog{hpcstruct} \Arg{measurement directory of GPU-accelerated application} \\ \\
which analyzes all GPU binaries within the measurement directory and records 
program structure files within the directory for use by \Prof{hpcprof}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Description}

Given an application binary, a shared library, or a GPU binary, \Prog{hpcstruct}
recovers the program structure of its object code by analyzing available information
about loop nests, inlined functions, and the mapping between machine instructions and 
source lines.  Program structure is a
mapping of a program's object code to its static source-level structure.

When analyzing a CPU binary, by default, 
\Prog{hpcstruct} writes its results to the file 'basename(<binary>).hpcstruct'.
To improve attribution of performance measurements to program source code, one can
pass one or more program structure files (e.g., for an executable and/or 
one or more shared libraries) to HPCToolkit's analysis tool hpcprof
along with one or more HPCToolkit performance measurement directories.

During execution of a GPU-accelerated application on an NVIDIA GPU, HPCToolkit
records NVIDIA 'cubin' GPU binaries in the application's measurement directory.
To attribute performance to GPU functions in a GPU-accelerated application, one
should apply hpcstruct to the application's HPCToolkit measurement directory to
analyze all GPU binaries recorded within. When analyzing a measurement directory
that includes GPU binaries, any program structure files produced will be recorded
inside the measurement directory. When hpcprof is applied to a measurement
directory that contains program structure files for GPU binaries, these program
structure files will be used to help attribute any GPU performance measurements.

\Prog{hpcstruct} is designed primarily for highly optimized binaries created from
C, C++, Fortran, and CUDA source code. Because \Prog{hpcstruct}'s algorithms exploit a
binary's debugging information, for best results, binary should be compiled
with standard debugging information or, at a minimum, line map information.
Note: although a CPU or GPU binary may be optimized, it must also be
compiled with debug symbols for the results to be useful, normally using the -g
flag when compiling CPU binaries. 
For NVIDIA GPUs, one can use the -lineinfo flag to generate
line map information. (Using the -G compiler flag with NVIDIA's 
compilers to generate full debug information
inhibits optimization and is not recommended for performance analysis.)

For faster analysis of large binaries or many GPU binaries, we recommend using
the -j option to employ multithreading. As many as 32 cores can be used profitably
to analyze large CPU or GPU binaries in the measurements directory for a
GPU-accelerated application.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Arguments}

%% SKW 7/6/18:
%% 
%% The following arguments are implemented in hpcstruct's "Args.cpp" but are deprecated
%% and so not documented here, per JohnMC
%% 
%%    agent-c++
%%    agent-cilk
%%    loop-intvl
%%    loop-fwd-subst
%%    normalize
%%    use-binutils

\begin{Description}
\item[\Arg{binary}] File containing a binary executable or dynamically linked library.
Note that \Prog{hpcstruct} does not recover program structure for libraries that \Arg{binary} depends on.
To recover that structure, run hpcstruct on each dynamically linked library
or relink your program with static versions of the libraries.
\end{Description}

Default values for an option's optional arguments are shown in \{\}.

\subsection{Options: Informational}

\begin{Description}

\item[\Opt{-V}, \Opt{--version}]
Print version information.

\item[\Opt{-h}, \Opt{--help}]
Print help message.

\end{Description}

\subsection{Options: Parallel Usage}
\item[\OptArg{-j}{num}, \OptArg{--jobs}{num}]
Use <num> threads for all phases in hpcstruct. {1}

\item[\OptArg{--gpu-size}{n}]
Size (bytes) of a GPU binary that will cause hpcstruct
to use <num> threads to analyze a binary in parallel.
GPU binaries with fewer than <n> bytes will be analyzed
concurrently, <num> at a time.  {100000000}

\subsection{Options: Structure recovery}

\begin{Description}

% No longer exist.
%
% \item[\OptArg{--demangle-library}{libpath}]
% Use a function from the library at \emph{libpath} to demangle C++ names.
% By default the library function used is \Prog{__cxa_demangle}.
% A different function may be specified with the \Prog{--demangle-function} option.
% 
% \item[\OptArg{--demangle-function}{funcname}]
% Call the function named \emph{funcname} in the specified demangler library to demangle C++ names.
% This option may only be given if the \Prog{--demangle-library} option is also given.

\item[\OptArg{--gpucfg}{yes/no}]
Compute loop nesting structure for GPU machine code.  Currently,
this applies only to NVIDIA CUDA binaries (cubins). Loop nesting
structure is only useful with instruction-level measurements
collected using PC sampling. \{no\}

\item[\OptArg{-I}{path}, \OptArg{--include}{path}] 
Use \Arg{path} when resolving source file names. 
This option is useful when a compiler records the same filename in different ways within the symbolic information.
(Yes, this does happen.)
For a recursive search, append a '+' after the last slash, e.g., \texttt{/mypath/+}. 
This option may appear multiple times.

\item[\OptArg{-R}{'old-path=new-path'}, \OptArg{--replace-path}{'old-path=new-path'}]
Replace instances of \Arg{old-path} with \Arg{new-path} in all paths with \Arg{old-path} is a prefix
(e.g., a profile's load map and source code).
Use \verb+'\'+ to escape instances of '=' within specified paths.
This option may appear multiple times.
  
Use this when a profile or executable references files that have been relocated,
such as might occur with a file system change.

\end{Description}

\subsection{Options: Output}

\begin{Description}

\item[\OptArg{-o}{file}, \OptArg{--output}{file}]
Write results to \Arg{file}.  \{\Arg{basename(binary)}\File{.hpcstruct}\}

% \item[\Opt{--compact}]
% Generate compact output by eliminating extra white space.

\end{Description}

\subsection{Options for Developers:}

\begin{Description}
\item[\OptArg{--jobs-struct}{num}]
Use num threads for the program structure analysis phase of \Prog{hpcstruct}.

\item[\OptArg{--jobs-parse}{num}]
Use num threads for the parse phase of \Prog{hpcstruct}.

\item[\OptArg{--jobs-symtab}{num}]
Use num threads for the symbol table analysis phase of \Prog{hpcstruct}.

\item[\Opt{--show-gaps}]
Developer option to
write a text file describing all the "gaps" found by \Prog{hpcstruct},
i.e. address regions not identified as belonging to a code or data segment
by the ParseAPI parser used to analyze application executables.
The file is named \emph{outfile}\File{.gaps}, which by default is
\emph{appname}\File{.hpcstruct.gaps}.

\item[\Opt{--time}]
Display the time and space usage per phase in \Prog{hpcstruct}.

\end{Description}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}

%\begin{enumerate}
%\item 
Assume we have collected profiling information for the (optimized) binary \File{sweep3dsingle},
compiled with debugging information.
We wish to recover program structure in the file \File{sweep3dsingle.hpcstruct}
for use with \HTMLhref{hpcprof.html}{\Cmd{hpcprof}{1}}.
To do this, execute:

\begin{verbatim}
    hpcstruct sweep3dsingle
\end{verbatim}

By defult the output is placed in a file named \File{sweep3dsingle.hpcstruct}.
%\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notes}

\begin{enumerate}

\item For best results, an application binary should be compiled with debugging information.
To generate debugging information while also enabling optimizations,
use the appropriate variant of \verb+-g+ for the following compilers:
\begin{itemize}
\item GNU compilers: \verb+-g+
\item Intel compilers: \verb+-g -debug inline_debug_info+
\item IBM compilers: \verb+-g -fstandalone-debug -qfulldebug -qfullpath+
\item PGI compilers: \verb+-gopt+
\end{itemize}

\item While \Prog{hpcstruct} attempts to guard against inaccurate debugging information,
some compilers (notably PGI's) often generate invalid and inconsistent debugging information.
Garbage in; garbage out.

\item C++ mangling is compiler specific. On non-GNU platforms, \Prog{hpcstruct}
tries both platform's and GNU's demangler.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \section{Bugs}
%% 
%% \begin{enumerate}

%% \item xxxxxx

%% \end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{See Also}

\HTMLhref{hpctoolkit.html}{\Cmd{hpctoolkit}{1}}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Version}

Version: \Version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{License and Copyright}

\begin{description}
\item[Copyright] \copyright\ 2002-2020, Rice University.
\item[License] See \File{README.License}.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Authors}

\noindent
Rice University's HPCToolkit Research Group \\
Email: \Email{hpctoolkit-forum =at= rice.edu} \\
WWW: \URL{http://hpctoolkit.org}.

Thanks to Gabriel Marin and Jason Eckhardt.

\LatexManEnd

\end{document}

%% Local Variables:
%% eval: (add-hook 'write-file-hooks 'time-stamp)
%% time-stamp-start: "setDate{ "
%% time-stamp-format: "%:y/%02m/%02d"
%% time-stamp-end: "}\n"
%% time-stamp-line-limit: 50
%% End:

