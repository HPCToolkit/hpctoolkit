% $Id$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[english]{article}
\usepackage[latin1]{inputenc}
\usepackage{babel}
\usepackage{verbatim}

%% do we have the `hyperref package?
\IfFileExists{hyperref.sty}{
   \usepackage[bookmarksopen,bookmarksnumbered]{hyperref}
}{}

%% do we have the `fancyhdr' or `fancyheadings' package?
\IfFileExists{fancyhdr.sty}{
\usepackage[fancyhdr]{latex2man}
}{
\IfFileExists{fancyheadings.sty}{
\usepackage[fancy]{latex2man}
}{
\usepackage[nofancy]{latex2man}
\message{no fancyhdr or fancyheadings package present, discard it}
}}

%% do we have the `rcsinfo' package?
\IfFileExists{rcsinfo.sty}{
\usepackage[nofancy]{rcsinfo}
\rcsInfo $Id$
\setDate{\rcsInfoLongDate}
}{
\setDate{2021/09/15}
\message{package rcsinfo not present, discard it}
}

\setVersionWord{Version:}  %%% that's the default, no need to set it.
\setVersion{=PACKAGE_VERSION=}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{Name}{1}{hpcstruct}{The HPCToolkit Performance Tools}{The HPCToolkit Performance Tools}{hpcstruct:\\ Recovery of Static Program Structure}

\Prog{hpcstruct} - recovers the static program structure of CPU or GPU binaries, as cited in a recorded measurements directory, or
in a single CPU or GPU binary.
The static structure includes procedures, inlined functions, loops, and source lines

See \HTMLhref{hpctoolkit.html}{\Cmd{hpctoolkit}{1}} for an overview of \textbf{HPCToolkit}.

\end{Name}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Synopsis}

\Prog{hpcstruct} \oOpt{options} \Arg{measurement-directory}

\Prog{hpcstruct} \oOpt{options} \Arg{binary}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Description}

\Prog{hpcstruct} recovers the program structure for all CPU and GPU
binaries referenced by a directory containing HPCToolkit performance
measurements. If needed, one can apply \Prog{hpcstruct} to recover program
structure for an individual CPU or GPU binary.

During execution of a any application, HPCToolkit records the name of the application binary,
and the names of any shared-libraries used. During execution of a GPU-accelerated application,
HPCToolkit also records GPU binaries in the application's measurement directory.

Normally, \Prog{hpcstruct} is run against an application's HPCToolkit \Arg{measurement-directory} directing
it to analyze all CPU and GPU binaries recorded within.

When analyzing a \Arg{measurement-directory},  \Prog{hpcstruct} writes its results into a subdirectory of the directory.
It analyzes the application and all the shared libraries used during the run, as well as any
GPU binaries recorded in the directory.  It also puts links to all shared libraries in another subdirectory.
When \Prog{hpcprof} is applied to a measurement directory that contains program structure files,
those program structure files will be used to help attribute performance measurements.

When analyzing a CPU or GPU binary \Arg{b}, \Prog{hpcstruct} only writes its results to the file
'basename(\Arg{b}).hpcstruct', and does not link to the binary.

Program structure is a mapping from addresses of machine instructions
in a binary to source code contexts; this mapping is used to attribute
measured performance metrics back to source code. A strength of
\Prog{hpcstruct} is its ability to attribute metrics to inlined functions
and loops; such mappings are especially useful for understanding the
performance of programs generated using template-based programming
models.

\Prog{hpcstruct} is designed for analysis of optimized binaries created from
C, C++, Fortran, CUDA, HIP, and DPC++ source code. Because \Prog{hpcstruct}'s
algorithms exploit the line map and debug information recorded in an
application binary during compilation, for best results, we recommend that
binaries be compiled with standard debug information or at a minimum,
line map information. Typically, this is accomplished by passing a '-g'
option to each compiler along with any optimization flags. See the
HPCToolkit manual for more information.

To accelerate analysis of a measurement directory, which contains
references to an application as well as any shared libraries
and/or GPU binaries it uses, \Prog{hpcstruct} employs multiple threads by
default. Multiple small binaries are analyzed concurrently, using one
thread per binary. By default, this analysis will use half of the
threads in the CPU set for the process. Binaries larger than a certain
threshold (see the --psize option and its default) are analyzed using
multiple threads. By default, large binaries will be analyzed using
min(half of the threads in the CPU set for the process, 16) threads.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Arguments}

\begin{Description}
\item[\Arg{measurement directory}]
A measurement directory of an application, either GPU-accelerated or not.
Applying \Prog{hpcstruct} to a measurement directory analyzes the application, all shared libraries referenced
during the data-collection run, as well as any GPU binaries recorded 
in the measurement directory during execution. 

\item[\Arg{binary}] File containing an executable, a dynamically-linked shared library, or a GPU binary
recorded by HPCToolkit as a program executes.
Note that \Prog{hpcstruct} does not recover program structure for libraries that \Arg{binary} depends on.
To recover that structure, run \Prog{hpcstruct} on each dynamically-linked shared library
or relink your program with static versions of the libraries.  Invoking \Prog{hpcstruct} on a binary
is normally not used.

\end{Description}

Default values for an option's optional arguments are shown in \{\}.

\subsection{Options: Informational}

\begin{Description}

\item[\Opt{-V}, \Opt{--version}]
Print version information.

\item[\Opt{-h}, \Opt{--help}]
Print help message.

\item[\OptArg{-v}{num}, \OptArg{--verbose}{num}]
Generate progress messages to stderr, at verbosity level \Arg{num}. {1}

\end{Description}

\subsection{Options: Override parallel defaults}
\item[\OptArg{-j}{num}, \OptArg{--jobs}{num}]
Use \Arg{num} threads in \Prog{hpcstruct}.

\item[\OptArg{--psize}{n}]
Size, in bytes, of a binary that will cause \Prog{hpcstruct}
to analyze a binary in parallel.
Binaries with fewer than \Arg{n} bytes will be analyzed
concurrently. {100000000}

\subsection{Options: override structure recovery defaults}

\begin{Description}

\item[\OptArg{--cpu}{"yes"/"no"}]
Analyze CPU binaries references in a measurements directory. {"yes"}

\item[\OptArg{--gpu}{"yes"/"no"}]
Analyze GPU binaries references in a measurements directory. {"yes"}

\item[\OptArg{--gpucfg}{"yes"/"no"}]
Compute loop nesting structure for GPU machine code. {"no"}

% \item[\OptArg{-I}{path}, \OptArg{--include}{path}] 
% Use \Arg{path} when resolving source file names. 
% This option is useful when a compiler records the same filename in different ways within the symbolic information.
% (Yes, this does happen.)
% For a recursive search, append a '+' after the last slash, e.g., \texttt{/mypath/+}. 
% This option may appear multiple times.

% \item[\OptArg{-R}{'old-path=new-path'}, \OptArg{--replace-path}{'old-path=new-path'}]
% Replace instances of \Arg{old-path} with \Arg{new-path} in all paths with \Arg{old-path} is a prefix
% (e.g., a profile's load map and source code).
% Use \verb+'\'+ to escape instances of '=' within specified paths.
% This option may appear multiple times.
% 
% Use this when a profile or executable references files that have been relocated,
% such as might occur with a file system change.

\end{Description}

\subsection{Options to control output:}
\begin{Description}

\item[\OptArg{-o}{filename}, \OptArg{--output}{filename}]
Write the output to to \Arg{filename}.  This option is only applicable when invoking
\Prog{hpcstruct} on a single binary.

\end{Description}

\subsection{Options for Developers:}

\begin{Description}
% \item[\OptArg{--debug}{<n>}]
% Use debug level <n>.  {1}

\item[\OptArg{--jobs-struct}{num}]
Use \Arg{num} threads for the program structure analysis phase of \Prog{hpcstruct}.

\item[\OptArg{--jobs-parse}{num}]
Use \Arg{num} threads for the parse phase of \Prog{hpcstruct}.

\item[\OptArg{--jobs-symtab}{num}]
Use \Arg{num} threads for the symbol table analysis phase of \Prog{hpcstruct}.

\item[\Opt{--show-gaps}]
Developer option to
write a text file describing all the "gaps" found by \Prog{hpcstruct},
i.e. address regions not identified as belonging to a code or data segment
by the ParseAPI parser used to analyze application executables.
The file is named \emph{outfile}\File{.gaps}, which by default is
\emph{appname}\File{.hpcstruct.gaps}.

\item[\Opt{--time}]
Display the time and space usage per phase in \Prog{hpcstruct}.

\end{Description}

\begin{Description}

\subsection{Options used internally, but not for user use}

\item[\OptArg{-M}{dirname}]
Indicate that the invocation of hpcstruct comes from the Makefile generated
by processing a measurements-directory.

\end{Description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}

\begin{enumerate}
\item 
Assume we have used HPCToolkit to collect performance measurements for the (optimized) CPU binary 
\File{sweep3d} and that performance measurement data for the application is in the measurement 
directory \File{hpctoolkit-sweep3d-measurements}. 
Assume that \File{sweep3d} was compiled with debugging information using the -g compiler flag in addition to any
optimization flags. 
To recover program structure in \File{sweep3d} and any shared libraries used during the run
for use with \HTMLhref{hpcprof.html}{\Cmd{hpcprof}{1}}, execute:
\medskip
\begin{verbatim}
    hpcstruct hpctoolkit-sweep3d-measurements
\end{verbatim}
\medskip
The output is placed in a subdirectory of the measurements directory.
\medskip
These program structure files are used to interpret performance measurements in \File{hpctoolkit-sweep3d-measurements}. 
\medskip
\begin{verbatim}
    hpcprof hpctoolkit-sweep3d-measurements
\end{verbatim}

\item
Assume we have used HPCToolkit to collect performance measurements for the (optimized) GPU-accelerated 
CPU binary \File{laghos}, which offloaded computation onto one or more Nvidia GPUs.
Assume that performance measurement data for the application is in the measurement 
directory \File{hpctoolkit-laghos-measurements}. 
\medskip
Assume that the CPU code for \File{laghos} was compiled with debugging information using the -g compiler flag in addition to any
optimization flags and that the GPU code the application contains was compiled with line map information (-lineinfo).
\medskip
To recover program structure information for the laghos CPU binary, and any shared libraries it used
during the run, as well as any GPU binaries it used, execute:
\medskip
\begin{verbatim}
    hpcstruct hpctoolkit-laghos-measurements
\end{verbatim}
\medskip
The measurement directory will be augmented with program structure information recovered for the
laghos binary, any shared libraries it used, and any GPU binaries it used.  All will be
stored in subdirectories of the measurements directory.
\medskip
\begin{verbatim}
    hpcprof hpctoolkit-laghos-measurements
\end{verbatim}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notes}

\begin{enumerate}

\item For best results, an application binary should be compiled with debugging information.
To generate debugging information while also enabling optimizations,
use the appropriate variant of \verb+-g+ for the following compilers:
\begin{itemize}
\item GNU compilers: \verb+-g+
\item Intel compilers: \verb+-g -debug inline_debug_info+
\item IBM compilers: \verb+-g -fstandalone-debug -qfulldebug -qfullpath+
\item PGI compilers: \verb+-gopt+
\item Nvidia's nvcc: \\
~~~~\verb+-lineinfo+ provides line mappings for optimized or unoptimized code\\
~~~~\verb+-G+ provides line mappings and inline information for unoptimized code
\end{itemize}

\item While \Prog{hpcstruct} attempts to guard against inaccurate debugging information,
some compilers (notably PGI's) often generate invalid and inconsistent debugging information.
Garbage in; garbage out.

\item C++ mangling is compiler specific. On non-GNU platforms, \Prog{hpcstruct}
tries both platform's and GNU's demangler.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \section{Bugs}
%% 
%% \begin{enumerate}

%% \item xxxxxx

%% \end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{See Also}

\HTMLhref{hpctoolkit.html}{\Cmd{hpctoolkit}{1}}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Version}

Version: \Version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{License and Copyright}

\begin{description}
\item[Copyright] \copyright\ 2002-2022, Rice University.
\item[License] See \File{README.License}.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Authors}

\noindent
Rice University's HPCToolkit Research Group \\
Email: \Email{hpctoolkit-forum =at= rice.edu} \\
WWW: \URL{http://hpctoolkit.org}.

\LatexManEnd

\end{document}

%% Local Variables:
%% eval: (add-hook 'write-file-hooks 'time-stamp)
%% time-stamp-start: "setDate{ "
%% time-stamp-format: "%:y/%02m/%02d"
%% time-stamp-end: "}\n"
%% time-stamp-line-limit: 50
%% End:

