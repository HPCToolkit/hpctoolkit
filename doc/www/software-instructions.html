<?xml version="1.0" encoding="UTF-8"?>
<!-- -*- coding: utf-8 -*- -->

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	  "http://www.w3.org/TR/html4/loose.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <!-- meta http-equiv="Content-Type" content="text/html; charset=utf-8" -->
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <title>Installing HPCToolkit with Spack</title>
</head>

<body>

<!-- HPCToolkit Image (height = 71 pixels) -->
<img style="position: absolute; top: 0px; left: 0px" src="style/header.gif" alt="hpctoolkit" />
<div style="position: relative; margin-top: 60px; width: 100%; text-align: right;">
<p style="margin: 0px; font-size: small;">
  [ <a href="index.html">Home</a>
    | <a href="overview.html">Overview</a>
    | <a href="publications.html">Publications</a>
    | <a href="software.html">Software/Downloads</a> ]
  &bull;
  [ <a href="documentation.html">Documentation/Questions</a>
    | <a href="training.html">Training Videos and Slides</a> ]
  &bull;
  [ <a href="info-people.html">People</a>
    | <a href="info-acks.html">Acks</a> ]
</p>
</div>
<div style="width: 100%;">
  <hr />
</div>

<h1 class="settitle" align="center">Installing HPCToolkit with Spack</h1>


<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">
<ul class="no-bullet">
<li><a name="toc-Introduction" href="#Introduction">1 Introduction</a></li>
<li><a name="toc-Prerequisites" href="#Prerequisites">2 Prerequisites</a></li>
<li><a name="toc-Spack-Notation" href="#Spack-Notation">3 Spack Notation</a></li>
<li><a name="toc-Clone-Spack-and-HPCToolkit" href="#Clone-Spack-and-HPCToolkit">4 Clone Spack and HPCToolkit</a></li>
<li><a name="toc-Config_002eyaml" href="#Config_002eyaml">5 Config.yaml</a></li>
<li><a name="toc-Modules_002eyaml" href="#Modules_002eyaml">6 Modules.yaml</a></li>
<li><a name="toc-Packages_002eyaml" href="#Packages_002eyaml">7 Packages.yaml</a>
<ul class="no-bullet">
  <li><a name="toc-External-Packages" href="#External-Packages">7.1 External Packages</a></li>
  <li><a name="toc-Micro_002dArchitecture-Targets" href="#Micro_002dArchitecture-Targets">7.2 Micro-Architecture Targets</a></li>
  <li><a name="toc-Require_002c-Reuse-and-Fresh" href="#Require_002c-Reuse-and-Fresh">7.3 Require, Reuse and Fresh</a></li>
</ul></li>
<li><a name="toc-Bootstrapping-Clingo" href="#Bootstrapping-Clingo">8 Bootstrapping Clingo</a></li>
<li><a name="toc-Compilers-and-compilers_002eyaml" href="#Compilers-and-compilers_002eyaml">9 Compilers and compilers.yaml</a></li>
<li><a name="toc-Python" href="#Python">10 Python</a></li>
<li><a name="toc-Spack-Install" href="#Spack-Install">11 Spack Install</a></li>
<li><a name="toc-Manual-Install" href="#Manual-Install">12 Manual Install</a></li>
<li><a name="toc-Advanced-Options" href="#Advanced-Options">13 Advanced Options</a>
<ul class="no-bullet">
  <li><a name="toc-CUDA" href="#CUDA">13.1 CUDA</a></li>
  <li><a name="toc-Level-Zero" href="#Level-Zero">13.2 Level Zero</a></li>
  <li><a name="toc-ROCM" href="#ROCM">13.3 ROCM</a></li>
  <li><a name="toc-OpenCL" href="#OpenCL">13.4 OpenCL</a></li>
  <li><a name="toc-MPI" href="#MPI">13.5 MPI</a></li>
  <li><a name="toc-PAPI-vs-Perfmon" href="#PAPI-vs-Perfmon">13.6 PAPI vs Perfmon</a></li>
  <li><a name="toc-Python-1" href="#Python-1">13.7 Python</a></li>
</ul></li>
<li><a name="toc-Platform-Specific-Notes" href="#Platform-Specific-Notes">14 Platform Specific Notes</a>
<ul class="no-bullet">
  <li><a name="toc-Cray" href="#Cray">14.1 Cray</a></li>
</ul></li>
<li><a name="toc-HPCToolkit-GUI-Interface-_0028Hpcviewer_0029" href="#HPCToolkit-GUI-Interface-_0028Hpcviewer_0029">15 HPCToolkit GUI Interface (Hpcviewer)</a>
<ul class="no-bullet">
  <li><a name="toc-Spack-Install-1" href="#Spack-Install-1">15.1 Spack Install</a></li>
  <li><a name="toc-Manual-Install-1" href="#Manual-Install-1">15.2 Manual Install</a></li>
</ul></li>
<li><a name="toc-Building-a-New-Compiler" href="#Building-a-New-Compiler">16 Building a New Compiler</a>
<ul class="no-bullet">
  <li><a name="toc-Using-the-New-Compiler" href="#Using-the-New-Compiler">16.1 Using the New Compiler</a></li>
  <li><a name="toc-Bootstrapping-Environment-Modules" href="#Bootstrapping-Environment-Modules">16.2 Bootstrapping Environment Modules</a></li>
</ul></li>
<li><a name="toc-Spack-Mirrors" href="#Spack-Mirrors">17 Spack Mirrors</a></li>
<li><a name="toc-Common-Problems" href="#Common-Problems">18 Common Problems</a>
<ul class="no-bullet">
  <li><a name="toc-Unable-to-fetch-tar-file" href="#Unable-to-fetch-tar-file">18.1 Unable to fetch tar file</a></li>
  <li><a name="toc-New-releases-break-the-build" href="#New-releases-break-the-build">18.2 New releases break the build</a></li>
  <li><a name="toc-Failure-to-load-modules" href="#Failure-to-load-modules">18.3 Failure to load modules</a></li>
</ul></li>

</ul>
</div>



<a name="Introduction"></a>
<h3 class="section">1 Introduction</h3>

<p>These notes describe how to build and install HPCToolkit and hpcviewer
and their prerequisites with Spack.  HPCToolkit proper (hpcrun,
hpcstruct and hpcprof) is used to measure and analyze an application&rsquo;s
performance and then produce a database for hpcviewer.  HPCToolkit is
supported on the following platforms.  IBM Blue Gene is no longer
supported.
</p>
<ol>
<li> Linux (64-bit) on x86_64, little-endian powerpc (power8 and 9) and ARM
(aarch64).  Big endian powerpc is no longer supported.

</li><li> Cray on x86_64 and Compute Node Linux.
</li></ol>

<p>We provide binary distributions for hpcviewer and hpctraceviewer on
Linux (x86_64, ppc64/le and aarch64), Windows (x86_64) and MacOS
(x86_64, M1 and M2).  HPCToolkit databases are platform-independent and it
is common to run hpcrun on one machine and then view the results on
another machine.
</p>
<p>We build HPCToolkit and its prerequisite libraries from source.
HPCToolkit has some 20-25 base prerequisites (more for cuda or rocm)
and we now use spack to build them.  It is possible to use spack to
install all of hpctoolkit or build just the prerequisites and then
build hpctoolkit with the traditional <code>configure ; make ; make
install</code> method from autotools.  Developers will probably want to run
<code>configure</code> and <code>make</code> manually, but both methods are
supported.
</p>
<p>These notes are written mostly from the view of using spack to build
hpctoolkit and its dependencies.  If you are a more experienced spack
user, especially if you want to use spack to build hpctoolkit plus
several other packages, then you will want to adapt these directions to
your own needs.
</p>
<p>Spack documentation is available at:
</p>
<div class="example">
<pre class="example"><a href="https://spack.readthedocs.io/en/latest/index.html">https://spack.readthedocs.io/en/latest/index.html</a>
</pre></div>

<p>The current status of using Spack for HPCToolkit is at:
</p>
<div class="example">
<pre class="example"><a href="http://hpctoolkit.org/spack-issues.html">http://hpctoolkit.org/spack-issues.html</a>
</pre></div>

<p>Last revised: July 11, 2023.
</p>

<a name="Prerequisites"></a>
<h3 class="section">2 Prerequisites</h3>

<p>Building HPCToolkit requires the following prerequisites.
</p>
<ol>
<li> The GNU gcc, g++ and gfortran compilers version 8.x or later with
support for C++17.  On systems with older compilers, you can use spack
to build a later version of gcc.

</li><li> GNU glibc version 2.16 or later.  Note: Red Hat 6.x uses glibc 2.12
which is too old.

</li><li> Basic build tools: make, ld, ar, objcopy, nm, etc, and shell utilities:
bash, sed, awk, grep, etc.  Most Linux systems have these tools, or
else you couldn&rsquo;t compile anything.  If you are building inside a
container, you may need to add them.

</li><li> Cmake version 3.14 or later, perl version 5.x, and python version
3.8 or later.  On systems that are missing these tools or have versions
that are too old, you can use spack to build a later version.

</li><li> Git and curl for downloading files.

</li><li> (optional) Environment (TCL) or LUA (Lmod) modules, if you want to make
HPCToolkit available as a module.  Again, spack can install these
packages if they are missing from your system.
</li></ol>

<p>Hpcviewer and hpctraceviewer require Java 11 or later.  Spack can
install Java, if needed.  On Linux, the viewers also require GTK+
version 3.20 or later.
</p>

<a name="Spack-Notation"></a>
<h3 class="section">3 Spack Notation</h3>

<p>Spack uses a special notation for specifying the version, variants,
compilers and dependencies when describing how to build a package.
This combination of version, variants, etc is called a &rsquo;spec&rsquo; and is
used both on the command line and in config files.
</p>
<ol>
<li> &rsquo;@&rsquo; specifies the package version.  <code>spack info &lt;package&gt;</code> shows
the available versions and variants for a package.  In most cases,
spaces are optional between elements of a spec.  For example:

<div class="example">
<pre class="example">boost@1.77.0    hpctoolkit @develop    papi @=6.0.0    &quot;libiberty@2.40&quot;
</pre></div>

<p>Note: <code>foo@2.1</code> includes all versions beginning with <code>2.1</code>,
including <code>2.1</code>, <code>2.1.0</code>, <code>2.1.4</code>, <code>2.1.9.9.9</code>,
<code>2.1.stable</code>, etc.  If you want version exactly <code>2.1</code>, then
use the notation <code>foo@=2.1</code> to differentiate <code>2.1</code> from
<code>2.1.*</code>.
</p>
<p>Note: dotted version numbers with exactly two fields that end with a 0
(<code>@1.10</code>, <code>@2.120</code>, etc) should be quoted so that yaml
does not treat the version <code>@2.40</code> as the floating point number
<code>2.4</code>.
</p>
</li><li> &rsquo;+&rsquo;, &rsquo;-&rsquo;, &rsquo;~&rsquo; specify boolean (on/off) variants.  Note: <code>-</code>
(dash) and <code>~</code> (tilde) both mean &rsquo;off&rsquo;.  Use dash after a space
and tilde after a non-space.  For example:

<div class="example">
<pre class="example">elfutils+bzip2~nls    elfutils +bzip2 -nls    elfutils@0.186 +bzip2~nls
</pre></div>

</li><li> &rsquo;name=value&rsquo; specifies a non-boolean variant, for example:

<div class="example">
<pre class="example">dyninst+openmp build_type=RelWithDebInfo    xerces-c@3.2.2 transcoder=iconv
</pre></div>

</li><li> &rsquo;%&rsquo; specifies the build compiler and its version, for example:

<div class="example">
<pre class="example">hpctoolkit@develop %gcc@8.5.0
</pre></div>

</li><li> &rsquo;cflags&rsquo;, &rsquo;cxxflags&rsquo;, &rsquo;fflags&rsquo;, &rsquo;cppflags&rsquo;, &rsquo;ldflags&rsquo; and &rsquo;ldlibs&rsquo; are
special name/value variants for compiler flags.  These are normally not
needed, but if you do need to add a flag to the build, then one example
might be:

<div class="example">
<pre class="example">amg2013 cflags='-O2 -mavx512pf'
</pre></div>

</li><li> &rsquo;^&rsquo; represents a dependency spec.  The spec for a dependency package is
a full spec and may include its own version, variants, etc.  For
example:

<div class="example">
<pre class="example">hpctoolkit@develop ^dyninst@12.1.0+openmp
</pre></div>

</li><li> &rsquo;arch&rsquo;, &rsquo;platform&rsquo;, &rsquo;os&rsquo; and &rsquo;target&rsquo; are special options for the
system architecture and machine type.  Platform is normally &rsquo;linux&rsquo;,
or else &rsquo;cray&rsquo; (or even &rsquo;darwin&rsquo;).  OS (or &rsquo;operating_system&rsquo;) is the
Linux distribution, &rsquo;rhel8&rsquo;, &rsquo;sles15&rsquo;, etc, and target is the machine
type, &rsquo;x86_64&rsquo;, &rsquo;ppc64le&rsquo;, etc.  Arch is a triple of platform, os and
target separated by dashes, for example <code>linux-rhel8-x86_84</code>.

<p>Normally, a system has only one arch type and you don&rsquo;t need to
specify this.  However, for systems with separate front and back-end
types, the default is the back end.  For example, if you wanted to
build for the front end on Cray, then you could use something like
this.
</p>
<div class="example">
<pre class="example">python@3.7.4 arch=cray-sles15-x86_64    boost os=fe
</pre></div>

<p>Now that spack has implemented microarchitecture targets
(haswell, ivybridge, etc), you can use &rsquo;target&rsquo; to build for a generic
x86_64 or a specific CPU type.  For example:
</p>
<div class="example">
<pre class="example">amg2013 target=x86_64    lulesh target=ivybridge
</pre></div>

<p>You can use <code>spack arch</code> to display the generic, top-level
families and the micro-arch targets.
</p>
<div class="example">
<pre class="example">spack arch --known-targets
</pre></div>
</li></ol>

<p>The following command gives a summary of spack spec syntax.
</p>
<div class="example">
<pre class="example">spack help --spec
</pre></div>

<p>When writing a spec (for <code>spack spec, install</code>, etc), spack will
fully resolve all possible choices for the package and all of its
dependencies and create a unique hash value for that exact
configuration.  This process is called &rsquo;concretization.&rsquo;  To see how
spack would concretize a spec, use <code>spack spec</code>.
</p>
<div class="example">
<pre class="example">spack spec hpctoolkit@develop ^elfutils@0.187 ^boost@1.77.0
</pre></div>

<div class="example">
<pre class="example"><a href="https://spack.readthedocs.io/en/latest/basic_usage.html#specs-dependencies">https://spack.readthedocs.io/en/latest/basic_usage.html#specs-dependencies</a>
</pre></div>


<a name="Clone-Spack-and-HPCToolkit"></a>
<h3 class="section">4 Clone Spack and HPCToolkit</h3>

<p>Spack is available via git clone from GitHub.  This includes the core
spack machinery and recipes for building over 7,000 packages (and
growing).  You should also clone HPCToolkit for the
<code>packages.yaml</code> file which is used to configure the spack build.
Note: spack is on GitHub, but hpctoolkit has moved to GitLab.
</p>
<div class="example">
<pre class="example">git clone https://github.com/spack/spack.git
git clone https://gitlab.com/hpctoolkit/hpctoolkit.git
</pre></div>

<p>After cloning, add the <code>spack/bin</code> directory to your PATH, or else
source the spack <code>setup-env</code> script.
</p>
<div class="example">
<pre class="example">(bash)   .  /path/to/spack/share/spack/setup-env.sh
(csh)    setenv SPACK_ROOT /path/to/spack/root
         source $SPACK_ROOT/share/spack/setup-env.csh
</pre></div>

<p>It suffices to add <code>spack/bin</code> to your PATH (or even symlink the
spack launch script).  Sourcing the <code>setup-env</code> script adds extra
support for modules built by spack.
</p>

<a name="Config_002eyaml"></a>
<h3 class="section">5 Config.yaml</h3>

<p><code>config.yaml</code> is the top-level spack config file.  This specifies
the directory layout for installed files and the top-level spack
parameters.
</p>
<p>By default, spack installs packages inside the spack repository at
<code>spack/opt/spack</code>.  To use another location, set the <code>root</code>
field under <code>install_tree</code> in <code>config.yaml</code>.  Normally, you
will want to set this.
</p>
<div class="example">
<pre class="example">config:
  install_tree:
    root: /path/to/top-level/install/directory
</pre></div>

<p>There are a few other fields that you may want to set for your local
system.  These are all in <code>config.yaml</code>.
</p>
<ol>
<li> <code>build_stage</code> &ndash; the location where spack builds packages
(default is in <code>/tmp</code>).

</li><li> <code>source_cache</code> &ndash; where spack stores downloaded source tar files.

</li><li> <code>connect_timeout</code> &ndash; some download sites, especially sourceforge
are often slow to connect.  If you find that connections are timing out,
try increasing this time to 30 or 60 seconds (default is 10 seconds).

</li><li> <code>url_fetch_method</code> &ndash; by default, spack uses a python library
(urllib) to fetch source files.  If you have trouble downloading
files, try changing this to <code>curl</code>.

</li><li> <code>build_jobs</code> &ndash; by default, spack uses all available hardware
threads for parallel make, up to a limit of 16.  If you want to use a
different number, then set this.
</li></ol>

<p>The default <code>config.yaml</code> file is in the spack repository at
<code>spack/etc/spack/defaults</code>.  The simplest solution is to copy this
file one directory up and then edit the copy (don&rsquo;t edit the default
file directly).
</p>
<div class="example">
<pre class="example">cd spack/etc/spack
cp defaults/config.yaml .
vi config.yaml
</pre></div>

<p>Alternatively, you could put this file in a separate directory,
outside of the spack repository and then use <code>-C/--config-scope
dir</code> on the spack command line.  (The <code>-C</code> option goes before the
spack command name.)  This is useful if you maintain multiple config
files for different machines.
</p>
<div class="example">
<pre class="example">spack -C dir install ...
</pre></div>

<p>Note: if you put <code>config.yaml</code> in <code>spack/etc/spack</code>, then it
will apply to every spack command for that repository (and you won&rsquo;t
forget).  Putting it in a separate directory is more flexible because
you can support multiple configurations from the same repository.  But
then you must use <code>-C dir</code> with every spack command or else you
will get inconsistent results.
</p>
<p>You can view the current configuration and see where each entry comes
from with <code>spack config</code>.
</p>
<div class="example">
<pre class="example">spack [-C dir] config get config
spack [-C dir] config blame config
</pre></div>

<p>See the spack docs on &lsquo;Configuration Files&rsquo; and &lsquo;Basic Settings&rsquo;.
</p>
<div class="example">
<pre class="example"><a href="https://spack.readthedocs.io/en/latest/configuration.html">https://spack.readthedocs.io/en/latest/configuration.html</a>
<a href="https://spack.readthedocs.io/en/latest/config_yaml.html">https://spack.readthedocs.io/en/latest/config_yaml.html</a>
</pre></div>


<a name="Modules_002eyaml"></a>
<h3 class="section">6 Modules.yaml</h3>

<p>Spack supports creating module files, but does not install them by
default.  If you want to install module files, then you need to edit
<code>modules.yaml</code> to specify which type of modules to use (TCL or
Lmod) and the install path.
</p>
<div class="example">
<pre class="example">modules:
  default:
    roots:
      # normally, need only one of these
      tcl:  /path/to/top-level/tcl-module/directory
      lmod: /path/to/top-level/lmod-module/directory
    enable:
      - tcl  (or lmod)
</pre></div>

<p>Also, for hpctoolkit, you should also turn off autoload for
dependencies.  By default, autoload loads the modules for hpctoolkit&rsquo;s
dependencies.  But hpctoolkit does not need this and loading them may
interfere with an application&rsquo;s dependencies.  You should do this for
both tcl and lmod modules.
</p>
<div class="example">
<pre class="example">modules:
  default:
    tcl:
      hpctoolkit:
        autoload: none
      all:
        autoload: direct
</pre></div>


<a name="Packages_002eyaml"></a>
<h3 class="section">7 Packages.yaml</h3>

<p>The <code>packages.yaml</code> file specifies the versions and variants for
the packages that spack installs and serves as a common reference
point for HPCToolkit&rsquo;s prerequisites.  This file also specifies the
paths or modules for system build tools (cmake, python, etc) to avoid
rebuilding them.  Put this file in the same directory as
<code>config.yaml</code>.  A sample <code>packages.yaml</code> file is available
in the <code>spack</code> directory of the hpctoolkit repository.
</p>
<p>There are two main sections to <code>packages.yaml</code>.  The first
specifies the versions and variants for hpctoolkit&rsquo;s prereqs.  By
default, spack will choose the latest version of each package (plus
any constraints from hpctoolkit&rsquo;s <code>package.py</code> file).  In most
cases, this will work, but not always.  If you need to specify a
different version or variant, then set this in <code>packages.yaml</code>.
For example:
</p>
<div class="example">
<pre class="example">packages:
  elfutils:
  version:  [0.189]
  variants: ~nls
</pre></div>

<p>Note: the versions and variants specified in hpctoolkit&rsquo;s
<code>package.py</code> file are hard constraints and should not be changed.
Variants in <code>packages.yaml</code> are preferences that may be modified
for your local system.  (But don&rsquo;t report a bug until you have first
tried the versions from <code>packages.yaml</code> that we supply.)
</p>
<a name="External-Packages"></a>
<h4 class="subsection">7.1 External Packages</h4>

<p>The other sections in <code>packages.yaml</code> specify paths or modules
for other packages and system build tools.  Building hpctoolkit&rsquo;s
prerequisites requires cmake 3.14 or later, perl 5.x and python 3.8 or
later.  There are three ways to satisfy these requirements: a system
installed version (eg, /usr), a pre-built module or build from
scratch.
</p>
<p>By default, spack will rebuild these from scratch, even if your local
version is perfectly fine.  If you already have an installed version
and prefer to use that instead, then you can specify this in
<code>packages.yaml</code>.
</p>
<p>The easiest way to use a pre-built package is to let spack find the
package itself.  Make sure the program is on your PATH and run
<code>spack external</code>.  For example, to search for <code>cmake</code>, use:
</p>
<div class="example">
<pre class="example">spack external find cmake
</pre></div>

<p>This does not work for every spack package, but it does work with
<code>cmake</code>, <code>perl</code> and <code>python</code>.  Note: spack puts these
entries in <code>packages.yaml</code> in the <code>.spack</code> subdirectory of
your home directory.
</p>
<p>You can also add these entries manually to <code>packages.yaml</code>.  For
example, this entry says that cmake 3.7.2 is available from module
<code>CMake/3.7.2</code>.  <code>buildable: False</code> is optional and means
that spack must find a matching external spec or else fail the build.
</p>
<div class="example">
<pre class="example">cmake:
  externals:
  - spec: cmake@3.7.2
    modules:
    - CMake/3.7.2
  buildable: False
</pre></div>

<p>This example says that python2 and python3 are both available in
<code>/usr/bin</code>.  Note that the <code>prefix</code> entry is the parent
directory of <code>bin</code>, not the bin directory itself.
</p>
<div class="example">
<pre class="example">python:
  externals:
  - spec: python@2.7.18
    prefix: /usr
  - spec: python@3.6.8
    prefix: /usr
</pre></div>

<p>Note: as a special rule for python, use package name <code>python</code>,
even though the program name is python2 or python3.
</p>
<p><b>Warning:</b> It is Ok to use spack externals for build utilities that
exist on your system (cmake, perl, python).  However, we strongly
recommend that you should rebuild all prereq packages that link code
into hpctoolkit (dyninst, elfutils, etc).
</p>
<a name="Micro_002dArchitecture-Targets"></a>
<h4 class="subsection">7.2 Micro-Architecture Targets</h4>

<p>Spack implements a hierarchy of micro-architecture targets, where
&rsquo;target&rsquo; is a specific architecture (eg, haswell, ivybridge, etc)
instead of a generic family (x86_64, ppc64le or aarch64).  This allows
the compiler to optimize code for the specific target.
</p>
<p>You will notice this choice in two main places: the &rsquo;spack spec&rsquo; and the
path for the install directory.  For example, <code>linux-rhel7-x86_64</code>
might become <code>linux-rhel7-broadwell</code>.  You can use <code>spack
arch</code> to see the list of generic families and micro-architecture
targets.
</p>
<div class="example">
<pre class="example">spack arch --known-targets
</pre></div>

<p>If you prefer a generic install, you can use the <code>target</code> option
to specify a generic family (x86_64, ppc64le or aarch64) instead of a
micro-architecture target.  This would be useful for a shared install
that needs to work across multiple machines with different micro-arch
types.  For example:
</p>
<div class="example">
<pre class="example">spack install hpctoolkit ... target=x86_64
</pre></div>

<p>You can also specify preferences for <code>target</code>, <code>compilers</code>
and <code>providers</code> in the <code>all:</code> section of
<code>packages.yaml</code>.  Note: these are only preferences, they can be
overridden on the command line.
</p>
<div class="example">
<pre class="example">packages:
  all:
    target: [x86_64]
    compiler: [gcc@9.3.0]
    providers:
      mpi: [openmpi]
</pre></div>

<p>See the spack docs on &rsquo;Build Customization&rsquo; and &rsquo;Specs and
Dependencies&rsquo;.
</p>
<div class="example">
<pre class="example"><a href="https://spack.readthedocs.io/en/latest/build_settings.html">https://spack.readthedocs.io/en/latest/build_settings.html</a>
<a href="https://spack.readthedocs.io/en/latest/basic_usage.html#specs-dependencies">https://spack.readthedocs.io/en/latest/basic_usage.html#specs-dependencies</a>
</pre></div>

<a name="Require_002c-Reuse-and-Fresh"></a>
<h4 class="subsection">7.3 Require, Reuse and Fresh</h4>

<p>It is important to understand that specifications in
<code>packages.yaml</code> are only preferences, not requirements.  There
are other choices that spack ranks higher.  In particular, spack will
prefer to reuse an existing package that doesn&rsquo;t conform to
<code>packages.yaml</code> rather than rebuild a newer version.
</p>
<p>For example, suppose you previously installed hpctoolkit with dyninst
12.1.0.  Then, some months later, you update your spack repo and want
to install a new hpctoolkit with dyninst 12.3.0.  By default, spack
will prefer to reuse the old 12.1.0 rather than rebuild the new
version.
</p>
<p>The solution is to use <code>require:</code> to force spack to build the new
version.
</p>
<div class="example">
<pre class="example">packages:
  dyninst:
    require: &quot;@12.3.0&quot;
</pre></div>

<p>Note:
</p><ol>
<li> The value for <code>require:</code> is a full spec (so include <code>@</code> for
version) and supersedes both version and variants.

</li><li> The value for <code>require:</code> should be a singleton spec (not a list)
and should be quoted.
</li></ol>

<p>By default, spack install uses <code>--reuse</code> which prefers reusing an
already installed package.  You can change this with <code>--fresh</code>
which prefers to rebuild the latest version of a package.  But
<code>--reuse</code> and <code>--fresh</code> apply to all package versions.  The
advantage of <code>require:</code> is that you can selectively choose the
version and variants on a package by package basis.
</p>
<p>There are two extensions to <code>require:</code> that are sometimes useful.
<code>any_of</code> requires one or more from a list of specs, and
<code>one_of</code> requires exactly one from a list of specs.  For example,
</p>
<div class="example">
<pre class="example">packages:
  boost:
    require:
      - one_of: [&quot;@1.75.0&quot;, &quot;@1.77.0&quot;]
  elfutils:
    require:
      - any_of: [&quot;+bzip2&quot;, &quot;+xz&quot;]
</pre></div>

<p>You can require the target, compiler or providers in
<code>packages.yaml</code> as follows.  Recall that the field for
<code>require:</code> is a spec in quotes.
</p>
<div class="example">
<pre class="example">packages:
  all:
    require: &quot;%gcc@9.3.0 target=x86_64&quot;
  mpi:
    require: &quot;mpich@4.0&quot;
</pre></div>

<div class="example">
<pre class="example"><a href="https://spack.readthedocs.io/en/latest/build_settings.html#package-requirements">https://spack.readthedocs.io/en/latest/build_settings.html#package-requirements</a>
</pre></div>


<a name="Bootstrapping-Clingo"></a>
<h3 class="section">8 Bootstrapping Clingo</h3>

<p>The &rsquo;concretizer&rsquo; is the part of spack that converts a partial spec
into a full spec with values for the version and variants of every
package in the spec plus all dependencies.  The new concretizer for
spack (clingo) is a third-party python library for solving answer-set
logic problems (eg, satisfiability).  Normally, this only needs to be
set up once per machine, the first time you run spack.
</p>
<p>The easiest way to install clingo it to use spack&rsquo;s pre-built
libraries.  These are available for Linux (x86_64, ppc64le, aarch64)
and Macos/Darwin (x86_64) for python 3.7 or later.  The Macos version
also requires Macos 10.13 or later and the Xcode developer package
(for python and other programs).
</p>
<p>By default, spack will automatically install (bootstrap) clingo the
first time you run a command that uses it (<code>spec</code> or
<code>solve</code>).  However, if this fails or you want to verify the steps
yourself, then follow these steps.
</p>
<p>In <code>config.yaml</code>, set <code>concretizer</code> to <code>clingo</code>.
</p>
<div class="example">
<pre class="example">config:
  concretizer: clingo
</pre></div>

<p>Spack needs at least one compiler configured (see below).  If this is
your first time running spack on this machine, then use <code>compiler
find</code> to detect a compiler.  Finally, use <code>spack solve</code> to
trigger bootstrapping.
</p>
<div class="example">
<pre class="example">spack compiler list    (to display known compilers)
spack compiler find    (to add a compiler, if needed)
spack solve zlib
==&gt; Bootstrapping clingo from pre-built binaries
...
zlib@1.2.11%gcc@8.4.1+optimize+pic+shared arch=linux-rhel8-zen
</pre></div>

<p>Spack stores the clingo bootstrap files in <code>~/.spack/bootstrap</code>.
You can check on the status of these files or clean (reset) them with
the <code>find</code> or <code>clean</code> commands.
</p>
<div class="example">
<pre class="example">spack find -b     (displays the status of the bootstrap files)
spack clean -b    (erases the current bootstrap files)
</pre></div>

<p>If the binary bootstrap fails, then try the <code>solve</code> step with
debugging turned on.
</p>
<div class="example">
<pre class="example">spack -d solve zlib
</pre></div>

<p>If the binary bootstrap fails or if your system is not supported, then
you will need to let spack build clingo from source.  Reset
<code>spack-install</code> to true and rerun <code>spack solve zlib</code>.  This
requires a compiler with support for C++14 and takes maybe 30-45
minutes to install all the packages.
</p>
<div class="example">
<pre class="example"><a href="https://spack.readthedocs.io/en/latest/getting_started.html#bootstrapping-clingo">https://spack.readthedocs.io/en/latest/getting_started.html#bootstrapping-clingo</a>
<a href="https://github.com/alalazo/spack-bootstrap-mirrors#supported-platforms">https://github.com/alalazo/spack-bootstrap-mirrors#supported-platforms</a>
</pre></div>


<a name="Compilers-and-compilers_002eyaml"></a>
<h3 class="section">9 Compilers and compilers.yaml</h3>

<p>Building HPCToolkit requires GNU gcc/g++ version 8.x or later with
C++17 support.  By default, spack uses the latest available version of
gcc, but you can specify a different compiler, if one is available.
</p>
<p>Spack uses a separate file, <code>compilers.yaml</code> to store information
about available compilers.  This file is normally in your home directory
at <code>~/.spack/platform</code> where &lsquo;platform&rsquo; is normally &lsquo;linux&rsquo; (or
else &lsquo;cray&rsquo;).
</p>
<p>The first time you use spack, or after adding a new compiler, you should
run <code>spack compiler find</code> to have spack search your system for
available compilers.  If a compiler is provided as a module, then you
should load the module before running <code>find</code>.  Normally, you only
need to run <code>find</code> once, unless you want to add or delete a
compiler.  You can also run <code>spack compiler list</code> and <code>spack
compiler info</code> to see what compilers spack knows about.
</p>
<p>For example, on one power8 system running RedHat 7.3, /usr/bin/gcc is
version 4.8.5, but gcc 8.3.0 is available as module <code>GCC/8.3.0</code>.
</p>
<div class="example">
<pre class="example">module load GCC/8.3.0

spack compiler find
==&gt; Added 2 new compilers to /home/krentel/.spack/linux/compilers.yaml
    gcc@8.3.0  gcc@4.8.5
==&gt; Compilers are defined in the following files:
    /home/krentel/.spack/linux/compilers.yaml

spack compiler list
==&gt; Available compilers
-- gcc rhel7-ppc64le --------------------------------------------
gcc@8.3.0  gcc@4.8.5

spack compiler info gcc@8.3
gcc@8.3.0:
    paths:
        cc = /opt/apps/software/Core/GCCcore/8.3.0/bin/gcc
        cxx = /opt/apps/software/Core/GCCcore/8.3.0/bin/g++
        f77 = /opt/apps/software/Core/GCCcore/8.3.0/bin/gfortran
        fc = /opt/apps/software/Core/GCCcore/8.3.0/bin/gfortran
    modules  = ['GCC/8.3.0']
    operating system  = rhel7
</pre></div>

<p>Note: for compilers from modules, spack does not fill in the
<code>modules:</code> field in the <code>compilers.yaml</code> file.  You need to
do this manually.  In the above example, after running <code>find</code>, I
edited <code>compilers.yaml</code> to add <code>GCC/8.3.0</code> to the
<code>modules:</code> field as below.  This is important to how spack
manipulates the build environment.
</p>
<div class="example">
<pre class="example">- compiler:
    modules: [GCC/8.3.0]
    operating_system: rhel7
    spec: gcc@8.3.0
    ...
</pre></div>

<p>Spack uses <code>%</code> syntax to specify the build compiler and <code>@</code>
syntax to specify the version.  For example, suppose you had gcc
versions 8.5.0, 9.3.0 and 10.2.0 available and you wanted to use 9.3.0.
You could write this as:
</p>
<div class="example">
<pre class="example">spack install package %gcc@9.3.0
</pre></div>

<p>You can also set the choice of compiler in the <code>all:</code> section of
<code>packages.yaml</code>.
</p>
<div class="example">
<pre class="example">packages:
  all:
    compiler: [gcc@9.3.0]
</pre></div>

<p>See the spack docs on &lsquo;Compiler Configuration&rsquo;.
</p>
<div class="example">
<pre class="example"><a href="https://spack.readthedocs.io/en/latest/getting_started.html#compiler-configuration">https://spack.readthedocs.io/en/latest/getting_started.html#compiler-configuration</a>
</pre></div>


<a name="Python"></a>
<h3 class="section">10 Python</h3>

<p>Spack uses Python for two things.  First, to run the Spack scripts
written in Python, and second, to use as a dependency for other spack
packages.  These do not have to be the same python version or install.
</p>
<p>Currently, Spack requires at a minimum Python 3.7 to run spack at all.
But 3.7 is deprecated and support for it will be removed in a few
months.  So, the best thing to do is to upgrade to Python 3.8 or later
now.
</p>
<p>If python 3.8 or later is not available on your system, then your
options to install it are: (1) load a module for a later version, (2)
use yum or apt to install a later version, (3) ask your sysadmin to
install a later version, or (4) as a last resort, compile a later
version from source.
</p>
<p>If a later python is available on your system but not first in your
PATH or under a different name, you can set the environment variable
<code>SPACK_PYTHON</code> to the python3 binary.  For example, suppose
<code>/usr/bin/python3</code> is too old, but python 3.8 is available as
<code>/usr/bin/python3.8</code>, then you could use:
</p>
<div class="example">
<pre class="example">export SPACK_PYTHON=/usr/bin/python3.8
</pre></div>

<p>If set, <code>SPACK_PYTHON</code> is the path to the Python interpreter used
to run Spack.
</p>

<a name="Spack-Install"></a>
<h3 class="section">11 Spack Install</h3>

<p>First, set up your <code>config.yaml</code>, <code>modules.yaml</code>,
<code>packages.yaml</code> and <code>compilers.yaml</code> files as above and edit
them for your system.  You can see how spack will build hpctoolkit
with <code>spack spec</code>.
</p>
<div class="example">
<pre class="example">spack spec hpctoolkit
</pre></div>

<p>Then, the &ldquo;one button&rdquo; method uses spack to install everything.
</p>
<div class="example">
<pre class="example">spack install hpctoolkit
</pre></div>

<p><b>Tip:</b> Spack fetch is somewhat fragile and sometimes has transient
problems downloading files.  You can use <code>spack fetch -D</code> to
pre-fetch all of the tar files and resolve any downloading problems
before starting the full install.
</p>
<div class="example">
<pre class="example">spack fetch -D hpctoolkit
</pre></div>


<a name="Manual-Install"></a>
<h3 class="section">12 Manual Install</h3>

<p>The manual method uses spack to build hpctoolkit&rsquo;s prerequisites and
then uses the traditional autotools <code>configure &amp;&amp; make &amp;&amp; make
install</code> to install hpctoolkit.  This method is primarily for
developers who want to compile hpctoolkit, edit the source code and
recompile, etc.  This method is also useful if you need some configure
option that is not available through spack.
</p>
<p>First, use spack to build hpctoolkit&rsquo;s prerequisites as above.  You
can either build some version of hpctoolkit as before (which will pull
in the prerequisites), or else use <code>--only dependencies</code> to avoid
building hpctoolkit itself.
</p>
<div class="example">
<pre class="example">spack install --only dependencies hpctoolkit
</pre></div>

<p>Then, configure and build hpctoolkit as follows.  Hpctoolkit uses
automake and so allows for parallel make.
</p>
<div class="example">
<pre class="example">configure  \
   --prefix=/path/to/hpctoolkit/install/prefix  \
   --with-spack=/path/to/spack/install_tree/linux-centos9-x86_64/gcc-11.3.1  \
   ...
make -j &lt;num&gt;
make install
</pre></div>

<p>The argument to <code>--with-spack</code> should be the directory containing
all of the individual package directories, normally two directories
down from the top-level <code>install_tree</code> and named by the platform
and compiler.  This option replaces the old <code>--with-externals</code>.
The following are other options that may be useful.  For the full list
of options, see <code>configure -h</code>.
</p>
<ol>
<li> <code>--enable-all-static</code> &ndash; build hpcprof-mpi statically linked for
the compute nodes.

</li><li> <code>--enable-develop</code> &ndash; compile with optimization turned off for
debugging.

</li><li> <code>--with-package=path</code> &ndash; specify the install prefix for some
prerequisite package, mostly for developers who want to use a custom,
non-spack version of some package.

</li><li> <code>MPICXX=compiler</code> &ndash; specify the MPI C++ compiler for
hpcprof-mpi, may be a compiler name or full path.
</li></ol>

<p>Note: if your spack install tree has multiple versions or variants for
the same package, then <code>--with-spack</code> will select the one with
the most recent directory time stamp (and issue a warning).  If this
is not what you want, then you will need to specify the correct
version with a <code>--with-package</code> option.
</p>

<a name="Advanced-Options"></a>
<h3 class="section">13 Advanced Options</h3>

<a name="CUDA"></a>
<h4 class="subsection">13.1 CUDA</h4>

<p>Beginning with the 2020.03.01 version, HPCToolkit now supports
profiling CUDA binaries (nVidia only).  For best results, use CUDA
version 10.1 or later and Dyninst 10.1 or later.  Note: in addition to
a CUDA installation, you also need the CUDA system drivers installed.
This normally requires root access and is outside the scope of spack.
</p>
<p>For a spack install with CUDA, use the <code>+cuda</code> variant.
</p>
<div class="example">
<pre class="example">spack install hpctoolkit +cuda
</pre></div>

<p>For a manual install, either download and install CUDA or use an
existing module, and then use the <code>--with-cuda</code> configure option.
</p>
<div class="example">
<pre class="example">configure  \
   --prefix=/path/to/hpctoolkit/install/prefix  \
   --with-spack=/path/to/spack/install/dir   \
   --with-cuda=/path/to/cuda/install/prefix  \
   ...
</pre></div>

<p>If you installed CUDA with spack in the same directory as the rest of
the prerequisites, then the <code>--with-spack</code> option should find it
automatically (but check the summary at the end of the configure
output).  If you are using CUDA from a separate system module, then you
will need the <code>--with-cuda</code> option.
</p>

<a name="Level-Zero"></a>
<h4 class="subsection">13.2 Level Zero</h4>

<p>HPCToolkit supports profiling Intel GPUs through the Intel Level Zero
and Intel GTPin interfaces.  For basic support (start and stop times
for GPU kernels) add the <code>+level_zero</code> variant.  For advanced
support inside the GPU kernel, also add the <code>+gtpin</code> variant.
But we recommend always compiling with gtpin and then deciding at
runtime which options to use.
</p>
<div class="example">
<pre class="example">spack install hpctoolkit +level_zero +gtpin
</pre></div>

<p>GTPin requires the <code>oneapi-igc</code> package which is an external only
spack package, normally installed in <code>/usr</code>.  You should add this
manually with a spack externals (it&rsquo;s currently not searchable) and
let spack build the rest.  For example:
</p>
<div class="example">
<pre class="example">packages:
  oneapi-igc:
    externals:
     - spec: oneapi-igc@1.0.10409
       prefix: /usr
</pre></div>

<p>For an autotools build, use the options:
</p>
<div class="example">
<pre class="example">configure  \
    --with-level0=/path/to/oneapi-level-zero/prefix  \
    --with-gtpin=/path/to/intel-gtpin/prefix  \
    --with-igc=/usr   (or oneapi-igc prefix)  \
    ...
</pre></div>


<a name="ROCM"></a>
<h4 class="subsection">13.3 ROCM</h4>

<p>HPCToolkit supports profiling AMD GPU binaries through the HIP/ROCM
interface, and beginning with version 2022.04.15, we support building
hpctoolkit plus rocm with a fully integrated spack build.  We require
ROCM 5.x or later, and the ROCM version should match the version the
application uses.  This is still somewhat fluid and subject to change.
</p>
<p>There are two ways to build HPCToolkit plus ROCM with spack.
HPCToolkit uses four ROCM prerequisites (hip, hsa-rocr-dev,
roctracer-dev and rocprofiler-dev).  If you have AMD&rsquo;s all-in-one ROCM
package installed in <code>/opt</code>, then specify all four prereqs in
<code>packages.yaml</code>.  For example, if ROCM 5.0.0 is installed at
<code>/opt/rocm-5.0.0</code>, then you would use:
</p>
<div class="example">
<pre class="example">packages:
  hip:
    externals:
    - spec: hip@5.0.0
      prefix: /opt/rocm-5.0.0

  hsa-rocr-dev:
    externals:
    - spec: hsa-rocr-dev@5.0.0
      prefix: /opt/rocm-5.0.0

  roctracer-dev:
    externals:
    - spec: roctracer-dev@5.0.0
      prefix: /opt/rocm-5.0.0

  rocprofiler-dev:
    externals:
    - spec: rocprofiler-dev@5.0.0
      prefix: /opt/rocm-5.0.0
</pre></div>

<p>Currently, with AMD&rsquo;s directory layout, the hip and hsa-rocr-dev
prefixes could be specified either as <code>/opt/rocm-5.0.0</code> or
<code>/opt/rocm-5.0.0/hip</code> (and <code>/opt/rocm-5.0.0/hsa</code>).  But
roctracer-dev and rocprofiler-dev require <code>/opt/rocm-5.0.0</code>.
Also, the rocm packages do not support <code>spack external find</code>.
But all this is fluid and subject to change.
</p>
<p>Alternatively, if ROCM is not installed in <code>/opt/rocm</code>, or if you
want to build a different version, then omit the externals definitions
in <code>packages.yaml</code> (but be prepared for spack to build an extra
80-90 packages).  In either case, install hpctoolkit with:
</p>
<div class="example">
<pre class="example">spack install hpctoolkit +rocm ...
</pre></div>

<p>For developers building with autotools, use the following configure
options.  If <code>/opt/rocm</code> is available, then use the
<code>--with-rocm</code> option.  Otherwise, use the other four options.
</p>
<div class="example">
<pre class="example">configure  \
   --with-rocm=/opt/rocm \    (for all-in-one /opt/rocm)

   --with-rocm-hip=/path/to/hip/prefix  \
   --with-rocm-hsa=/path/to/hsa-rocr-dev/prefix  \
   --with-rocm-tracer=/path/to/roctracer-dev/prefix  \
   --with-rocm-profiler=/path/to/rocprofiler-dev/prefix  \
   ...
</pre></div>

<p>It is allowed to mix the all-in-one option with the individual
packages.  The rule is that the specific overrides the general.
</p>

<a name="OpenCL"></a>
<h4 class="subsection">13.4 OpenCL</h4>

<p>For all three GPU types, an application can access the GPU through the
native interface (CUDA, ROCM, Level Zero) or through the OpenCL
interface.  To add support for OpenCL, add the <code>+opencl</code> variant
in addition to the native interface.  We recommend adding opencl
support for all GPU types.  For example, with CUDA:
</p>
<div class="example">
<pre class="example">spack install hpctoolkit +cuda +opencl
</pre></div>

<p>For an autotools build, use the <code>--with-opencl</code> option.
</p>
<div class="example">
<pre class="example">configure  \
    --with-cuda=/path/to/cuda/prefix  \
    --with-opencl=/path/to/opencl-c-headers/prefix  \
    ...
</pre></div>


<a name="MPI"></a>
<h4 class="subsection">13.5 MPI</h4>

<p>HPCToolkit always supports profiling MPI applications.  For
hpctoolkit, the spack variant <code>+mpi</code> is for building hpcprof-mpi,
the MPI version of hpcprof.  If you want to build hpcprof-mpi, then
you need to supply an installation of MPI.
</p>
<div class="example">
<pre class="example">spack install hpctoolkit +mpi
</pre></div>

<p>Normally, for systems with compute nodes, you should use an existing
MPI module that was built for the correct interconnect for your system
and add this to <code>packages.yaml</code>.  The MPI module should be built
with the same version of GNU gcc/g++ used to build hpctoolkit (to keep
the C++ libraries in sync).  For example,
</p>
<div class="example">
<pre class="example">packages:
  mpich:
    externals:
    - spec: mpich@4.0
      modules:
      - mpich/4.0
</pre></div>


<a name="PAPI-vs-Perfmon"></a>
<h4 class="subsection">13.6 PAPI vs Perfmon</h4>

<p>HPCToolkit can access the Hardware Performance Counters with either
PAPI (default) or Perfmon (libpfm4).  PAPI runs on top of the perfmon
library and uses its own, internal (but slightly out of date) copy of
perfmon.  So, building with <code>+papi</code> allows accessing the counters
with either PAPI or perfmon events.
</p>
<p>If you want to disable PAPI and use the latest Perfmon instead, then
build hpctoolkit with <code>~papi</code>.
</p>
<div class="example">
<pre class="example">spack install hpctoolkit ~papi
</pre></div>


<a name="Python-1"></a>
<h4 class="subsection">13.7 Python</h4>

<p>Beginning with the 2023 release, HPCToolkit can now profile Python
scripts and attribute samples to python source functions instead of
the python interpreter.  This requires Python 3.10 or later and is not
the same python to run the spack scripts.  This should be the same
python used to run the application.
</p>
<div class="example">
<pre class="example">spack install hpctoolkit +python
</pre></div>

<p>When building with autotools, use the <code>--enable-python</code> argument
with the path to the <code>python-config</code> command.
</p>
<div class="example">
<pre class="example">configure  \
    --enable-python=/path/to/python-config
    ...
</pre></div>


<a name="Platform-Specific-Notes"></a>
<h3 class="section">14 Platform Specific Notes</h3>

<a name="Cray"></a>
<h4 class="subsection">14.1 Cray</h4>

<p>There are two ways to build <code>hpcprof-mpi</code> on Cray systems
depending on how old the system is and what MPI wrapper is available.
Newer Crays have an <code>mpicxx</code> wrapper from the <code>cray-mpich</code>
module (but it may not be on your PATH).  Older Crays use the
<code>CC</code> wrapper from the <code>craype</code> module.
</p>
<p>On either type of system, start by switching to the <code>PrgEnv-gnu</code>
module and unload the Darshan module if it exists.  Darshan is a
profiling tool that monitors an application&rsquo;s use of I/O, but it
conflicts with hpctoolkit.
</p>
<div class="example">
<pre class="example">module swap PrgEnv-cray PrgEnv-gnu
module unload darshan
</pre></div>

<p>Next, we need the front-end GCC compiler that is compatible with the
MPI compiler.  The gcc compiler should use the front-end operating
system type (sles, not cnl) and should be version 8.x or later
(preferably 9.x or later).  The <code>cc</code> and <code>cxx</code> compilers
should be gcc and g++, not the cc and CC wrappers, and the modules
should include at least <code>PrgEnv-gnu</code> and <code>gcc</code>.
</p>
<p>For example, I have the following on Crusher at ORNL in my
<code>compilers.yaml</code> file (your versions may differ).  Note that
spack may report the front-end arch type as either cray or linux.
</p>
<div class="example">
<pre class="example">compilers:
- compiler:
    spec: gcc@11.2.0
    paths:
      cc:  /opt/cray/pe/gcc/11.2.0/bin/gcc
      cxx: /opt/cray/pe/gcc/11.2.0/bin/g++
      f77: /opt/cray/pe/gcc/11.2.0/bin/gfortran
      fc:  /opt/cray/pe/gcc/11.2.0/bin/gfortran
    modules:
      - PrgEnv-gnu/8.3.3
      - gcc/11.2.0
    operating_system: sles15
    target: x86_64
    ...
</pre></div>

<p><b>New Cray</b> The preferred method for newer Crays is using the
<code>+mpi</code> option and the <code>cray-mpich</code> module.  This requires
the <code>mpicxx</code> wrapper, although it won&rsquo;t be on your PATH.  Look in
the <code>$MPICH_DIR</code> or <code>$CRAY_MPICH_DIR</code> directory for the
<code>mpicxx</code> wrapper.  For example on Crusher, this is at the
following path, your path may be different.
</p>
<div class="example">
<pre class="example">/opt/cray/pe/mpich/8.1.17/ofi/gnu/9.1/bin/mpicxx
</pre></div>

<p>If this is available, then add a spack externals entry for
<code>cray-mpich</code> and the <code>mpi</code> virtual package to
<code>packages.yaml</code>.  For example, I used this entry on Crusher, your
versions may be different (put the specs in quotes).
</p>
<div class="example">
<pre class="example">packages:
  mpi:
    require: &quot;cray-mpich@8.1.17&quot;

  cray-mpich:
    externals:
      - spec: &quot;cray-mpich@8.1.17&quot;
        prefix: /opt/cray/pe/mpich/8.1.17/ofi/gnu/9.1
        modules:
         - cray-mpich/8.1.17
</pre></div>

<p>Then, build with <code>+mpi</code> for the front-end arch type (with arch or
os).  If the front and back-end arch types are the same, then you
don&rsquo;t need to specify that.  For example,
</p>
<div class="example">
<pre class="example">spack install hpctoolkit +mpi os=fe    (or arch=cray-sles15-x86_64)
</pre></div>

<p>Cray&rsquo;s use of modules is complex and requires several modules to be
loaded at compile time.  You will likely find that the above recipe
fails with an undefined reference to one or more modules.  For
example,
</p>
<div class="example">
<pre class="example">/usr/bin/ld: warning: libfabric.so.1, needed by /opt/cray/pe/mpich/8.1.17/ofi/gnu/9.1/lib/libmpi_gnu_91.so,
not found (try using -rpath or -rpath-link)
/usr/bin/ld: /opt/cray/pe/mpich/8.1.17/ofi/gnu/9.1/lib/libmpi_gnu_91.so:
undefined reference to `fi_strerror@FABRIC_1.0'
</pre></div>

<p>There are two solutions.  One, you could search the failing build log
to identify the missing modules and add them to the compiler entry.
This may require several modules.  For example on Crusher, I added
these modules to the compiler entry and then the build succeeded.
</p>
<div class="example">
<pre class="example">modules:
  - PrgEnv-gnu/8.3.3
  - gcc/11.2.0
  - craype/2.7.16
  - cray-mpich/8.1.17
  - libfabric/1.15.0.0
</pre></div>

<p>The other solution is to load the <code>PrgEnv-gnu</code> and related
modules and then install hpctoolkit with the <code>--dirty</code> flag.
Note: only the final hpctoolkit package needs <code>--dirty</code>.  For
example,
</p>
<div class="example">
<pre class="example">spack install --only dependencies hpctoolkit +mpi os=fe
spack install --dirty hpctoolkit +mpi os=fe
</pre></div>

<p><b>Note:</b> Some very new Cray systems (eg, Sunspot at ANL) have
<code>PrgEnv-gnu</code> but use a different MPI module than
<code>cray-mpich</code>.  On such a system, continue to add the extra
modules to the compilers entry but use a spack externals entry for the
other MPI module.
</p>
<p><b>Old Cray</b>
Some older Cray systems (eg, Theta at ANL) don&rsquo;t have the
<code>mpicxx</code> wrapper.  In this case, it&rsquo;s necessary to use the
<code>+cray</code> option.  This option tells hpctoolkit&rsquo;s configure to
search for the older <code>CC</code> wrapper.
</p>
<p>Prepare the <code>PrgEnv-gnu</code> and GCC compiler the same as with a
newer Cray, then build hpctoolkit with the <code>+cray</code> option again
for the front-end arch type.
</p>
<div class="example">
<pre class="example">spack install hpctoolkit +cray os=fe
</pre></div>

<p>As with new Crays, you will likely need to add extra modules to the
compiler entry or else build with <code>--dirty</code>.
</p>
<p><b>Autotools</b> For building with autotools, use the <code>MPICXX</code>
configure variable to specify the MPI compiler, either CC or mpicxx.
Note: the <code>--enable-all-static</code> option is no longer used.
</p>
<div class="example">
<pre class="example">configure  \
    --prefix=/path/to/install/prefix  \
    --with-spack=/path/to/linux-sles15-x86_64/gcc-11.2.0  \
    MPICXX=CC    (or /path/to/mpicxx)
</pre></div>

<p><b>Old HPCToolkit Versions</b>
As of October 2022, we now always build <code>hpcprof-mpi</code> on Cray
dynamically, and the <code>+all-static</code> option no longer exists.
However, for old versions of hpctoolkit up to 2022.05.15, it is
possible to build <code>hpcprof-mpi</code> either statically or dynamically,
depending on what your system supports.  (Hpcprof-mpi is disabled for
the 2022.10.01 release.)
</p>
<p>If your Cray supports it and <code>CC</code> builds static binaries, then
you can build <code>hpcprof-mpi</code> statically with the <code>+cray</code> and
<code>+cray-static</code> options.
</p>
<div class="example">
<pre class="example">spack install hpctoolkit @2022.05.15 +cray +cray-static os=fe
</pre></div>

<p>The <code>+cray-static</code> option only applies with <code>+cray</code> (using
the CC wrapper) and only for versions up to 2022.05.15.
</p>

<a name="HPCToolkit-GUI-Interface-_0028Hpcviewer_0029"></a>
<h3 class="section">15 HPCToolkit GUI Interface (Hpcviewer)</h3>

<p>Since the 2020.12 release, the HPCToolkit GUI interface provides both
profile and trace views in a single application, i.e. hpcviewer. Prior
to that, each view was a separate program: hpcviewer to analyze the
profile database, and hpctraceviewer to display the traces.
</p>
<p>We provide binary distributions for hpcviewer on Linux (x86_64,
ppc64le and aarch64), Windows (x86_64) and MacOS (x86_64, M1 and M2).
HPCToolkit databases are platform-independent and it is common to run
hpcrun on one machine and then view the results on another machine.
</p>
<p>Starting with 2021.01, the viewer now requires Java 11 or later, plus
GTK+ 3.20 or later on Linux.
</p>
<a name="Spack-Install-1"></a>
<h4 class="subsection">15.1 Spack Install</h4>

<p>The spack install is available on Linux x86_64, little-endian ppc64le
(power8 and 9) and aarch64 ARM, and also MacOS on x86_64.  This
installs hpcviewer and includes the Java prerequisite.
</p>
<p>For the current viewers, use openjdk with the most recent version of
Java 11 for all platforms.  Currently, this is the default, but if not,
then you can add an explicit openjdk dependency.  You can check this
with <code>spack info</code> and <code>spack spec</code>.
</p>
<div class="example">
<pre class="example">spack info openjdk
spack install hpcviewer
spack install hpcviewer ^openjdk @11.0.12_7    (if needed)
</pre></div>

<p>Note: to run the viewer on Macos, you can either open the Finder and
click your way to the <code>hpcviewer.app</code> directory and double-click
on the hpcviewer icon, or else use <code>spack load hpcviewer</code> to put
<code>hpcviewer</code> on your PATH.
</p>
<a name="Manual-Install-1"></a>
<h4 class="subsection">15.2 Manual Install</h4>

<p>Binary distributions of the viewers for all supported platforms are
available at:
</p>
<div class="example">
<pre class="example"><a href="http://hpctoolkit.org/download.html">http://hpctoolkit.org/download.html</a>
</pre></div>

<p>On Linux, download the <code>linux.gtk</code> version of hpcviewer (and also
hpctraceviewer for older versions), unpack the tar files and run the
install scripts (for both viewers) with the path to the desired install
prefix.
</p>
<div class="example">
<pre class="example">./install /path/to/install/directory
</pre></div>

<p>On Windows and MacOS, download the <code>win32</code> or <code>macosx.cocoa</code>
versions and unpack the zip or dmg files in the desired directory.
Due to Apple&rsquo;s security precautions, on MacOS, you may need to use
curl or wget instead of a web browser.
</p>
<p>Note: the manual install uses the existing system version of Java (or
one of several versions with modules), whereas the spack install
includes the java prerequisite.  That is, the spack install is
self-contained and does not need to change the system java.
</p>

<a name="Building-a-New-Compiler"></a>
<h3 class="section">16 Building a New Compiler</h3>

<p>Some systems may have compilers that are too old for building
HPCToolkit or other packages.  For example, RedHat 7.x comes with gcc
4.8.x which is very old.  If your system doesn&rsquo;t already have modules
for later compilers, then you may need to build a new compiler
yourself.
</p>
<p>First, pick a directory in which to install the modules and make
subdirectories for the spack packages and module files.  In this
example, I&rsquo;m using <code>/opt/spack/Modules</code> as my top-level directory
and subdirectories <code>packages</code> and <code>modules</code>.  Edit
<code>config.yaml</code> and <code>modules.yaml</code> to add these paths.
</p>
<div class="example">
<pre class="example">config:
  install_tree:
    root: /opt/spack/Modules/packages

modules:
  default:
    roots:
      # just use one of these
      module_roots:
        tcl:  /opt/spack/Modules/modules
        lmod: /opt/spack/Modules/modules
</pre></div>

<p>Determine if your system uses TCL (environment) or Lmod modules.
Normally, the <code>module</code> command is a shell function.  TCL modules
use <code>modulecmd</code> and Lmod modules eval <code>LMOD_CMD</code>.  Edit
<code>modules.yaml</code> to enable the module type for your system.  Again,
you only need one of these (and don&rsquo;t use dotkit unless you work at
LLNL).
</p>
<div class="example">
<pre class="example">modules:
  default:
    enable:
     - tcl
     - lmod
</pre></div>

<p>Then, choose a version of gcc and use the default compiler (normally
<code>/usr/bin/gcc</code>) to build the newer version.  Currently, gcc 10.x
or 11.x is a good choice that builds robustly, has enough modern
features but is not too new to cause problems for some packages.  For
example,
</p>
<div class="example">
<pre class="example">spack install gcc@10.4.0
</pre></div>

<p>Note: it is not necessary to rebuild the new compiler with itself.
</p>
<a name="Using-the-New-Compiler"></a>
<h4 class="subsection">16.1 Using the New Compiler</h4>

<p>After building a new compiler, then you need to tell spack how to find
it.  First, use <code>module use</code> and <code>module load</code> to load the
module.  For TCL modules, the module files are in a subdirectory of
<code>module_roots</code> named after the system architecture.  For example,
</p>
<div class="example">
<pre class="example">module use /opt/spack/Modules/modules/linux-rhel7-x86_64
module load gcc-8.4.0-gcc-4.8.5-qemsqrc
</pre></div>

<p>For Lmod modules, the module directory is one level below that and the
module names are a little different.
</p>
<div class="example">
<pre class="example">module use /opt/spack/Modules/modules/linux-rhel7-x86_64/Core
module load gcc/8.4.0-dan4vbm
</pre></div>

<p>For both TCL and Lmod modules, it&rsquo;s best to put the <code>module use</code>
command in your shell&rsquo;s startup scripts so that <code>module avail</code> and
<code>module load</code> will know where to find them.  After loading the
module, run <code>spack compiler find</code>.
</p>
<div class="example">
<pre class="example">$ spack compiler find
==&gt; Added 1 new compiler to /home/krentel/.spack/linux/compilers.yaml
    gcc@8.4.0
</pre></div>

<p>Finally, always check the new entry in <code>compilers.yaml</code> and add the
name of the module to the <code>modules:</code> field.
</p>
<div class="example">
<pre class="example">- compiler:
    environment: {}
    extra_rpaths: []
    flags: {}
    modules:
    - gcc-8.4.0-gcc-4.8.5-qemsqrc
    operating_system: rhel7
    paths:
      cc:  /opt/spack/Modules/packages/linux-rhel7-x86_64/gcc-4.8.5/gcc-8.4.0-qemsqrcwkk52f6neef4kg5wvoucsroif/bin/gcc
      cxx: /opt/spack/Modules/packages/linux-rhel7-x86_64/gcc-4.8.5/gcc-8.4.0-qemsqrcwkk52f6neef4kg5wvoucsroif/bin/g++
      f77: /opt/spack/Modules/packages/linux-rhel7-x86_64/gcc-4.8.5/gcc-8.4.0-qemsqrcwkk52f6neef4kg5wvoucsroif/bin/gfortran
      fc:  /opt/spack/Modules/packages/linux-rhel7-x86_64/gcc-4.8.5/gcc-8.4.0-qemsqrcwkk52f6neef4kg5wvoucsroif/bin/gfortran
    spec: gcc@8.4.0
    target: x86_64
</pre></div>

<p>Note: as long as the spack packages and modules directories remain
intact and you don&rsquo;t remove the <code>compilers.yaml</code> entry, then this
compiler will always be available from within spack.  You can also use
this compiler outside of spack by using <code>module load</code>.  If you
want to make this your default compiler for all spack builds, then you
can specify this in <code>packages.yaml</code>.  For example,
</p>
<div class="example">
<pre class="example">packages:
  all:
    compiler: [gcc@8.4.0]
</pre></div>

<p>Also, when using the compiler from within spack, it doesn&rsquo;t matter if
you have the module loaded or not.  Spack will erase your environment
and re-add the appropriate modules automatically.
</p>
<div class="example">
<pre class="example"><a href="https://spack.readthedocs.io/en/latest/getting_started.html#compiler-configuration">https://spack.readthedocs.io/en/latest/getting_started.html#compiler-configuration</a>
</pre></div>

<a name="Bootstrapping-Environment-Modules"></a>
<h4 class="subsection">16.2 Bootstrapping Environment Modules</h4>

<p>If your system does not support modules, then you will have to add it.
If you have root access, the easiest solution is to install a system
package for modules.  If not, then use spack to install the
environment-modules package.  Source the bash or csh script in the
<code>init</code> directory to add the <code>module</code> function to your
environment.  For example,
</p>
<div class="example">
<pre class="example">spack install environment-modules
cd /path/to/environment-modules-5.3.0-ism7cdy4xverxywj27jvjstqwk5oxe2v/init
(bash)  . ./bash
(csh)   source ./csh
</pre></div>

<p>Again, add the setup command to your shell&rsquo;s startup scripts.
</p>

<a name="Spack-Mirrors"></a>
<h3 class="section">17 Spack Mirrors</h3>

<p>A spack mirror allows you to download and save a source tar file in
advance.  This is useful if your system is behind a firewall, or if you
need to manually agree to a license, or if you just don&rsquo;t want to keep
downloading the same file over and over.
</p>
<p>A mirror has a simple directory structure and is easy to set up.  Create
a top-level directory with subdirectories named after the spack packages
and copy the tar files into their package&rsquo;s subdirectory.  For example,
</p>
<div class="example">
<pre class="example">my-mirror/
   boost/
      boost-1.66.0.tar.bz2      (from boost_1_66_0.tar.bz2)
      boost-1.70.0.tar.bz2
   dyninst/
      dyninst-10.1.0.tar.gz     (from git checkout)
   ibm-java/
      ibm-java-8.0.5.30.None    (from ibm-java-sdk-8.0-5.30-ppc64le-archive.bin)
   intel-xed/
      intel-xed-2019.03.01.tar.gz    (from git checkout)
      mbuild-2019.03.01.tar.gz       (resource from git checkout)
   jdk/
      jdk-1.8.0_202.tar.gz      (from jdk-8u202-linux-x64.tar.gz)
</pre></div>

<p>Note: the names of the files in the spack mirror always follow the same,
specific format, regardless of the actual name of the tar file.  Version
is the spack name for the version (from <code>spack info</code>), and
extension is the same extension as the tar file (<code>tar.gz</code>,
<code>tar.bz2</code>, etc) or else <code>None</code> for other types of files.
</p>
<div class="example">
<pre class="example">&lt;package-name&gt; - &lt;version&gt; . &lt;extension&gt;
</pre></div>

<p>For example, the boost 1.66.0 tar file is actually named
<code>boost_1_66_0.tar.bz2</code> but is stored in the mirror as
<code>boost-1.66.0.tar.bz2</code> and <code>jdk-8u202-linux-x64.tar.gz</code> is
renamed to <code>jdk-1.8.0_202.tar.gz</code>.
</p>
<p>For packages that use a snapshot from a git repository (tag or commit
hash), clone the repository, checkout the desired version, make a tar
file and gzip the file.  (You should exclude the <code>.git</code>
subdirectory.)  But note that spack refuses to use a cached file for
the head of a branch because it is a moving target.
</p>
<p>Finally, after creating the mirror directory, add it to spack with
<code>spack mirror add</code>.  For example,
</p>
<div class="example">
<pre class="example">spack mirror add my-mirror file:///home/krentel/spack/my-mirror
spack mirror list
my-mirror    file:///home/krentel/spack/mirror
</pre></div>

<p>Note: by default, spack stores downloaded files inside the spack
repository at <code>spack/var/spack/cache</code>.  This directory is a full
spack mirror, so instead of creating a separate directory tree, you
could just copy the files into the <code>cache</code> directory.  This is
useful when <code>spack fetch</code> has trouble downloading a file.  If you
can download the file manually, or copy it from another machine, then
just rename the file as above and copy it into the spack file cache.
</p>
<p>For more information on mirrors, see:
</p>
<div class="example">
<pre class="example"><a href="https://spack.readthedocs.io/en/latest/mirrors.html">https://spack.readthedocs.io/en/latest/mirrors.html</a>
</pre></div>


<a name="Common-Problems"></a>
<h3 class="section">18 Common Problems</h3>

<a name="Unable-to-fetch-tar-file"></a>
<h4 class="subsection">18.1 Unable to fetch tar file</h4>

<p>Spack is somewhat fragile for how it downloads tar files and will
often fail for transitory network problems.  This is especially true
for packages with many dependencies.  For example:
</p>
<div class="example">
<pre class="example">==&gt; Installing m4
==&gt; Searching for binary cache of m4
==&gt; No binary for m4 found: installing from source
curl: (6) Could not resolve host: ftp.wayne.edu; Name or service not known
==&gt; Fetching https://ftpmirror.gnu.org/m4/m4-1.4.18.tar.gz
==&gt; Fetching from https://ftpmirror.gnu.org/m4/m4-1.4.18.tar.gz failed.
==&gt; Error: FetchError: All fetchers failed for m4-1.4.18-vorbvkcjfac43b7vuswsvnm6xe7w7or5
</pre></div>

<p>There are two workarounds.  First, assuming the problem is temporary,
simply wait 10 minutes or an hour and try again.  Second, you could
manually download the file(s) by some other means and copy them to
spack&rsquo;s cache directory <code>spack/var/spack/cache/&lt;package&gt;</code> or to a
spack mirror.
</p>
<a name="New-releases-break-the-build"></a>
<h4 class="subsection">18.2 New releases break the build</h4>

<p>Normally, HPCToolkit should build and work correctly with the latest
version for all of its dependencies.  But sometimes a new release will
change something and break the build.  This has happened a couple times
where a new release of Boost has broken the build for Dyninst.  Or,
maybe the latest version of gcc/g++ disallows some usage and breaks the
build.
</p>
<p>The solution is to use <code>packages.yaml</code> to specify an earlier
version until the rest of the code adapts to the change.
</p>
<a name="Failure-to-load-modules"></a>
<h4 class="subsection">18.3 Failure to load modules</h4>

<p>Spack is quite aggressive about compiling with a clean environment and
will unload modules unless they are specifically required by some config
file (<code>compilers.yaml</code> or <code>packages.yaml</code>).  This can result
in a situation where you think some compiler or build tool is available
from your environment but spack removes it during the build.
</p>
<p>In this example, I am using modules for <code>GCC/8.3.0</code> and
<code>CMake/3.8.2</code>.  Spack finds the gcc 8.3.0 compiler and I added
<code>cmake@3.8.2</code> to <code>packages.yaml</code>.  But I failed to add the
<code>modules:</code> field for gcc 8.3.0 in <code>compilers.yaml</code>.  As a
result, the build fails with:
</p>
<div class="example">
<pre class="example">cmake: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.20' not found (required by cmake)
cmake: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by cmake)
cmake: /usr/lib64/libstdc++.so.6: version `CXXABI_1.3.9' not found (required by cmake)
==&gt; Error: ProcessError: Command exited with status 1:
</pre></div>

<p>The problem is that cmake 3.8.2 was built with g++ 8.3.0, but spack is
running cmake without the GCC/8.3.0 libraries and so the build fails as
above.  One way to confirm this is to rerun <code>spack install --dirty</code>
which then succeeds.  The <code>--dirty</code> option tells spack not to
unload your modules.  Whenever the build fails with a mismatched library
as above and especially when <code>--dirty</code> fixes the problem, this is a
clear sign that spack is missing a module during the build.
</p>
<p>Although <code>--dirty</code> may make the build succeed, there should be no
case where this is necessary.  The correct solution is to fill in the
<code>modules:</code> field in <code>compilers.yaml</code> or some other config
file.  See the section on Compilers above.
</p><hr>



<div style="width: 100%; font-size: small;">
  <hr />
  <p style="margin: 0px; font-size: small;">
    &copy;2002-2023 <a href="http://www.rice.edu">Rice University</a>
    &bull;
    <a href="http://www.cs.rice.edu">Rice Computer Science</a>
  </p>
  <a href="http://validator.w3.org/check/referer">
    <img src="http://www.w3.org/Icons/valid-xhtml10-blue" alt="" height="15" /></a>
  <a href="http://jigsaw.w3.org/css-validator/check/referer">
    <img src="http://www.w3.org/Icons/valid-css-blue" alt="" height="15" /></a>
</div>

</body>
</html>
