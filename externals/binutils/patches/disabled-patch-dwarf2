Replace the linear search in lookup_address_in_function_table() and
comp_unit_contains_address() in dwarf2.c with a splay tree.

diff -Naurb version-binutils-2.17.orig/binutils-2.17/bfd/dwarf2.c version-binutils-2.17/binutils-2.17/bfd/dwarf2.c
--- version-binutils-2.17.orig/binutils-2.17/bfd/dwarf2.c	2009-08-20 13:52:55.000000000 -0500
+++ version-binutils-2.17/binutils-2.17/bfd/dwarf2.c	2009-11-18 15:48:21.000000000 -0600
@@ -145,6 +145,8 @@
   bfd_vma high;
 };
 
+struct arange_node;
+
 /* A minimal decoding of DWARF2 compilation units.  We only decode
    what's needed to get to the line number information.  */
 
@@ -209,6 +211,10 @@
   /* Base address for this unit - from DW_AT_low_pc attribute of
      DW_TAG_compile_unit DIE */
   bfd_vma base_address;
+
+  /* Roots of the splay trees for the comp_unit and funcinfo ranges. */
+  struct arange_node *unit_splay_tree;
+  struct arange_node *func_splay_tree;
 };
 
 /* This data structure holds the information of an abbrev.  */
@@ -762,6 +768,277 @@
   unsigned int stack: 1;
 };
 
+/*----------------  Begin Splay Trees  ----------------*/
+
+#define USE_BROKEN_BEST_FIT_HACK  1
+
+struct arange_node
+{
+    bfd_vma low;
+    bfd_vma high;
+    struct arange_node *left;
+    struct arange_node *right;
+    struct funcinfo *func;
+    unsigned long orig_len;
+};
+
+/*
+ *  The Sleator-Tarjan top-down splay algorithm.
+ *
+ *  This macro is the body of the splay function.  It rotates the
+ *  interval containing "key" to the root, if there is one, else the
+ *  new root will be an adjacent interval (left or right).
+ *
+ *  Nodes in the tree should be a struct with name "type" containing
+ *  at least these four field names with these types:
+ *
+ *    start : same type as key,
+ *    end   : same type as key,
+ *    left  : struct type *,
+ *    right : struct type *.
+ *
+ *  "root" is a struct type * and is reset to the new root.
+ *
+ *  Intervals are semi-inclusive: [start, end).
+ */
+
+#define INTERVAL_SPLAY_TREE(type, root, key, start, end, left, right)	\
+    do {								\
+	struct type dummy_node;						\
+	struct type *ltree_max, *rtree_min, *yyy;			\
+	if ((root) != NULL) {						\
+	    ltree_max = rtree_min = &dummy_node;			\
+	    for (;;) {							\
+		if ((key) < (root)->start) {				\
+		    if ((yyy = (root)->left) == NULL)			\
+			break;						\
+		    if ((key) < yyy->start) {				\
+			(root)->left = yyy->right;			\
+			yyy->right = (root);				\
+			(root) = yyy;					\
+			if ((yyy = (root)->left) == NULL)		\
+			    break;					\
+		    }							\
+		    rtree_min->left = (root);				\
+		    rtree_min = (root);					\
+		} else if ((key) >= (root)->end) {			\
+		    if ((yyy = (root)->right) == NULL)			\
+			break;						\
+		    if ((key) >= yyy->end) {				\
+			(root)->right = yyy->left;			\
+			yyy->left = (root);				\
+			(root) = yyy;					\
+			if ((yyy = (root)->right) == NULL)		\
+			    break;					\
+		    }							\
+		    ltree_max->right = (root);				\
+		    ltree_max = (root);					\
+		} else							\
+		    break;						\
+		(root) = yyy;						\
+	    }								\
+	    ltree_max->right = (root)->left;				\
+	    rtree_min->left = (root)->right;				\
+	    (root)->left = dummy_node.right;				\
+	    (root)->right = dummy_node.left;				\
+	}								\
+    } while (0)
+
+static struct arange_node *
+arange_tree_splay(struct arange_node *root, bfd_vma addr)
+{
+    INTERVAL_SPLAY_TREE(arange_node, root, addr, low, high, left, right);
+    return root;
+}
+
+/*
+ * Add the range [low, high) for the function "new_func" to the tree
+ * "root" and return the new root.
+ *
+ * The original binutils code compares each arange with its own
+ * length, but then treats it as the length of the first function in
+ * the func list.  We emulate the original (broken?) behavior when
+ * USE_BROKEN_BEST_FIT_HACK is set.
+ *
+ * Note: we use this function to add ranges to both the function tree
+ * and the comp-unit tree, so we can't assume new_func != NULL.
+ */
+static struct arange_node *
+arange_tree_add_range(struct arange_node *root,
+		      struct funcinfo *new_func,
+		      bfd_vma low, bfd_vma high)
+{
+    unsigned long new_len = high - low;
+    unsigned long first_func_len = new_len;
+    struct arange_node *tmp, *ltree;
+
+#if USE_BROKEN_BEST_FIT_HACK
+    if (new_func != NULL)
+	first_func_len = new_func->arange.high - new_func->arange.low;
+#endif
+
+    /* Binutils generates many intervals with low == high, but those
+     * don't belong in the tree.
+     */
+    if (low >= high)
+	return root;
+
+    if (root == NULL) {
+	root = bfd_malloc(sizeof(struct arange_node));
+	root->low = low;
+	root->high = high;
+	root->left = NULL;
+	root->right = NULL;
+	root->func = new_func;
+	root->orig_len = first_func_len;
+	return root;
+    }
+
+    /*
+     * Advance low from left to right, break original range into
+     * subranges at every endpoint, and update each range as needed.
+     *
+     * Technically, this could be O(n^2) to build the tree from
+     * scratch, but only if most intervals overlap most other
+     * intervals, and that never happens in practice.  Mergesort,
+     * would build a tree from scratch in total time O(nlog n).
+     */
+    while (low < high)
+    {
+	root = arange_tree_splay(root, low);
+	if (root->low == low && high < root->high) {
+	    /*
+	     * Case 1: break off left side of root.
+	     *
+	     *   |----- new -----|
+	     *   |----- tmp -----+----- root -----|
+	     */
+	    root->low = high;
+	    tmp = bfd_malloc(sizeof(struct arange_node));
+	    tmp->low = low;
+	    tmp->high = high;
+	    if (new_len < root->orig_len) {
+		tmp->func = new_func;
+		tmp->orig_len = first_func_len;
+	    } else {
+		tmp->func = root->func;
+		tmp->orig_len = root->orig_len;
+	    }
+	    tmp->left = root->left;
+	    tmp->right = NULL;
+	    root->left = tmp;
+	    low = high;
+	}
+	else if (root->low == low) {
+	    /*
+	     * Case 2: update root if needed.
+	     *
+	     *   |----- new ------+--------------|
+	     *   |----- root -----|
+	     */
+	    if (new_len < root->orig_len) {
+		root->func = new_func;
+		root->orig_len = first_func_len;
+	    }
+	    low = root->high;
+	}
+	else if (root->low < low && low < root->high) {
+	    /*
+	     * Case 3: break off left side of root.
+	     *
+	     *                 |------- new -------|
+	     *   |---- tmp ----+---- root ----|
+	     */
+	    tmp = bfd_malloc(sizeof(struct arange_node));
+	    *tmp = *root;
+	    tmp->high = low;
+	    root->low = low;
+	    tmp->right = NULL;
+	    root->left = tmp;
+	    /* low doesn't advance in this case. */
+	}
+	else {
+	    /*
+	     * Case 4: low is not within an existing range.  Split the
+	     * tree on either side of low so that root (if nonempty)
+	     * is the first range right of low.  Then, split off the
+	     * left side of the new range.
+	     *
+	     *                     |--- tmp ---+--- new ---|
+	     *   |-- ltree --|                 |------ root ------|
+	     */
+	    if (low < root->low) {
+		ltree = root->left;
+		root->left = NULL;
+	    } else {
+		ltree = root;
+		root = arange_tree_splay(root->right, low);
+		ltree->right = NULL;
+	    }
+	    tmp = bfd_malloc(sizeof(struct arange_node));
+	    tmp->low = low;
+	    tmp->high = (root == NULL || high < root->low) ? high : root->low;
+	    tmp->func = new_func;
+	    tmp->orig_len = first_func_len;
+	    tmp->left = ltree;
+	    tmp->right = root;
+	    root = tmp;
+	    low = tmp->high;
+	}
+    }
+
+    return root;
+}
+
+/*
+ * Build the function ranges splay tree from scratch.
+ *
+ * This and make_unit_splay_tree() assume that we add all of the
+ * aranges before doing any lookups.
+ */
+static struct arange_node *
+make_func_splay_tree(struct comp_unit *unit)
+{
+    struct arange_node *root;
+    struct funcinfo *each_func;
+    struct arange *arange;
+
+    root = NULL;
+    for (each_func = unit->function_table;
+	 each_func;
+	 each_func = each_func->prev_func)
+    {
+	for (arange = &each_func->arange;
+	     arange;
+	     arange = arange->next)
+	{
+	    root = arange_tree_add_range(root, each_func,
+					 arange->low, arange->high);
+	}
+    }
+    return root;
+}
+
+/*
+ * Build the comp_unit ranges splay tree from scratch.
+ */
+static struct arange_node *
+make_unit_splay_tree(struct comp_unit *unit)
+{
+    struct arange_node *root;
+    struct arange *arange;
+
+    root = NULL;
+    for (arange = &unit->arange; arange != NULL; arange = arange->next)
+    {
+	root = arange_tree_add_range(root, NULL, arange->low, arange->high);
+    }
+
+    return root;
+}
+
+/*-----------------  End Splay Trees  -----------------*/
+
 
 #if 0 /* HPCToolkit */
 static int 
@@ -1611,25 +1888,23 @@
 				  struct funcinfo **function_ptr,
 				  const char **functionname_ptr)
 {
-  struct funcinfo* each_func;
-  struct funcinfo* best_fit = NULL;
-  struct arange *arange;
+  struct funcinfo *best_fit;
 
-  for (each_func = unit->function_table;
-       each_func;
-       each_func = each_func->prev_func)
-    {
-      for (arange = &each_func->arange;
-	   arange;
-	   arange = arange->next)
+  /* Note: this assumes that we add all of the aranges before doing
+   * any lookups.
+   */
+  if (unit->func_splay_tree == NULL)
 	{
-	  if (addr >= arange->low && addr < arange->high)
-	    {
-	      if (!best_fit ||
-		  ((arange->high - arange->low) < (best_fit->arange.high - best_fit->arange.low)))
-		best_fit = each_func;
-	    }
+      unit->func_splay_tree = make_func_splay_tree(unit);
 	}
+
+  best_fit = NULL;
+  unit->func_splay_tree = arange_tree_splay(unit->func_splay_tree, addr);
+  if (unit->func_splay_tree != NULL
+      && unit->func_splay_tree->low <= addr
+      && addr < unit->func_splay_tree->high)
+    {
+      best_fit = unit->func_splay_tree->func;
     }
 
   if (best_fit)
@@ -2283,21 +2558,29 @@
 static bfd_boolean
 comp_unit_contains_address (struct comp_unit *unit, bfd_vma addr)
 {
-  struct arange *arange;
+  bfd_boolean ans;
 
   if (unit->error)
     return FALSE;
 
-  arange = &unit->arange;
-  do
+  /* Note: this assumes that we add all of the aranges before doing
+   * any lookups.
+   */
+  if (unit->unit_splay_tree == NULL)
     {
-      if (addr >= arange->low && addr < arange->high)
-	return TRUE;
-      arange = arange->next;
+      unit->unit_splay_tree = make_unit_splay_tree(unit);
     }
-  while (arange);
 
-  return FALSE;
+  ans = FALSE;
+  unit->unit_splay_tree = arange_tree_splay(unit->unit_splay_tree, addr);
+  if (unit->unit_splay_tree != NULL
+      && unit->unit_splay_tree->low <= addr
+      && addr < unit->unit_splay_tree->high)
+    {
+      ans = TRUE;
+    }
+
+  return ans;
 }
 
 /* If UNIT contains ADDR, set the output parameters to the values for
