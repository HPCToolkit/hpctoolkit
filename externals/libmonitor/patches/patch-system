Fix a problem in monitor_real_system().  When the client runs a
program via system, we don't want the new process to be monitored.
Normally, unsetenv(LD_PRELOAD) works, but for some reason, unsetenv
does not change the environ list when run inside bash (why?).

The solution is to copy the environ list, omit LD_PRELOAD and then use
execve() to explicitly set the new environment.


Index: trunk/src/fork.c
===================================================================
--- trunk/src/fork.c	(revision 131)
+++ trunk/src/fork.c	(revision 132)
@@ -46,6 +46,7 @@
 
 #include "config.h"
 #include <sys/types.h>
+#include <sys/mman.h>
 #include <sys/wait.h>
 #ifdef MONITOR_DYNAMIC
 #include <dlfcn.h>
@@ -63,6 +64,8 @@
 #include "common.h"
 #include "monitor.h"
 
+extern char **environ;
+
 /*
  *----------------------------------------------------------------------
  *  GLOBAL VARIABLES and EXTERNAL FUNCTIONS
@@ -70,6 +73,8 @@
  */
 
 #define MONITOR_INIT_ARGV_SIZE  64
+#define MONITOR_INIT_ENVIRON_SIZE  250
+#define MONITOR_DEFAULT_PAGESIZE  4096
 
 typedef pid_t fork_fcn_t(void);
 typedef int execv_fcn_t(const char *path, char *const argv[]);
@@ -97,6 +102,8 @@
 static sigprocmask_fcn_t  *real_sigprocmask = NULL;
 static malloc_fcn_t  *real_malloc = NULL;
 
+static char *newenv_array[MONITOR_INIT_ENVIRON_SIZE];
+
 /*
  *----------------------------------------------------------------------
  *  INTERNAL HELPER FUNCTIONS
@@ -122,6 +129,64 @@
 }
 
 /*
+ *  Copy the process's environment and omit LD_PRELOAD.  This is used
+ *  by monitor_real_system() so that we don't monitor the system
+ *  function.
+ *
+ *  For most binaries, unsetenv(LD_PRELAOD) would work.  But inside
+ *  bash, unsetenv() doesn't seem to change environ (why!?).  Also,
+ *  copying environ is safer than modifying it in place if environ is
+ *  somehow read-only.
+ */
+static char **
+monitor_copy_environ(void)
+{
+    char **newenv = &newenv_array[0];
+    size_t pagesize = MONITOR_DEFAULT_PAGESIZE;
+    size_t size;
+    int k, n, prot, flags;
+
+    /* Count the size of the environ array. */
+    for (n = 0; environ[n] != NULL; n++) {
+    }
+    n += 2;
+
+    /* mmap() a larger array if needed. */
+    if (n > MONITOR_INIT_ENVIRON_SIZE) {
+#ifdef _SC_PAGESIZE
+	if ((size = sysconf(_SC_PAGESIZE)) > 0) {
+	    pagesize = size;
+	}
+#endif
+	size = n * sizeof(char *);
+	size = ((size + pagesize - 1)/pagesize) * pagesize;
+	prot = PROT_READ | PROT_WRITE;
+#if defined(MAP_ANONYMOUS)
+	flags = MAP_PRIVATE | MAP_ANONYMOUS;
+#else
+	flags = MAP_PRIVATE | MAP_ANON;
+#endif
+	newenv = mmap(NULL, size, prot, flags, -1, 0);
+	if (newenv == MAP_FAILED) {
+	    MONITOR_ERROR("mmap failed, size: %ld, errno: %d\n",
+			  size, errno);
+	}
+    }
+
+    /* Copy environ and omit LD_PRELOAD. */
+    n = 0;
+    for (k = 0; environ[k] != NULL; k++) {
+	if (strstr(environ[k], "LD_PRELOAD") == NULL) {
+	    newenv[n] = environ[k];
+	    n++;
+	}
+    }
+    newenv[n] = NULL;
+
+    return newenv;
+}
+
+/*
  *  Copy the execl() argument list of first_arg followed by arglist
  *  into an argv array, including the terminating NULL.  If envp is
  *  non-NULL, then there is an extra argument after NULL.  va_start
@@ -441,8 +506,6 @@
  *  (2) provide pre/post_fork() callbacks, and (3) selectively monitor
  *  or not the child process.  Note: the libc system() does a direct
  *  syscall for fork, thus bypassing our override.
- *
- *  For now, always un-monitor the child by just unsetting LD_PRELOAD.
  */
 #define SHELL  "/bin/sh"
 static int
@@ -452,19 +515,20 @@
     sigset_t sigchld_set, old_set;
     void *user_data = NULL;
     char *arglist[4];
+    char *who;
     pid_t pid;
     int status;
 
     monitor_fork_init();
-    MONITOR_DEBUG("(%s) command = %s\n",
-		  (callback ? "appl" : "client"), command);
+    who = (callback ? "appl" : "client");
+    MONITOR_DEBUG("(%s) command = %s\n", who, command);
     /*
      * command == NULL tests if the shell is available and returns
      * non-zero if yes.
      */
     if (command == NULL) {
 	status = !access(SHELL, X_OK);
-	MONITOR_DEBUG("status = %d\n", status);
+	MONITOR_DEBUG("(%s) status = %d\n", who, status);
 	return (status);
     }
     /*
@@ -476,7 +540,7 @@
     sigaddset(&sigchld_set, SIGCHLD);
 
     if (callback) {
-	MONITOR_DEBUG1("calling monitor_pre_fork() ...\n");
+	MONITOR_DEBUG("(%s) calling monitor_pre_fork() ...\n", who);
 	user_data = monitor_pre_fork();
     }
     (*real_sigaction)(SIGINT, &ign_act, &old_int);
@@ -486,11 +550,13 @@
     pid = (*real_fork)();
     if (pid < 0) {
 	/* Fork failed. */
-	MONITOR_DEBUG1("real fork failed\n");
+	MONITOR_DEBUG("(%s) real fork failed\n", who);
 	status = -1;
     }
     else if (pid == 0) {
 	/* Child process. */
+	MONITOR_DEBUG("(%s) child process about to exec, parent = %d\n",
+		      who, getppid());
 	(*real_sigaction)(SIGINT, &old_int, NULL);
 	(*real_sigaction)(SIGQUIT, &old_quit, NULL);
 	(*real_sigprocmask)(SIG_SETMASK, &old_set, NULL);
@@ -498,8 +564,8 @@
 	arglist[1] = "-c";
 	arglist[2] = (char *)command;
 	arglist[3] = NULL;
-	unsetenv("LD_PRELOAD");
-	(*real_execv)("/bin/sh", arglist);
+	(*real_execve)(SHELL, arglist,
+		       callback ? environ : monitor_copy_environ());
 	monitor_real_exit(127);
     }
     else {
@@ -516,11 +582,11 @@
     (*real_sigprocmask)(SIG_SETMASK, &old_set, NULL);
 
     if (callback) {
-	MONITOR_DEBUG1("calling monitor_post_fork() ...\n");
+	MONITOR_DEBUG("(%s) calling monitor_post_fork() ...\n", who);
 	monitor_post_fork(pid, user_data);
     }
 
-    MONITOR_DEBUG("status = %d\n", status);
+    MONITOR_DEBUG("(%s) status = %d\n", who, status);
     return (status);
 }
 
