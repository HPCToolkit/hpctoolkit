Matt's patch to fix the O(n^2) symbol matching bottleneck.

diff -Naurb symtabAPI.orig/src/core/symtabAPI/src/Object-elf.C symtabAPI/src/core/symtabAPI/src/Object-elf.C
--- symtabAPI.orig/src/core/symtabAPI/src/Object-elf.C	2008-04-11 15:46:40.000000000 -0500
+++ symtabAPI/src/core/symtabAPI/src/Object-elf.C	2009-03-03 15:19:00.000000000 -0600
@@ -1932,26 +1932,61 @@
 		}
 	} /* end fixSymbolsInModule */
 
-void fixSymbolsInModuleByRange(string &moduleName,
-			       Dwarf_Addr modLowPC, Dwarf_Addr modHighPC,
-			       hash_map<string, std::vector< Symbol *> > *symbols_)
-{
-    string symName;
-    std::vector< Symbol *> syms;
-    Symbol *sym;
+typedef struct {
+   Address low;
+   Address high;
+   std::string module_name;
+} module_range_t;
     
-    hash_map< string, std::vector< Symbol *> >::iterator iter = symbols_->begin();
-    for(;iter!=symbols_->end();iter++)
+struct SortModules
+{
+   bool operator()(const module_range_t &a, const module_range_t &b) {
+      return a.low < b.low;
+   }
+};
+
+unsigned fixSymbolsInModuleByRange(std::vector<module_range_t> &modules,
+                                   hash_map<string, std::vector<Symbol*> > &symbols)
+{
+   unsigned nsyms_altered = 0;
+
+   hash_map< string, std::vector< Symbol *> >::iterator iter = symbols.begin();
+   for (;iter!=symbols.end();iter++)
     {
-    	symName = iter->first;
-	syms = iter->second;
-    	for( unsigned int i = 0; i < syms.size(); i++ ) {
-    		sym = syms[i];
-			if (sym->getAddr() >= modLowPC && sym->getAddr() < modHighPC) {
-			    (*symbols_)[symName][i]->setModuleName(moduleName);
+      std::string symName = iter->first;
+      std::vector<Symbol *> & syms = iter->second;
+
+      for ( unsigned int i = 0; i < syms.size(); i++ ) 
+      {
+         Symbol *sym = syms[i];
+
+         unsigned high = modules.size(); 
+         unsigned low = 0;
+         unsigned mid;
+         unsigned last = high+1;
+         for (;;) {
+            Address sym_addr = sym->getAddr();
+            mid = (high + low) / 2;
+            if (mid == last) {
+               break;
 		    }
+            last = mid;
+            if (sym_addr >= modules[mid].low && sym_addr < modules[mid].high) {
+               sym->setModuleName(modules[mid].module_name);
+               nsyms_altered++;
+               break;
 		}
+            else if (sym_addr < modules[mid].low) {
+               high = mid;
     }
+            else if (sym_addr > modules[mid].high) {
+               low = mid;
+            }
+         }
+      }
+   }
+
+   return nsyms_altered;
 }
 
 bool Object::fix_global_symbol_modules_static_dwarf(Elf_X &elf)
@@ -1959,7 +1994,7 @@
   /* Initialize libdwarf. */
   Dwarf_Debug dbg;
 
-									  
+  std::vector<module_range_t> module_ranges;
   int status = dwarf_elf_init( elf.e_elfp(), DW_DLC_READ, & pd_dwarf_handler, getErrFunc(), & dbg, NULL);
   if( status != DW_DLV_OK ) {
      return false;
@@ -2009,8 +2044,11 @@
 	    assert(status == DW_DLV_OK);
 	    
 	    // Set module names for all symbols that belong to the range
-	    fixSymbolsInModuleByRange(moduleName, modLowPC, modHighPC,
-				      &symbols_);
+       module_range_t mod;
+       mod.low = modLowPC;
+       mod.high = modHighPC;
+       mod.module_name = moduleName;
+       module_ranges.push_back(mod);
 		}
 	else {
 		/* Acquire declFileNoToName. */
@@ -2027,14 +2065,14 @@
 				}
 			dwarf_dealloc( dbg, declFileNoToName, DW_DLA_LIST );	
 			} /* end if the srcfile information was available */
-		else {
-			//bperr( "Unable to determine modules (%s): no code range or source file information available.\n", moduleName.c_str() );
-			} /* end if no source file information available */
 		} /* end if code range information unavailable */
-		
 	} /* end scan over CU headers. */
-
   /* Clean up. */
+  if (module_ranges.size()) {
+     std::sort(module_ranges.begin(), module_ranges.end(), SortModules());
+     fixSymbolsInModuleByRange(module_ranges, symbols_);
+  }
+
   status = dwarf_finish( dbg, NULL );  
   assert( status == DW_DLV_OK );
   return true;
